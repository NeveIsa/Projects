
FAT

FAT, or File Allocation Table, is a file system that is designed to keep track of allocation status of clusters on a hard drive. Developed in 1977 by Microsoft Corporation, FAT was originally intended to be a file system for the Microsoft Disk BASIC interpreter. FAT was quickly incorporated into an early version of Tim Patterson's QDOS, which was a moniker for "Quick and Dirty Operating System". Microsoft later purchased the rights to QDOS and released it under Microsoft branding as PC-DOS and later, MS-DOS.
Contents

    1 Specification
    2 Structure
        2.1 Boot Record
        2.2 FATs
        2.3 Root Directory
        2.4 Data Area
        2.5 Clusters
        2.6 Wasted Sectors
        2.7 FAT Entry Values
    3 Versions
        3.1 FAT12
        3.2 FAT16
        3.3 FAT32
            3.3.1 Limitations with Windows 2000 & Windows XP
        3.4 exFAT (sometimes incorrectly called FAT64)
        3.5 Comparison of FAT Versions
    4 Uses
    5 Data Recovery
    6 File Slack
    7 FAT Advantages
    8 FAT Disadvantages
    9 FAT date and time values
    10 External links
        10.1 ExFAT
        10.2 textFAT
    11 Tools
        11.1 exFAT

Specification

FAT is described by Microsoft in Microsoft's FAT32 specification. Despite the name, the document includes descriptions of FAT12 and FAT16.

Closely related standards are: ECMA 107 and ISO/EIC 9293, which only cover FAT12 and FAT16, and also are somewhat more restricted than the file system described by Microsoft's document.
Structure
Boot sector 	More reserved
sectors (optional) 	FAT #1 	FAT #2 	Root directory
(FAT12/16 only) 	Data region
(rest of disk)
Boot Record

When a computer is powered on, a POST (power-on self test) is performed, and control is then transferred to the Master boot record (MBR). The MBR is present no matter what file system is in use, and contains information about how the storage device is logically partitioned. When using a FAT file system, the MBR hands off control of the computer to the Boot Record, which is the first sector on the partition. The Boot Record, which occupies a reserved area on the partition, contains executable code, in addition to information such as an OEM identifier, number of FATs, media descriptor (type of storage device), and information about the operating system to be booted. Once the Boot Record code executes, control is handed off to the operating system installed on that partition.
FATs

The primary task of the File Alocation Tables are to keep track of the allocation status of clusters, or logical groupings of sectors, on the disk drive. There are four different possible FAT entries: allocated (along with the address of the next cluster associated with the file), unallocated, end of file, and bad sector.

In order to provide redundancy in case of data corruption, two FATs, FAT1 and FAT2, are stored in the file system. FAT2 is a typically a duplicate of FAT1. However, FAT mirroring can be disabled on a FAT32 drive, thus enabling any of the FATs to become the Primary FAT. This possibly leaves FAT1 empty, which can be deceiving.
Root Directory

The Root Directory, sometimes referred to as the Root Folder, contains an entry for each file and directory stored in the file system. This information includes the file name, starting cluster number, and file size. This information is changed whenever a file is created or subsequently modified. Root directory has a fixed size of 512 entries on a hard disk and the size on a floppy disk depends. With FAT32 it can be stored anywhere within the partition, although in previous versions it is always located immediately following the FAT region.
Data Area

The Boot Record, FATs, and Root Directory are collectively referred to as the System Area. The remaining space on the logical drive is called the Data Area, which is where files are actually stored. It should be noted that when a file is deleted by the operating system, the data stored in the Data Area remains intact until it is overwritten.
Clusters

In order for FAT to manage files with satisfactory efficiency, it groups sectors into larger blocks referred to as clusters. A cluster is the smallest unit of disk space that can be allocated to a file, which is why clusters are often called allocation units. Each cluster can be used by one and only one resident file. Only the "data area" is divided into clusters, the rest of the partition is simply sectors. Cluster size is determined by the size of the disk volume and every file must be allocated an even number of clusters. Cluster sizing has a significant impact on performance and disk utilization. Larger cluster sizes result in more wasted space because files are less likely to fill up an even number of clusters.

The size of one cluster is specified in the Boot Record and can range from a single sector (512 bytes) to 128 sectors (65536 bytes). The sectors in a cluster are continuous, therefore each cluster is a continuous block of space on the disk. Note that only one file can be allocated to a cluster. Therefore if a 1KB file is placed within a 32KB cluster there are 31KB of wasted space. The formula for determining clusters in a partition is (# of Sectors in Partition) - (# of Sectors per Fat * 2) - (# of Reserved Sectors) ) / (# of Sectors per Cluster).
Wasted Sectors

Wasted Sectors (a.k.a. partition slack) are a result of the number of data sectors not being evenly distributed by the cluster size. It's made up of unused bytes left at the end of a file. Also, if the partition as declared in the partition table is larger than what is claimed in the Boot Record the volume can be said to have wasted sectors. Small files on a hard drive are the reason for wasted space and the bigger the hard drive the more wasted space there is.
FAT Entry Values


FAT12

0x000 (Free Cluster)
0x001 (Reserved Cluster)
0x002 - 0xFEF (Used cluster; value points to next cluster)
0xFF0 - 0xFF6 (Reserved values)
0xFF7 (Bad cluster)
0xFF8 - 0xFFF (Last cluster in file)

FAT16

0x0000 (Free Cluster)
0x0001 (Reserved Cluster)
0x0002 - 0xFFEF (Used cluster; value points to next cluster)
0xFFF0 - 0xFFF6 (Reserved values)
0xFFF7 (Bad cluster)
0xFFF8 - 0xFFFF (Last cluster in file)

FAT32

0x?0000000 (Free Cluster)
0x?0000001 (Reserved Cluster)
0x?0000002 - 0x?FFFFFEF (Used cluster; value points to next cluster)
0x?FFFFFF0 - 0x?FFFFFF6 (Reserved values)
0x?FFFFFF7 (Bad cluster)
0x?FFFFFF8 - 0x?FFFFFFF (Last cluster in file)

Note: FAT32 uses only 28 of 32 possible bits, the upper 4 bits should be left alone. Typically these bits are zero, and are represented above by a question mark (?).
Versions

There are three variants of FAT in existence: FAT12, FAT16, and FAT32.
FAT12

    FAT12 is the oldest type of FAT that uses a 12 bit file allocation table entry.
    FAT12 can hold a max of 4,084 clusters (which is 212 clusters minus a few values that are reserved for values used in the FAT).
    It is used for floppy disks and hard drive partitions that are smaller than 16 MB.
    All 1.44 MB 3.5" floppy disks are formatted using FAT12.
    Cluster size that is used is between 0.5 KB to 4 KB.

FAT16

    It is called FAT16 because all entries are 16 bit.
    FAT16 can hold a max of 65,524 addressable units
    It is used for small and moderate sized hard disk volumes.

FAT32

FAT32 is the enhanced version of the FAT system implemented beginning with Windows 95 OSR2, Windows 98, and Windows Me. Features include:

    Drives of up to 2 terabytes are supported (Windows 2000 only supports up to 32 gigabytes)
    Since FAT32 uses smaller clusters (of 4 kilobytes each), it uses hard drive space more efficiently. This is a 10 to 15 percent improvement over FAT or FAT16.
    The limitations of FAT or FAT 16 on the number of root folder entries have been eliminated. In FAT32, the root folder is an ordinary cluster chain, and can be located anywhere on the drive.
    File allocation mirroring can be disabled in FAT32. This allows a different copy of the file allocation table then the default to be active.

Limitations with Windows 2000 & Windows XP

    Clusters cannot be 64KB or larger.
    Cannot decrease cluster size that will result in the the FAT being larger than 16 MB minus 64KB in size.
    Cannot contain fewer than 65,527 clusters.
    Maximum of 32KB per cluster.
    Windows XP: The Windows XP installation program will not allow a user to format a drive of more than 32GB using the FAT32 file system. Using the installation program, the only way to format a disk greater than 32GB in size is to use NTFS. A disk larger than 32GB in size can be formatted with FAT32 for use with Windows XP if the system is booted from a Windows 98 or Windows ME startup disk, and formatted using the tool that will be on the disk.

exFAT (sometimes incorrectly called FAT64)

exFAT (also know as Extended File Allocation Table or exFAT) is Microsoft's latest version of FAT and works with Windows Embedded CE 6.0, Windows XP/Server 2003 (with a KB patch, Vista/Server 2008 SP 1 & Later, and Windows 7. Features include:

    Largest file size is 264 bytes (16 exabytes) vs. FAT32's maximum file size of 4GB.
    Has transaction support using Transaction-Safe Extended FAT File System (TexFAT). (Not released yet in Desktop/Server OS)
    Speeds up storage allocation processes by using free space bitmaps.
    Support UTC timestamps (Vista/Server 2008 SP1 does not support UTC, UTC support came out with SP2)
    Maximum Cluster size of 32MB (Fat32 is 32KB)
    Sector sizes from 512 bytes to 4096 bytes in size
    Maximum FAT supportable volume size of 128PB
    Maximum Subdirectory size of 256MB which can support up to over 2 million files in a singlr subdirectory
    Uses a Bitmap for cluster allocation
    Supports File Permissions (Not released yet in Desktop/Server OS)
    Has been selected as the exclusive file system of the SDXC memory card by the SD Association

Although Microsoft has published some information on exFAT, there are more technical specifications available from third parties. For example, here is a detailed presentation on exFAT.

Another published technical paper that goes in the internals in great detail is in the SANS Reading Room at: Reverse Engineering the Microsoft exFAT File System
Comparison of FAT Versions

See the table at http://en.wikipedia.org/wiki/File_Allocation_Table for more detailed information about the various versions of FAT.
Uses

Due to its low cost, mobility, and non-volatile nature, flash memory has quickly become the choice medium for storing and transferring data in consumer electronic devices. The majority of flash memory storage is formatted using the FAT file system. In addition, FAT is also frequently used in electronic devices with miniature hard drives.

Examples of devices in which FAT is utilized include:

    USB thumb drives
    Digital cameras
    Digital camcorders
    Portable audio and video players
    Multifunction printers
    Electronic photo frames
    Electronic musical instruments
    Standard televisions
    PDAs

Data Recovery

Recovering directory entries from FAT filesystems as part of recovering deleted data can be accomplished by looking for entries that begin with a sigma 0xe5. When a file or directory is deleted under a FAT filesystem, the first character of its name is changed to sigma. The remainder of the directory entry information remains intact.

The pointers are also changed to zero for each cluster used by the file. Recovery tools look at the FAT to find the entry for the file. The location of the starting cluster will still be in the directory file. It is not deleted or modified. The tool will go straight to that cluster and try to recover the file using the file size to determine the number of clusters to recover. Some tools will go to the starting cluster and recover the next "X" number of clusters needed for the specific file size. However, this tool is not ideal. An ideal tool will locate "X" number of available clusters. Since files are most often fragmented, this will be a more precise way to recover the file.

An issue arises when two files in the same row of clusters are deleted. If the clusters are not in sequential order, the tool will automatically receive "X" number of clusters. However, because the file was fragmented, it's most likely that all the clusters obtained will not all contain data for that file. If these two deleted files are in the same row of clusters, it is highly unlikely the file can be recovered.
File Slack

File slack is data that starts from the end of the file written and continues to the end of the sectors designated to the file. There are two types of file slack, RAM slack and Residual slack. RAM slack starts from the end of the file and goes to the end of that sector. Residual slack then starts at the next sector and goes to the end of the cluster allocated for the file. File slack is a helpful tool when analyzing a hard drive because the old data that is not overwritten by the new file is still in tact. Go to http://www.pcguide.com/ref/hdd/file/partSizes-c.html for examples.


Cluster
	
Sample Slack Space, 50% Cluster Slack Per File
	
Sample Slack Space, 67% Cluster Slack Per File
2 kiB
	
17 MB
	
22 MB
4 kiB
	
33 MB
	
44 MB
8 kiB
	
66 MB
	
89 MB
16 kiB
	
133 MB
	
177 MB
32 kiB
	
265 MB
	
354 MB

The diagram above demonstrates the larger the cluster size used, the more disk space is wasted due to slack. This suggests it is better to use smaller cluster sizes whenever possible.
FAT Advantages

    Files available to multiple operating systems on the same computer
    Easier to switch from FAT to NTFS than vice versa
    Performs faster on smaller volumes (< 10GB)
    Does not index files, which causes slightly higher performance
    Performs better with small cache sizes (< 96MB)
    More space-efficient on small volumes (< 4GB)
    Performs better with slow disks (< 5400RPM)

FAT Disadvantages

    FAT has a fixed maximum number of clusters per partition, which means as the hard disk gets bigger the size of each cluster must increase, creating more slack space
    Doesn't natively support many abilities of NTFS such as on-the-fly compression, encryption, or advanced security using access control lists
    NTFS recommended by Microsoft for volumes larger than 32GB
    FAT slows down as the number of files on the disk increases
    FAT usually fragments files more
    FAT does not allow for indexing of files for faster searching
    FAT does not support user quotas
    FAT has minimal security features including no access control list (ACL) capability.

FAT date and time values

Python code to convert a FAT date and time value into a Python datetime object.

import datetime

def FromFatDateTime(fat_date_time):
  """Converts a FAT date and time into a Python datetime object.

  FAT date time is mainly used in DOS/Windows file formats and FAT.

  The FAT date and time is a 32-bit value containing two 16-bit values:
    * The date (lower 16-bit).
      * bits 0 - 4:  day of month, where 1 represents the first day
      * bits 5 - 8:  month of year, where 1 represent January
      * bits 9 - 15: year since 1980
    * The time of day (upper 16-bit).
      * bits 0 - 4: seconds (in 2 second intervals)
      * bits 5 - 10: minutes
      * bits 11 - 15: hours

  Args:
    fat_date_time: The 32-bit FAT date time.

  Returns:
    A datetime object containing the date and time or None.
  """
  day_of_month = (fat_date_time & 0x1f)
  month = ((fat_date_time >> 5) & 0x0f)
  year = (fat_date_time >> 9) & 0x7f

  if day_of_month < 0 or day_of_month > 30 or month < 0 or month > 11:
    return None

  fat_date_time >>= 16

  seconds = (fat_date_time & 0x1f) * 2
  minutes = (fat_date_time >> 5) & 0x3f
  hours = (fat_date_time >> 11) & 0x1f

  if hours > 23 or minutes > 59 or seconds > 59:
    return None

  return datetime.datetime(
      1980 + year, month, day_of_month, hours, minutes, seconds)

External links

    http://en.wikipedia.org/wiki/File_Allocation_Table
    http://www.microsoft.com
    http://www.ntfs.com
    http://www.ntfs.com/ntfs_vs_fat.htm
    http://support.microsoft.com/kb/q154997/#XSLTH3126121123120121120120
    http://www.dewassoc.com/kbase/hard_drives/boot_sector.htm
    http://home.teleport.com/~brainy/fat32.htm
    http://www2.tech.purdue.edu/cpt/courses/cpt499s/
    http://home.no.net/tkos/info/fat.html
    http://web.ukonline.co.uk/cook/fat32.htm
    http://www.ntfs.com/fat-systems.htm
    http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx
    http://support.microsoft.com/kb/q140418

ExFAT

    Wikipedia: ExFAT
    exFAT File System
    Reverse Engineering the Microsoft exFAT File System, by Robert Shullich, December 1, 2009
    Extended FAT file system, by Jeff Hamm, December 2009
    Demystifying the Microsoft Extended FAT File System (exFAT), by Robert Shullich, September 20, 2010
    Windows Phone 7 : Implications For Digital Forensic Investigators, by Yung Anh Le, 2012

textFAT

    TexFAT Overview (Windows Embedded CE 6.0), by Microsoft
    TexFAT Padding Directory Entry

Tools
exFAT

    Open Source exFAT file system implementation

Category:

    File Systems

Navigation menu

    Log in
    Request account

    Page
    Discussion

    Read
    View source
    View history

    Main Page
    Categories

About forensicswiki.org:

    Recent changes
    Random page

Tools

    What links here
    Related changes
    Special pages
    Printable version
    Permanent link
    Page information

    This page was last modified on 1 August 2014, at 04:47.
    This page has been accessed 139,029 times.

    Privacy policy
    About ForensicsWiki
    Disclaimers

    Powered by MediaWiki


	    printf("\ni--------- %d\n",i);

Stack Exchange Inbox Reputation and Badges
sign up log in tour help

Stack Overflow

    Questions
    Jobs
    Documentation
    Tags
    Users
    Badges

    Ask Question

x Dismiss
Join the Stack Overflow Community
Stack Overflow is a community of 6.5 million programmers, just like you, helping each other.
Join them; it only takes a minute:
Sign up
How do function pointers in C work?
up vote
728
down vote
favorite
604
	

I had some experience lately with function pointers in C.

So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.
c function-pointers
shareimprove this question
	
asked May 8 '09 at 15:49
	
community wiki

Yuval Adam
	
17 	 
	
Also: For a bit of an in-depth analysis of C pointers, see blogs.oracle.com/ksplice/entry/the_ksplice_pointer_challenge‌​. Also, Programming from the Ground Up shows how they work on the machine level. Understanding C's "memory model" is very useful for understanding how C pointers work. – Abbafei May 22 '13 at 11:17
3 	 
	
Great info. By the title though, I would have expected to really see an explanation of how "function pointers work", not how they are coded :) – Bogdan Alexandru Aug 28 '14 at 12:39
26 	 
	
"How do function pointers in C work?" Just fine, thanks. – Keith Thompson Nov 17 '14 at 19:07
add a comment
11 Answers
active
oldest
votes
up vote
889
down vote
accepted
	
Functions pointers in C

Let's start with a basic function which we will be pointing to:

int addInt(int n, int m) {
    return n+m;
}

First thing, lets define a pointer to a function which receives 2 ints and returns and int:

int (*functionPtr)(int,int);

Now we can safely point to our function:

functionPtr = &addInt;

Now that we have a pointer to the function, lets use it:

int sum = (*functionPtr)(2, 3); // sum == 5

Passing the pointer to another function is basically the same:

int add2to3(int (*functionPtr)(int, int)) {
    return (*functionPtr)(2, 3);
}

We can use function pointers in return values as well (try to keep up, it gets messy):

// this is a function called functionFactory which receives parameter n
// and returns a pointer to another function which receives two ints
// and it returns another int
int (*functionFactory(int n))(int, int) {
    printf("Got parameter %d", n);
    int (*functionPtr)(int,int) = &addInt;
    return functionPtr;
}

But it's much nicer to use a typedef:

typedef int (*myFuncDef)(int, int);
// note that the typedef name is indeed myFuncDef

myFuncDef functionFactory(int n) {
    printf("Got parameter %d", n);
    myFuncDef functionPtr = &addInt;
    return functionPtr;
}

shareimprove this answer
	
edited May 20 '15 at 13:25
idmean
8,03262455
	
answered May 8 '09 at 15:49
Yuval Adam
88k63240332
	
9 	 
	
Thanks for the great info. Could you add some insight on where function pointers are used or happen to be particularly useful? – Rich.Carpenter May 8 '09 at 15:55
175 	 
	
"functionPtr = &addInt;" can also be written (and often is) as " functionPtr = addInt;" which is also valid since the standard says that a function name in this context is converted to the address of the function. – hlovdal May 9 '09 at 14:39
8 	 
	
hlovdal, in this context it's interesting to explain that this is what enables one to write functionPtr = ******************addInt; – Johannes Schaub - litb May 10 '09 at 17:54
53 	 
	
@Rich.Carpenter I know this is 4 years too late, but I figure other people might benefit from this: Function pointers are useful for passing functions as parameters to other functions. It took a lot of searching for me to find that answer for some odd reason. So basically, it gives C pseudo first-class functionality. – giant91 Oct 13 '13 at 2:28
7 	 
	
@Rich.Carpenter: function pointers are nice for runtime CPU detection. Have multiple versions of some functions to take advantage of SSE, popcnt, AVX, etc. At startup, set your function pointers to the best version of each function for the current CPU. In your other code, just call through the function pointer instead of having conditional branches on the CPU features everywhere. Then you can do complicated logic about deciding that well, even though this CPU supports pshufb, it's slow, so the earlier implementation is still faster. x264/x265 use this extensively, and are open source. – Peter Cordes Aug 30 '15 at 2:22
show 8 more comments
up vote
209
down vote
	

Function pointers in C can be used to perform object-oriented programming in C.

For example, the following lines is written in C:

String s1 = newString();
s1->set(s1, "hello");

Yes, the -> and the lack of a new operator is a dead give away, but it sure seems to imply that we're setting the text of some String class to be "hello".

By using function pointers, it is possible to emulate methods in C.

How is this accomplished?

The String class is actually a struct with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the String class:

typedef struct String_Struct* String;

struct String_Struct
{
    char* (*get)(const void* self);
    void (*set)(const void* self, char* value);
    int (*length)(const void* self);
};

char* getString(const void* self);
void setString(const void* self, char* value);
int lengthString(const void* self);

String newString();

As can be seen, the methods of the String class are actually function pointers to the declared function. In preparing the instance of the String, the newString function is called in order to set up the function pointers to their respective functions:

String newString()
{
    String self = (String)malloc(sizeof(struct String_Struct));

    self->get = &getString;
    self->set = &setString;
    self->length = &lengthString;

    self->set(self, "");

    return self;
}

For example, the getString function that is called by invoking the get method is defined as the following:

char* getString(const void* self_obj)
{
    return ((String)self_obj)->internal->value;
}

One thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a "self object" must be passed in on each invocation. (And the internal is just a hidden struct which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)

So, rather than being able to do s1->set("hello");, one must pass in the object to perform the action on s1->set(s1, "hello").

With that minor explanation having to pass in a reference to yourself out of the way, we'll move to the next part, which is inheritance in C.

Let's say we want to make a subclass of String, say an ImmutableString. In order to make the string immutable, the set method will not be accessible, while maintaining access to get and length, and force the "constructor" to accept a char*:

typedef struct ImmutableString_Struct* ImmutableString;

struct ImmutableString_Struct
{
    String base;

    char* (*get)(const void* self);
    int (*length)(const void* self);
};

ImmutableString newImmutableString(const char* value);

Basically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the set method is not present, therefore, it cannot be called in a ImmutableString.

As for the implementation of the ImmutableString, the only relevant code is the "constructor" function, the newImmutableString:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = self->base->length;

    self->base->set(self->base, (char*)value);

    return self;
}

In instantiating the ImmutableString, the function pointers to the get and length methods actually refer to the String.get and String.length method, by going through the base variable which is an internally stored String object.

The use of a function pointer can achieve inheritance of a method from a superclass.

We can further continue to polymorphism in C.

If for example we wanted to change the behavior of the length method to return 0 all the time in the ImmutableString class for some reason, all that would have to be done is to:

    Add a function that is going to serve as the overriding length method.
    Go to the "constructor" and set the function pointer to the overriding length method.

Adding an overriding length method in ImmutableString may be performed by adding an lengthOverrideMethod:

int lengthOverrideMethod(const void* self)
{
    return 0;
}

Then, the function pointer for the length method in the constructor is hooked up to the lengthOverrideMethod:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = &lengthOverrideMethod;

    self->base->set(self->base, (char*)value);

    return self;
}

Now, rather than having an identical behavior for the length method in ImmutableString class as the String class, now the length method will refer to the behavior defined in the lengthOverrideMethod function.

I must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn't explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.

For more information on how to perform object-oriented programming in C, please refer to the following questions:

    Object-Orientation in C?
    Can you write object oriented code in C?

shareimprove this answer
	
edited Oct 14 '14 at 7:19
	
community wiki

2 revs, 2 users 100%
coobird
	
6 	 
	
This answer is horrible! Not only it implies that OO somehow depends on dot notation, it also encourages putting junk into your objects! – Alexei Averchenko Sep 16 '12 at 14:30
12 	 
	
This is OO all right, but not anywhere near the C-style OO. What you have brokenly implemented is Javascript-style prototype-based OO. To get C++/Pascal-style OO, you'd need to: 1. Have a const struct for a virtual table of each class with virtual members. 2. Have pointer to that struct in polymorphic objects. 3. Call virtual methods via the virtual table, and all other methods directly -- usually by sticking to some ClassName_methodName function naming convention. Only then you get the same runtime and storage costs as you do in C++ and Pascal. – Kuba Ober Mar 18 '13 at 21:53
9 	 
	
Working OO with a language that is not intended to be OO is always a bad idea. If you want OO and still have C just work with C++. – rbaleksandar Jul 4 '13 at 15:21
6 	 
	
@rbaleksandar Tell that to the Linux kernel developers. "always a bad idea" is strictly your opinion, with which I firmly disagree. – Jonathon Reinhart Apr 30 '15 at 12:31
   	 
	
@KubaOber which sounds like GObject, right? – underscore_d Apr 20 at 21:17
show 4 more comments
up vote
139
down vote
	

The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:

    Returns the current value on the EAX register

    int eax = ((int(*)())("\xc3 <- This returns the value of the EAX register"))();

    Write a swap function

    int a = 10, b = 20;
    ((void(*)(int*,int*))"\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3 <- This swaps the values of a and b")(&a,&b);

    Write a for-loop counter to 1000, calling some function each time

    ((int(*)())"\x66\x31\xc0\x8b\x5c\x24\x04\x66\x40\x50\xff\xd3\x58\x66\x3d\xe8\x03\x75\xf4\xc3")(&function); // calls function with 1->1000

    You can even write a recursive function that counts to 100

    const char* lol = "\x8b\x5c\x24\x4\x3d\xe8\x3\x0\x0\x7e\x2\x31\xc0\x83\xf8\x64\x7d\x6\x40\x53\xff\xd3\x5b\xc3\xc3 <- Recursively calls the function at address lol.";
    i = ((int(*)())(lol))(lol);

shareimprove this answer
	
edited Apr 22 '15 at 11:53
	
community wiki

2 revs, 2 users 98%
Lee Gao
	
6 	 
	
Note: this doesn't work if Data Execution Prevention is enabled (e.g. on Windows XP SP2+), because C strings are not normally marked as executable. – SecurityMatt Feb 12 '13 at 5:53
1 	 
	
will this work on Visual Studio? I get:error C2440: 'type cast' : cannot convert from 'const char [68]' to 'void (__cdecl *)(int *,int *)' . Any ideas? – roboto1986 Jul 3 '13 at 18:42
3 	 
	
Hi Matt! Depending on the optimization level, GCC will often inline string constants into the TEXT segment, so this will work even on newer version of windows provided that you don't disallow this type of optimization. (IIRC, the MINGW version at the time of my post over two years ago inlines string literals at the default optimization level) – Lee Jan 2 '14 at 6:20
3 	 
	
could someone please explain what's happening here? What are those weird looking string literals? – ajay Jan 20 '14 at 10:17
18 	 
	
@ajay It looks like he's writing raw hexidecimal values (for instance '\x00' is the same as '/0', they're both equal to 0) into a string, then casting the string into a C function pointer, then executing the C function pointer because he's the devil. – ejk314 Feb 21 '14 at 21:27
show 9 more comments
up vote
68
down vote
	

One of my favorite uses for function pointers is as cheap and easy iterators -

#include <stdio.h>
#define MAX_COLORS  256

typedef struct {
    char* name;
    int red;
    int green;
    int blue;
} Color;

Color Colors[MAX_COLORS];


void eachColor (void (*fp)(Color *c)) {
    int i;
    for (i=0; i<MAX_COLORS; i++)
        (*fp)(&Colors[i]);
}

void printColor(Color* c) {
    if (c->name)
        printf("%s = %i,%i,%i\n", c->name, c->red, c->green, c->blue);
}

int main() {
    Colors[0].name="red";
    Colors[0].red=255;
    Colors[1].name="blue";
    Colors[1].blue=255;
    Colors[2].name="black";

    eachColor(printColor);
}

shareimprove this answer
	
edited Jul 24 '12 at 16:40
	
community wiki

2 revs, 2 users 99%
Nick
	
7 	 
	
You should also pass a pointer to user-specified data if you want to somehow extract any output from iterations (think closures). – Alexei Averchenko Sep 16 '12 at 14:32
   	 
	
Agreed. All of my iterators look like this: int (*cb)(void *arg, ...). The return value of the iterator also lets me stop early (if nonzero). – Jonathon Reinhart Apr 30 '15 at 12:35
add a comment
up vote
19
down vote
	

Function pointers become easy to declare once you have the basic declarators:

    id: ID: ID is a
    Pointer: *D: D pointer to
    Function: D(<parameters>): D function taking <parameters> returning

While D is another declarator built using those same rules. In the end, somewhere, it ends with ID (see below for an example), which is the name of the declared entity. Let's try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it's like this

typedef int ReturnFunction(char);
typedef int ParameterFunction(void);
ReturnFunction *f(ParameterFunction *p);

As you see, it's pretty easy to build it up using typedefs. Without typedefs, it's not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That's what appears at the very left of the declaration, and is not of interest: It's added at the end if one built up the declarator already. Let's do that. Building it up consistently, first wordy - showing the structure using [ and ]:

function taking 
    [pointer to [function taking [void] returning [int]]] 
returning
    [pointer to [function taking [char] returning [int]]]

As you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I'll show both ways.
Bottom Up

Construction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i'm going to number them:

D1(char);

Inserted the char parameter directly, since it's trivial. Adding a pointer to declarator by replacing D1 by *D2. Note that we have to wrap parentheses around *D2. That can be known by looking up the precedence of the *-operator and the function-call operator (). Without our parentheses, the compiler would read it as *(D2(char p)). But that would not be a plain replace of D1 by *D2 anymore, of course. Parentheses are always allowed around declarators. So you don't make anything wrong if you add too much of them, actually.

(*D2)(char);

Return type is complete! Now, let's replace D2 by the function declarator function taking <parameters> returning, which is D3(<parameters>) which we are at now.

(*D3(<parameters>))(char)

Note that no parentheses are needed, since we want D3 to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we've done the return type, just with char replaced by void. So i'll copy it:

(*D3(   (*ID1)(void)))(char)

I've replaced D2 by ID1, since we are finished with that parameter (it's already a pointer to a function - no need for another declarator). ID1 will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It's interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times int of course.

int (*ID0(int (*ID1)(void)))(char)

I've called the identifier of the function ID0 in that example.
Top Down

This starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with function taking <parameters> returning

ID0(<parameters>)

The next thing in the description (after "returning") was pointer to. Let's incorporate it:

*ID0(<parameters>)

Then the next thing was functon taking <parameters> returning. The parameter is a simple char, so we put it in right away again, since it's really trivial.

(*ID0(<parameters>))(char)

Note the parentheses we added, since we again want that the * binds first, and then the (char). Otherwise it would read function taking <parameters> returning function .... Noes, functions returning functions aren't even allowed.

Now we just need to put <parameters>. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.

pointer to: *ID1
... function taking void returning: (*ID1)(void)

Just put int before the declarators like we did with bottom-up, and we are finished

int (*ID0(int (*ID1)(void)))(char)

The nice thing

Is bottom-up or top-down better? I'm used to bottom-up, but some people may be more comfortable with top-down. It's a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:

int v = (*ID0(some_function_pointer))(some_char);

That is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It's like that for arrays too.

Hope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it.
shareimprove this answer
	
edited May 9 '09 at 13:38
	
community wiki

3 revs
Johannes Schaub - litb
	
add a comment
up vote
16
down vote
	
Another good use for function pointers:
Switching between versions painlessly

They're very handy to use for when you want different functions at different times, or different phases of development. For instance, I'm developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use printf to view status and error messages, but when I'm done, I don't want anything printed. Here's what I've done:
version.h

// First, undefine all macros associated with version.h
#undef DEBUG_VERSION
#undef RELEASE_VERSION
#undef INVALID_VERSION


// Define which version we want to use
#define DEBUG_VERSION       // The current version
// #define RELEASE_VERSION  // To be uncommented when finished debugging

#ifndef __VERSION_H_      /* prevent circular inclusions */
    #define __VERSION_H_  /* by using protection macros */
    void board_init();
    void noprintf(const char *c, ...); // mimic the printf prototype
#endif

// Mimics the printf function prototype. This is what I'll actually 
// use to print stuff to the screen
void (* zprintf)(const char*, ...); 

// If debug version, use printf
#ifdef DEBUG_VERSION
    #include <stdio.h>
#endif

// If both debug and release version, error
#ifdef DEBUG_VERSION
#ifdef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

// If neither debug or release version, error
#ifndef DEBUG_VERSION
#ifndef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

#ifdef INVALID_VERSION
    // Won't allow compilation without a valid version define
    #error "Invalid version definition"
#endif

In version.c I will define the 2 function prototypes present in version.h
version.c

#include "version.h"

/*****************************************************************************/
/**
* @name board_init
*
* Sets up the application based on the version type defined in version.h.
* Includes allowing or prohibiting printing to STDOUT.
*
* MUST BE CALLED FIRST THING IN MAIN
*
* @return    None
*
*****************************************************************************/
void board_init()
{
    // Assign the print function to the correct function pointer
    #ifdef DEBUG_VERSION
        zprintf = &printf;
    #else
        // Defined below this function
        zprintf = &noprintf;
    #endif
}

/*****************************************************************************/
/**
* @name noprintf
*
* simply returns with no actions performed
*
* @return   None
*
*****************************************************************************/
void noprintf(const char* c, ...)
{
    return;
}

Notice how the function pointer is prototyped in version.h as

void (* zprintf)(const char *, ...);

When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.

In version.c, notice in the board_init()function where zprintf is assigned a unique function (whose function signature matches) depending on the version that is defined in version.h

zprintf = &printf; zprintf calls printf for debugging purposes

or

zprintf = &noprint; zprintf just returns and will not run unnecessary code

Running the code will look like this:
mainProg.c

#include "version.h"
#include <stdlib.h>
int main()
{
    // Must run board_init(), which assigns the function
    // pointer to an actual function
    board_init();

    void *ptr = malloc(100); // Allocate 100 bytes of memory
    // malloc returns NULL if unable to allocate the memory.

    if (ptr == NULL)
    {
        zprintf("Unable to allocate memory\n");
        return 1;
    }

    // Other things to do...
    return 0;
}

The above code will use printf if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in version.h and the code will do the rest!
shareimprove this answer
	
edited Jun 11 '13 at 15:36
	
community wiki

2 revs
Zack Sheffield
	
add a comment
up vote
9
down vote
	

Function pointer is usually defined by typedef, and used as param & return value,

Above answers already explained a lot, I just give a full example:

#include <stdio.h>

#define NUM_A 1
#define NUM_B 2

// define a function pointer type
typedef int (*two_num_operation)(int, int);

// an actual standalone function
static int sum(int a, int b) {
    return a + b;
}

// use function pointer as param,
static int sum_via_pointer(int a, int b, two_num_operation funp) {
    return (*funp)(a, b);
}

// use function pointer as return value,
static two_num_operation get_sum_fun() {
    return &sum;
}

// test - use function pointer as variable,
void test_pointer_as_variable() {
    // create a pointer to function,
    two_num_operation sum_p = &sum;
    // call function via pointer
    printf("pointer as variable:\t %d + %d = %d\n", NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));
}

// test - use function pointer as param,
void test_pointer_as_param() {
    printf("pointer as param:\t %d + %d = %d\n", NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &sum));
}

// test - use function pointer as return value,
void test_pointer_as_return_value() {
    printf("pointer as return value:\t %d + %d = %d\n", NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));
}

int main() {
    test_pointer_as_variable();
    test_pointer_as_param();
    test_pointer_as_return_value();

    return 0;
}

shareimprove this answer
	
answered Nov 10 '14 at 8:50
	
community wiki

Eric Wang
	
add a comment
up vote
2
down vote
	

One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, qsort and bsearch, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use.

A very basic example, if there is one function called print(int x, int y) which in turn may require to call add() function or sub() which are of similar types then what we will do, we will add one function pointer argument to the print() function as shown below:-

int add()
{
   return (100+10);
}

int sub()
{
   return (100-10);
}

void print(int x, int y, int (*func)())
{
    printf("value is : %d", (x+y+(*func)()));
}

int main()
{
    int x=100, y=200;
    print(x,y,add);
    print(x,y,sub);

    return 0;
}

shareimprove this answer
	
edited Jan 3 '15 at 17:52
	
community wiki

2 revs, 2 users 96%
Vamsi
	
add a comment
up vote
1
down vote
	

Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call "function's memory address").Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C

1.First you need to declare a pointer to function 2.Pass the Address of the Desired function

****Note->the functions should be of same type****

This Simple Programme will Illustrate Every Thing.

#include<stdio.h>
void (*print)() ;//Declare a  Function Pointers
void sayhello();//Declare The Function Whose Address is to be passed
                //The Functions should Be of Same Type
int main()
{

 print=sayhello;//Addressof sayhello is assigned to print
 print();//print Does A call To The Function 
 return 0;
}

void sayhello()
{
 printf("\n Hello World");
}

enter image description hereAfter That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.

The red mark area is showing how the address is being exchanged and storing in eax.Then their is a call instruction on eax. eax contains the desired address of the function
shareimprove this answer
	
answered Sep 26 '14 at 8:09
	
community wiki

Mohit Dabas
	
add a comment
up vote
0
down vote
	

Since function pointers are often typed callbacks, you might want to have a look at type safe callbacks. The same applies to entry points, etc of functions that are not callbacks.

C is quite fickle and forgiving at the same time :)
shareimprove this answer
	
answered May 9 '09 at 13:56
	
community wiki

Tim Post
	
add a comment
up vote
-3
down vote
	

function pointers are useful in many situations, eg:

    COM objects members are pointer to function ag: This->lpVtbl->AddRef(This); AddRef is a pointer to a function.
    function callback, for example a user defined function to compares two variables to be passed as a callback to a special sort function.
    very useful for plugin implementation and application SDK.

shareimprove this answer
	
answered Jan 2 at 13:15
	
community wiki

milevyo
	
add a comment
protected by Sourav Ghosh May 16 '15 at 11:45

Thank you for your interest in this question. Because it has attracted low-quality or spam answers that had to be removed, posting an answer now requires 10 reputation on this site (the association bonus does not count).

Would you like to answer one of these unanswered questions instead?
Not the answer you're looking for? Browse other questions tagged c function-pointers or ask your own question.

asked
	

7 years ago

viewed
	

479255 times

active
	

12 months ago
Want a python job?

    Senior Python Developer
    HackerEarthBengaluru, India
    ₹1,500,000 - ₹2,500,000Relocation
    pythondjango
    Data Scientist
    MakemytripBengaluru, India
    Relocation
    machine-learningpython
    DevOps Engineer
    RedMartBengaluru, India
    pythonr
    Senior Systems Engineer
    DataXuBengaluru, India
    pythonjavascript

Linked
0
What does void *(*routine)(void *) mean in C?
3
Passing function pointers as arguments
0
Function Pointers Error In C
2
C pass pointer as argument in function
2
For function pointer “fptr”,why is value of “fptr” and *fptr same?What *fptr even mean?I only knew (*fptr)() or fptr()
2
How does function pointer in C actually work?
0
Passing a parameter in a callback in C
1
Can't understand code/function call
1
Please explain the following piece of code. I'm a beginner so please help me understand
0
What does an asterisk in empty parentheses mean?
see more linked questions…
Related
154
Why do function pointer definitions work with any number of ampersands '&' or asterisks '*'?
141
How does the C code that prints from 1 to 1000 without loops or conditional statements work?
7
How to use a function pointer in a C struct?
6
Pointers to any function?
7
function pointer to different functions with different arguments in C
2
Function pointer syntax in C
25
Returning function pointer type
0
Restart a computer using function pointers in C
2
How can a function pointer replace switch statement?
4
pattern for handling function pointer of functions of inhomogene signature in C
Hot Network Questions

    A bit, a nibble or byte?
    Could this kind of authentification be attacked?
    Animate tacky Christmas light decorations
    How is Sovereign Glue affected by Dispel Magic or an Antimagic Field?
    Help with a prime number spiral which turns 90 degrees at each prime
    Why does Hermione dislike Professor Trelawney from the start?
    How is the date of entry and exit of Schengen decided?
    What does this joke mean?
    Is the computer cheating at Dice Poker?
    Total count of Theorem like environments - In all chapters
    What is an asymmetric wheel and why would you use it?
    What's the first noticeable instance of Hermione showing the negative effects due to her timeturner use in the third year?
    When are there infinitely many primes in a sequence generated by a simple recurrence relation?
    I made it up with no more than one. But one what?
    A question about oversets in an equation
    NIntegrate into NDSolve with variable integrand
    How to understand 'quae prosum sola nocendo'?
    How did a Jedi die during the Battle of Geonosis?
    How can I easily double any size number in my head?
    Appropriate age for Rubik's cube
    changing user home directory has no effect
    What is the difference between motivation and inspiration?
    How do I prevent flight in a cyberpunk future?
    A program that guesses your number using bitwise operations C++

question feed
about us tour help blog chat data legal privacy policy work here advertising info mobile contact us feedback
Technology 	Life / Arts 	Culture / Recreation 	Science 	Other

    Stack Overflow
    Server Fault
    Super User
    Web Applications
    Ask Ubuntu
    Webmasters
    Game Development
    TeX - LaTeX

	

    Software Engineering
    Unix & Linux
    Ask Different (Apple)
    WordPress Development
    Geographic Information Systems
    Electrical Engineering
    Android Enthusiasts
    Information Security

	

    Database Administrators
    Drupal Answers
    SharePoint
    User Experience
    Mathematica
    Salesforce
    ExpressionEngine® Answers
    Cryptography

	

    Code Review
    Magento
    Signal Processing
    Raspberry Pi
    Programming Puzzles & Code Golf
    more (7)

	

    Photography
    Science Fiction & Fantasy
    Graphic Design
    Movies & TV
    Music: Practice & Theory
    Seasoned Advice (cooking)
    Home Improvement
    Personal Finance & Money

	

    Academia
    more (8)

	

    English Language & Usage
    Skeptics
    Mi Yodeya (Judaism)
    Travel
    Christianity
    English Language Learners
    Japanese Language
    Arqade (gaming)

	

    Bicycles
    Role-playing Games
    Anime & Manga
    Motor Vehicle Maintenance & Repair
    more (17)

	

    MathOverflow
    Mathematics
    Cross Validated (stats)
    Theoretical Computer Science
    Physics
    Chemistry
    Biology
    Computer Science

	

    Philosophy
    more (3)

	

    Meta Stack Exchange
    Stack Apps
    Area 51
    Stack Overflow Talent

site design / logo © 2016 Stack Exchange Inc; user contributions licensed under cc by-sa 3.0 with attribution required
rev 2016.12.24.1

Stack Exchange Inbox Reputation and Badges
sign up log in tour help

Stack Overflow

    Questions
    Jobs
    Documentation
    Tags
    Users
    Badges

    Ask Question

x Dismiss
Join the Stack Overflow Community
Stack Overflow is a community of 6.5 million programmers, just like you, helping each other.
Join them; it only takes a minute:
Sign up
How do function pointers in C work?
up vote
728
down vote
favorite
604
	

I had some experience lately with function pointers in C.

So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.
c function-pointers
shareimprove this question
	
asked May 8 '09 at 15:49
	
community wiki

Yuval Adam
	
17 	 
	
Also: For a bit of an in-depth analysis of C pointers, see blogs.oracle.com/ksplice/entry/the_ksplice_pointer_challenge‌​. Also, Programming from the Ground Up shows how they work on the machine level. Understanding C's "memory model" is very useful for understanding how C pointers work. – Abbafei May 22 '13 at 11:17
3 	 
	
Great info. By the title though, I would have expected to really see an explanation of how "function pointers work", not how they are coded :) – Bogdan Alexandru Aug 28 '14 at 12:39
26 	 
	
"How do function pointers in C work?" Just fine, thanks. – Keith Thompson Nov 17 '14 at 19:07
add a comment
11 Answers
active
oldest
votes
up vote
889
down vote
accepted
	
Functions pointers in C

Let's start with a basic function which we will be pointing to:

int addInt(int n, int m) {
    return n+m;
}

First thing, lets define a pointer to a function which receives 2 ints and returns and int:

int (*functionPtr)(int,int);

Now we can safely point to our function:

functionPtr = &addInt;

Now that we have a pointer to the function, lets use it:

int sum = (*functionPtr)(2, 3); // sum == 5

Passing the pointer to another function is basically the same:

int add2to3(int (*functionPtr)(int, int)) {
    return (*functionPtr)(2, 3);
}

We can use function pointers in return values as well (try to keep up, it gets messy):

// this is a function called functionFactory which receives parameter n
// and returns a pointer to another function which receives two ints
// and it returns another int
int (*functionFactory(int n))(int, int) {
    printf("Got parameter %d", n);
    int (*functionPtr)(int,int) = &addInt;
    return functionPtr;
}

But it's much nicer to use a typedef:

typedef int (*myFuncDef)(int, int);
// note that the typedef name is indeed myFuncDef

myFuncDef functionFactory(int n) {
    printf("Got parameter %d", n);
    myFuncDef functionPtr = &addInt;
    return functionPtr;
}

shareimprove this answer
	
edited May 20 '15 at 13:25
idmean
8,03262455
	
answered May 8 '09 at 15:49
Yuval Adam
88k63240332
	
9 	 
	
Thanks for the great info. Could you add some insight on where function pointers are used or happen to be particularly useful? – Rich.Carpenter May 8 '09 at 15:55
175 	 
	
"functionPtr = &addInt;" can also be written (and often is) as " functionPtr = addInt;" which is also valid since the standard says that a function name in this context is converted to the address of the function. – hlovdal May 9 '09 at 14:39
8 	 
	
hlovdal, in this context it's interesting to explain that this is what enables one to write functionPtr = ******************addInt; – Johannes Schaub - litb May 10 '09 at 17:54
53 	 
	
@Rich.Carpenter I know this is 4 years too late, but I figure other people might benefit from this: Function pointers are useful for passing functions as parameters to other functions. It took a lot of searching for me to find that answer for some odd reason. So basically, it gives C pseudo first-class functionality. – giant91 Oct 13 '13 at 2:28
7 	 
	
@Rich.Carpenter: function pointers are nice for runtime CPU detection. Have multiple versions of some functions to take advantage of SSE, popcnt, AVX, etc. At startup, set your function pointers to the best version of each function for the current CPU. In your other code, just call through the function pointer instead of having conditional branches on the CPU features everywhere. Then you can do complicated logic about deciding that well, even though this CPU supports pshufb, it's slow, so the earlier implementation is still faster. x264/x265 use this extensively, and are open source. – Peter Cordes Aug 30 '15 at 2:22
show 8 more comments
up vote
209
down vote
	

Function pointers in C can be used to perform object-oriented programming in C.

For example, the following lines is written in C:

String s1 = newString();
s1->set(s1, "hello");

Yes, the -> and the lack of a new operator is a dead give away, but it sure seems to imply that we're setting the text of some String class to be "hello".

By using function pointers, it is possible to emulate methods in C.

How is this accomplished?

The String class is actually a struct with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the String class:

typedef struct String_Struct* String;

struct String_Struct
{
    char* (*get)(const void* self);
    void (*set)(const void* self, char* value);
    int (*length)(const void* self);
};

char* getString(const void* self);
void setString(const void* self, char* value);
int lengthString(const void* self);

String newString();

As can be seen, the methods of the String class are actually function pointers to the declared function. In preparing the instance of the String, the newString function is called in order to set up the function pointers to their respective functions:

String newString()
{
    String self = (String)malloc(sizeof(struct String_Struct));

    self->get = &getString;
    self->set = &setString;
    self->length = &lengthString;

    self->set(self, "");

    return self;
}

For example, the getString function that is called by invoking the get method is defined as the following:

char* getString(const void* self_obj)
{
    return ((String)self_obj)->internal->value;
}

One thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a "self object" must be passed in on each invocation. (And the internal is just a hidden struct which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)

So, rather than being able to do s1->set("hello");, one must pass in the object to perform the action on s1->set(s1, "hello").

With that minor explanation having to pass in a reference to yourself out of the way, we'll move to the next part, which is inheritance in C.

Let's say we want to make a subclass of String, say an ImmutableString. In order to make the string immutable, the set method will not be accessible, while maintaining access to get and length, and force the "constructor" to accept a char*:

typedef struct ImmutableString_Struct* ImmutableString;

struct ImmutableString_Struct
{
    String base;

    char* (*get)(const void* self);
    int (*length)(const void* self);
};

ImmutableString newImmutableString(const char* value);

Basically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the set method is not present, therefore, it cannot be called in a ImmutableString.

As for the implementation of the ImmutableString, the only relevant code is the "constructor" function, the newImmutableString:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = self->base->length;

    self->base->set(self->base, (char*)value);

    return self;
}

In instantiating the ImmutableString, the function pointers to the get and length methods actually refer to the String.get and String.length method, by going through the base variable which is an internally stored String object.

The use of a function pointer can achieve inheritance of a method from a superclass.

We can further continue to polymorphism in C.

If for example we wanted to change the behavior of the length method to return 0 all the time in the ImmutableString class for some reason, all that would have to be done is to:

    Add a function that is going to serve as the overriding length method.
    Go to the "constructor" and set the function pointer to the overriding length method.

Adding an overriding length method in ImmutableString may be performed by adding an lengthOverrideMethod:

int lengthOverrideMethod(const void* self)
{
    return 0;
}

Then, the function pointer for the length method in the constructor is hooked up to the lengthOverrideMethod:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = &lengthOverrideMethod;

    self->base->set(self->base, (char*)value);

    return self;
}

Now, rather than having an identical behavior for the length method in ImmutableString class as the String class, now the length method will refer to the behavior defined in the lengthOverrideMethod function.

I must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn't explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.

For more information on how to perform object-oriented programming in C, please refer to the following questions:

    Object-Orientation in C?
    Can you write object oriented code in C?

shareimprove this answer
	
edited Oct 14 '14 at 7:19
	
community wiki

2 revs, 2 users 100%
coobird
	
6 	 
	
This answer is horrible! Not only it implies that OO somehow depends on dot notation, it also encourages putting junk into your objects! – Alexei Averchenko Sep 16 '12 at 14:30
12 	 
	
This is OO all right, but not anywhere near the C-style OO. What you have brokenly implemented is Javascript-style prototype-based OO. To get C++/Pascal-style OO, you'd need to: 1. Have a const struct for a virtual table of each class with virtual members. 2. Have pointer to that struct in polymorphic objects. 3. Call virtual methods via the virtual table, and all other methods directly -- usually by sticking to some ClassName_methodName function naming convention. Only then you get the same runtime and storage costs as you do in C++ and Pascal. – Kuba Ober Mar 18 '13 at 21:53
9 	 
	
Working OO with a language that is not intended to be OO is always a bad idea. If you want OO and still have C just work with C++. – rbaleksandar Jul 4 '13 at 15:21
6 	 
	
@rbaleksandar Tell that to the Linux kernel developers. "always a bad idea" is strictly your opinion, with which I firmly disagree. – Jonathon Reinhart Apr 30 '15 at 12:31
   	 
	
@KubaOber which sounds like GObject, right? – underscore_d Apr 20 at 21:17
show 4 more comments
up vote
139
down vote
	

The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:

    Returns the current value on the EAX register

    int eax = ((int(*)())("\xc3 <- This returns the value of the EAX register"))();

    Write a swap function

    int a = 10, b = 20;
    ((void(*)(int*,int*))"\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3 <- This swaps the values of a and b")(&a,&b);

    Write a for-loop counter to 1000, calling some function each time

    ((int(*)())"\x66\x31\xc0\x8b\x5c\x24\x04\x66\x40\x50\xff\xd3\x58\x66\x3d\xe8\x03\x75\xf4\xc3")(&function); // calls function with 1->1000

    You can even write a recursive function that counts to 100

    const char* lol = "\x8b\x5c\x24\x4\x3d\xe8\x3\x0\x0\x7e\x2\x31\xc0\x83\xf8\x64\x7d\x6\x40\x53\xff\xd3\x5b\xc3\xc3 <- Recursively calls the function at address lol.";
    i = ((int(*)())(lol))(lol);

shareimprove this answer
	
edited Apr 22 '15 at 11:53
	
community wiki

2 revs, 2 users 98%
Lee Gao
	
6 	 
	
Note: this doesn't work if Data Execution Prevention is enabled (e.g. on Windows XP SP2+), because C strings are not normally marked as executable. – SecurityMatt Feb 12 '13 at 5:53
1 	 
	
will this work on Visual Studio? I get:error C2440: 'type cast' : cannot convert from 'const char [68]' to 'void (__cdecl *)(int *,int *)' . Any ideas? – roboto1986 Jul 3 '13 at 18:42
3 	 
	
Hi Matt! Depending on the optimization level, GCC will often inline string constants into the TEXT segment, so this will work even on newer version of windows provided that you don't disallow this type of optimization. (IIRC, the MINGW version at the time of my post over two years ago inlines string literals at the default optimization level) – Lee Jan 2 '14 at 6:20
3 	 
	
could someone please explain what's happening here? What are those weird looking string literals? – ajay Jan 20 '14 at 10:17
18 	 
	
@ajay It looks like he's writing raw hexidecimal values (for instance '\x00' is the same as '/0', they're both equal to 0) into a string, then casting the string into a C function pointer, then executing the C function pointer because he's the devil. – ejk314 Feb 21 '14 at 21:27
show 9 more comments
up vote
68
down vote
	

One of my favorite uses for function pointers is as cheap and easy iterators -

#include <stdio.h>
#define MAX_COLORS  256

typedef struct {
    char* name;
    int red;
    int green;
    int blue;
} Color;

Color Colors[MAX_COLORS];


void eachColor (void (*fp)(Color *c)) {
    int i;
    for (i=0; i<MAX_COLORS; i++)
        (*fp)(&Colors[i]);
}

void printColor(Color* c) {
    if (c->name)
        printf("%s = %i,%i,%i\n", c->name, c->red, c->green, c->blue);
}

int main() {
    Colors[0].name="red";
    Colors[0].red=255;
    Colors[1].name="blue";
    Colors[1].blue=255;
    Colors[2].name="black";

    eachColor(printColor);
}

shareimprove this answer
	
edited Jul 24 '12 at 16:40
	
community wiki

2 revs, 2 users 99%
Nick
	
7 	 
	
You should also pass a pointer to user-specified data if you want to somehow extract any output from iterations (think closures). – Alexei Averchenko Sep 16 '12 at 14:32
   	 
	
Agreed. All of my iterators look like this: int (*cb)(void *arg, ...). The return value of the iterator also lets me stop early (if nonzero). – Jonathon Reinhart Apr 30 '15 at 12:35
add a comment
up vote
19
down vote
	

Function pointers become easy to declare once you have the basic declarators:

    id: ID: ID is a
    Pointer: *D: D pointer to
    Function: D(<parameters>): D function taking <parameters> returning

While D is another declarator built using those same rules. In the end, somewhere, it ends with ID (see below for an example), which is the name of the declared entity. Let's try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it's like this

typedef int ReturnFunction(char);
typedef int ParameterFunction(void);
ReturnFunction *f(ParameterFunction *p);

As you see, it's pretty easy to build it up using typedefs. Without typedefs, it's not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That's what appears at the very left of the declaration, and is not of interest: It's added at the end if one built up the declarator already. Let's do that. Building it up consistently, first wordy - showing the structure using [ and ]:

function taking 
    [pointer to [function taking [void] returning [int]]] 
returning
    [pointer to [function taking [char] returning [int]]]

As you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I'll show both ways.
Bottom Up

Construction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i'm going to number them:

D1(char);

Inserted the char parameter directly, since it's trivial. Adding a pointer to declarator by replacing D1 by *D2. Note that we have to wrap parentheses around *D2. That can be known by looking up the precedence of the *-operator and the function-call operator (). Without our parentheses, the compiler would read it as *(D2(char p)). But that would not be a plain replace of D1 by *D2 anymore, of course. Parentheses are always allowed around declarators. So you don't make anything wrong if you add too much of them, actually.

(*D2)(char);

Return type is complete! Now, let's replace D2 by the function declarator function taking <parameters> returning, which is D3(<parameters>) which we are at now.

(*D3(<parameters>))(char)

Note that no parentheses are needed, since we want D3 to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we've done the return type, just with char replaced by void. So i'll copy it:

(*D3(   (*ID1)(void)))(char)

I've replaced D2 by ID1, since we are finished with that parameter (it's already a pointer to a function - no need for another declarator). ID1 will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It's interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times int of course.

int (*ID0(int (*ID1)(void)))(char)

I've called the identifier of the function ID0 in that example.
Top Down

This starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with function taking <parameters> returning

ID0(<parameters>)

The next thing in the description (after "returning") was pointer to. Let's incorporate it:

*ID0(<parameters>)

Then the next thing was functon taking <parameters> returning. The parameter is a simple char, so we put it in right away again, since it's really trivial.

(*ID0(<parameters>))(char)

Note the parentheses we added, since we again want that the * binds first, and then the (char). Otherwise it would read function taking <parameters> returning function .... Noes, functions returning functions aren't even allowed.

Now we just need to put <parameters>. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.

pointer to: *ID1
... function taking void returning: (*ID1)(void)

Just put int before the declarators like we did with bottom-up, and we are finished

int (*ID0(int (*ID1)(void)))(char)

The nice thing

Is bottom-up or top-down better? I'm used to bottom-up, but some people may be more comfortable with top-down. It's a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:

int v = (*ID0(some_function_pointer))(some_char);

That is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It's like that for arrays too.

Hope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it.
shareimprove this answer
	
edited May 9 '09 at 13:38
	
community wiki

3 revs
Johannes Schaub - litb
	
add a comment
up vote
16
down vote
	
Another good use for function pointers:
Switching between versions painlessly

They're very handy to use for when you want different functions at different times, or different phases of development. For instance, I'm developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use printf to view status and error messages, but when I'm done, I don't want anything printed. Here's what I've done:
version.h

// First, undefine all macros associated with version.h
#undef DEBUG_VERSION
#undef RELEASE_VERSION
#undef INVALID_VERSION


// Define which version we want to use
#define DEBUG_VERSION       // The current version
// #define RELEASE_VERSION  // To be uncommented when finished debugging

#ifndef __VERSION_H_      /* prevent circular inclusions */
    #define __VERSION_H_  /* by using protection macros */
    void board_init();
    void noprintf(const char *c, ...); // mimic the printf prototype
#endif

// Mimics the printf function prototype. This is what I'll actually 
// use to print stuff to the screen
void (* zprintf)(const char*, ...); 

// If debug version, use printf
#ifdef DEBUG_VERSION
    #include <stdio.h>
#endif

// If both debug and release version, error
#ifdef DEBUG_VERSION
#ifdef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

// If neither debug or release version, error
#ifndef DEBUG_VERSION
#ifndef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

#ifdef INVALID_VERSION
    // Won't allow compilation without a valid version define
    #error "Invalid version definition"
#endif

In version.c I will define the 2 function prototypes present in version.h
version.c

#include "version.h"

/*****************************************************************************/
/**
* @name board_init
*
* Sets up the application based on the version type defined in version.h.
* Includes allowing or prohibiting printing to STDOUT.
*
* MUST BE CALLED FIRST THING IN MAIN
*
* @return    None
*
*****************************************************************************/
void board_init()
{
    // Assign the print function to the correct function pointer
    #ifdef DEBUG_VERSION
        zprintf = &printf;
    #else
        // Defined below this function
        zprintf = &noprintf;
    #endif
}

/*****************************************************************************/
/**
* @name noprintf
*
* simply returns with no actions performed
*
* @return   None
*
*****************************************************************************/
void noprintf(const char* c, ...)
{
    return;
}

Notice how the function pointer is prototyped in version.h as

void (* zprintf)(const char *, ...);

When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.

In version.c, notice in the board_init()function where zprintf is assigned a unique function (whose function signature matches) depending on the version that is defined in version.h

zprintf = &printf; zprintf calls printf for debugging purposes

or

zprintf = &noprint; zprintf just returns and will not run unnecessary code

Running the code will look like this:
mainProg.c

#include "version.h"
#include <stdlib.h>
int main()
{
    // Must run board_init(), which assigns the function
    // pointer to an actual function
    board_init();

    void *ptr = malloc(100); // Allocate 100 bytes of memory
    // malloc returns NULL if unable to allocate the memory.

    if (ptr == NULL)
    {
        zprintf("Unable to allocate memory\n");
        return 1;
    }

    // Other things to do...
    return 0;
}

The above code will use printf if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in version.h and the code will do the rest!
shareimprove this answer
	
edited Jun 11 '13 at 15:36
	
community wiki

2 revs
Zack Sheffield
	
add a comment
up vote
9
down vote
	

Function pointer is usually defined by typedef, and used as param & return value,

Above answers already explained a lot, I just give a full example:

#include <stdio.h>

#define NUM_A 1
#define NUM_B 2

// define a function pointer type
typedef int (*two_num_operation)(int, int);

// an actual standalone function
static int sum(int a, int b) {
    return a + b;
}

// use function pointer as param,
static int sum_via_pointer(int a, int b, two_num_operation funp) {
    return (*funp)(a, b);
}

// use function pointer as return value,
static two_num_operation get_sum_fun() {
    return &sum;
}

// test - use function pointer as variable,
void test_pointer_as_variable() {
    // create a pointer to function,
    two_num_operation sum_p = &sum;
    // call function via pointer
    printf("pointer as variable:\t %d + %d = %d\n", NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));
}

// test - use function pointer as param,
void test_pointer_as_param() {
    printf("pointer as param:\t %d + %d = %d\n", NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &sum));
}

// test - use function pointer as return value,
void test_pointer_as_return_value() {
    printf("pointer as return value:\t %d + %d = %d\n", NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));
}

int main() {
    test_pointer_as_variable();
    test_pointer_as_param();
    test_pointer_as_return_value();

    return 0;
}

shareimprove this answer
	
answered Nov 10 '14 at 8:50
	
community wiki

Eric Wang
	
add a comment
up vote
2
down vote
	

One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, qsort and bsearch, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use.

A very basic example, if there is one function called print(int x, int y) which in turn may require to call add() function or sub() which are of similar types then what we will do, we will add one function pointer argument to the print() function as shown below:-

int add()
{
   return (100+10);
}

int sub()
{
   return (100-10);
}

void print(int x, int y, int (*func)())
{
    printf("value is : %d", (x+y+(*func)()));
}

int main()
{
    int x=100, y=200;
    print(x,y,add);
    print(x,y,sub);

    return 0;
}

shareimprove this answer
	
edited Jan 3 '15 at 17:52
	
community wiki

2 revs, 2 users 96%
Vamsi
	
add a comment
up vote
1
down vote
	

Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call "function's memory address").Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C

1.First you need to declare a pointer to function 2.Pass the Address of the Desired function

****Note->the functions should be of same type****

This Simple Programme will Illustrate Every Thing.

#include<stdio.h>
void (*print)() ;//Declare a  Function Pointers
void sayhello();//Declare The Function Whose Address is to be passed
                //The Functions should Be of Same Type
int main()
{

 print=sayhello;//Addressof sayhello is assigned to print
 print();//print Does A call To The Function 
 return 0;
}

void sayhello()
{
 printf("\n Hello World");
}

enter image description hereAfter That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.

The red mark area is showing how the address is being exchanged and storing in eax.Then their is a call instruction on eax. eax contains the desired address of the function
shareimprove this answer
	
answered Sep 26 '14 at 8:09
	
community wiki

Mohit Dabas
	
add a comment
up vote
0
down vote
	

Since function pointers are often typed callbacks, you might want to have a look at type safe callbacks. The same applies to entry points, etc of functions that are not callbacks.

C is quite fickle and forgiving at the same time :)
shareimprove this answer
	
answered May 9 '09 at 13:56
	
community wiki

Tim Post
	
add a comment
up vote
-3
down vote
	

function pointers are useful in many situations, eg:

    COM objects members are pointer to function ag: This->lpVtbl->AddRef(This); AddRef is a pointer to a function.
    function callback, for example a user defined function to compares two variables to be passed as a callback to a special sort function.
    very useful for plugin implementation and application SDK.

shareimprove this answer
	
answered Jan 2 at 13:15
	
community wiki

milevyo
	
add a comment
protected by Sourav Ghosh May 16 '15 at 11:45

Thank you for your interest in this question. Because it has attracted low-quality or spam answers that had to be removed, posting an answer now requires 10 reputation on this site (the association bonus does not count).

Would you like to answer one of these unanswered questions instead?
Not the answer you're looking for? Browse other questions tagged c function-pointers or ask your own question.

asked
	

7 years ago

viewed
	

479255 times

active
	

12 months ago
Want a python job?

    Senior Python Developer
    HackerEarthBengaluru, India
    ₹1,500,000 - ₹2,500,000Relocation
    pythondjango
    Data Scientist
    MakemytripBengaluru, India
    Relocation
    machine-learningpython
    DevOps Engineer
    RedMartBengaluru, India
    pythonr
    Senior Systems Engineer
    DataXuBengaluru, India
    pythonjavascript

Linked
0
What does void *(*routine)(void *) mean in C?
3
Passing function pointers as arguments
0
Function Pointers Error In C
2
C pass pointer as argument in function
2
For function pointer “fptr”,why is value of “fptr” and *fptr same?What *fptr even mean?I only knew (*fptr)() or fptr()
2
How does function pointer in C actually work?
0
Passing a parameter in a callback in C
1
Can't understand code/function call
1
Please explain the following piece of code. I'm a beginner so please help me understand
0
What does an asterisk in empty parentheses mean?
see more linked questions…
Related
154
Why do function pointer definitions work with any number of ampersands '&' or asterisks '*'?
141
How does the C code that prints from 1 to 1000 without loops or conditional statements work?
7
How to use a function pointer in a C struct?
6
Pointers to any function?
7
function pointer to different functions with different arguments in C
2
Function pointer syntax in C
25
Returning function pointer type
0
Restart a computer using function pointers in C
2
How can a function pointer replace switch statement?
4
pattern for handling function pointer of functions of inhomogene signature in C
Hot Network Questions

    A bit, a nibble or byte?
    Could this kind of authentification be attacked?
    Animate tacky Christmas light decorations
    How is Sovereign Glue affected by Dispel Magic or an Antimagic Field?
    Help with a prime number spiral which turns 90 degrees at each prime
    Why does Hermione dislike Professor Trelawney from the start?
    How is the date of entry and exit of Schengen decided?
    What does this joke mean?
    Is the computer cheating at Dice Poker?
    Total count of Theorem like environments - In all chapters
    What is an asymmetric wheel and why would you use it?
    What's the first noticeable instance of Hermione showing the negative effects due to her timeturner use in the third year?
    When are there infinitely many primes in a sequence generated by a simple recurrence relation?
    I made it up with no more than one. But one what?
    A question about oversets in an equation
    NIntegrate into NDSolve with variable integrand
    How to understand 'quae prosum sola nocendo'?
    How did a Jedi die during the Battle of Geonosis?
    How can I easily double any size number in my head?
    Appropriate age for Rubik's cube
    changing user home directory has no effect
    What is the difference between motivation and inspiration?
    How do I prevent flight in a cyberpunk future?
    A program that guesses your number using bitwise operations C++

question feed
about us tour help blog chat data legal privacy policy work here advertising info mobile contact us feedback
Technology 	Life / Arts 	Culture / Recreation 	Science 	Other

    Stack Overflow
    Server Fault
    Super User
    Web Applications
    Ask Ubuntu
    Webmasters
    Game Development
    TeX - LaTeX

	

    Software Engineering
    Unix & Linux
    Ask Different (Apple)
    WordPress Development
    Geographic Information Systems
    Electrical Engineering
    Android Enthusiasts
    Information Security

	

    Database Administrators
    Drupal Answers
    SharePoint
    User Experience
    Mathematica
    Salesforce
    ExpressionEngine® Answers
    Cryptography

	

    Code Review
    Magento
    Signal Processing
    Raspberry Pi
    Programming Puzzles & Code Golf
    more (7)

	

    Photography
    Science Fiction & Fantasy
    Graphic Design
    Movies & TV
    Music: Practice & Theory
    Seasoned Advice (cooking)
    Home Improvement
    Personal Finance & Money

	

    Academia
    more (8)

	

    English Language & Usage
    Skeptics
    Mi Yodeya (Judaism)
    Travel
    Christianity
    English Language Learners
    Japanese Language
    Arqade (gaming)

	

    Bicycles
    Role-playing Games
    Anime & Manga
    Motor Vehicle Maintenance & Repair
    more (17)

	

    MathOverflow
    Mathematics
    Cross Validated (stats)
    Theoretical Computer Science
    Physics
    Chemistry
    Biology
    Computer Science

	

    Philosophy
    more (3)

	

    Meta Stack Exchange
    Stack Apps
    Area 51
    Stack Overflow Talent

site design / logo © 2016 Stack Exchange Inc; user contributions licensed under cc by-sa 3.0 with attribution required
rev 2016.12.24.1

Stack Exchange Inbox Reputation and Badges
sign up log in tour help

Stack Overflow

    Questions
    Jobs
    Documentation
    Tags
    Users
    Badges

    Ask Question

x Dismiss
Join the Stack Overflow Community
Stack Overflow is a community of 6.5 million programmers, just like you, helping each other.
Join them; it only takes a minute:
Sign up
How do function pointers in C work?
up vote
728
down vote
favorite
604
	

I had some experience lately with function pointers in C.

So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.
c function-pointers
shareimprove this question
	
asked May 8 '09 at 15:49
	
community wiki

Yuval Adam
	
17 	 
	
Also: For a bit of an in-depth analysis of C pointers, see blogs.oracle.com/ksplice/entry/the_ksplice_pointer_challenge‌​. Also, Programming from the Ground Up shows how they work on the machine level. Understanding C's "memory model" is very useful for understanding how C pointers work. – Abbafei May 22 '13 at 11:17
3 	 
	
Great info. By the title though, I would have expected to really see an explanation of how "function pointers work", not how they are coded :) – Bogdan Alexandru Aug 28 '14 at 12:39
26 	 
	
"How do function pointers in C work?" Just fine, thanks. – Keith Thompson Nov 17 '14 at 19:07
add a comment
11 Answers
active
oldest
votes
up vote
889
down vote
accepted
	
Functions pointers in C

Let's start with a basic function which we will be pointing to:

int addInt(int n, int m) {
    return n+m;
}

First thing, lets define a pointer to a function which receives 2 ints and returns and int:

int (*functionPtr)(int,int);

Now we can safely point to our function:

functionPtr = &addInt;

Now that we have a pointer to the function, lets use it:

int sum = (*functionPtr)(2, 3); // sum == 5

Passing the pointer to another function is basically the same:

int add2to3(int (*functionPtr)(int, int)) {
    return (*functionPtr)(2, 3);
}

We can use function pointers in return values as well (try to keep up, it gets messy):

// this is a function called functionFactory which receives parameter n
// and returns a pointer to another function which receives two ints
// and it returns another int
int (*functionFactory(int n))(int, int) {
    printf("Got parameter %d", n);
    int (*functionPtr)(int,int) = &addInt;
    return functionPtr;
}

But it's much nicer to use a typedef:

typedef int (*myFuncDef)(int, int);
// note that the typedef name is indeed myFuncDef

myFuncDef functionFactory(int n) {
    printf("Got parameter %d", n);
    myFuncDef functionPtr = &addInt;
    return functionPtr;
}

shareimprove this answer
	
edited May 20 '15 at 13:25
idmean
8,03262455
	
answered May 8 '09 at 15:49
Yuval Adam
88k63240332
	
9 	 
	
Thanks for the great info. Could you add some insight on where function pointers are used or happen to be particularly useful? – Rich.Carpenter May 8 '09 at 15:55
175 	 
	
"functionPtr = &addInt;" can also be written (and often is) as " functionPtr = addInt;" which is also valid since the standard says that a function name in this context is converted to the address of the function. – hlovdal May 9 '09 at 14:39
8 	 
	
hlovdal, in this context it's interesting to explain that this is what enables one to write functionPtr = ******************addInt; – Johannes Schaub - litb May 10 '09 at 17:54
53 	 
	
@Rich.Carpenter I know this is 4 years too late, but I figure other people might benefit from this: Function pointers are useful for passing functions as parameters to other functions. It took a lot of searching for me to find that answer for some odd reason. So basically, it gives C pseudo first-class functionality. – giant91 Oct 13 '13 at 2:28
7 	 
	
@Rich.Carpenter: function pointers are nice for runtime CPU detection. Have multiple versions of some functions to take advantage of SSE, popcnt, AVX, etc. At startup, set your function pointers to the best version of each function for the current CPU. In your other code, just call through the function pointer instead of having conditional branches on the CPU features everywhere. Then you can do complicated logic about deciding that well, even though this CPU supports pshufb, it's slow, so the earlier implementation is still faster. x264/x265 use this extensively, and are open source. – Peter Cordes Aug 30 '15 at 2:22
show 8 more comments
up vote
209
down vote
	

Function pointers in C can be used to perform object-oriented programming in C.

For example, the following lines is written in C:

String s1 = newString();
s1->set(s1, "hello");

Yes, the -> and the lack of a new operator is a dead give away, but it sure seems to imply that we're setting the text of some String class to be "hello".

By using function pointers, it is possible to emulate methods in C.

How is this accomplished?

The String class is actually a struct with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the String class:

typedef struct String_Struct* String;

struct String_Struct
{
    char* (*get)(const void* self);
    void (*set)(const void* self, char* value);
    int (*length)(const void* self);
};

char* getString(const void* self);
void setString(const void* self, char* value);
int lengthString(const void* self);

String newString();

As can be seen, the methods of the String class are actually function pointers to the declared function. In preparing the instance of the String, the newString function is called in order to set up the function pointers to their respective functions:

String newString()
{
    String self = (String)malloc(sizeof(struct String_Struct));

    self->get = &getString;
    self->set = &setString;
    self->length = &lengthString;

    self->set(self, "");

    return self;
}

For example, the getString function that is called by invoking the get method is defined as the following:

char* getString(const void* self_obj)
{
    return ((String)self_obj)->internal->value;
}

One thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a "self object" must be passed in on each invocation. (And the internal is just a hidden struct which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)

So, rather than being able to do s1->set("hello");, one must pass in the object to perform the action on s1->set(s1, "hello").

With that minor explanation having to pass in a reference to yourself out of the way, we'll move to the next part, which is inheritance in C.

Let's say we want to make a subclass of String, say an ImmutableString. In order to make the string immutable, the set method will not be accessible, while maintaining access to get and length, and force the "constructor" to accept a char*:

typedef struct ImmutableString_Struct* ImmutableString;

struct ImmutableString_Struct
{
    String base;

    char* (*get)(const void* self);
    int (*length)(const void* self);
};

ImmutableString newImmutableString(const char* value);

Basically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the set method is not present, therefore, it cannot be called in a ImmutableString.

As for the implementation of the ImmutableString, the only relevant code is the "constructor" function, the newImmutableString:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = self->base->length;

    self->base->set(self->base, (char*)value);

    return self;
}

In instantiating the ImmutableString, the function pointers to the get and length methods actually refer to the String.get and String.length method, by going through the base variable which is an internally stored String object.

The use of a function pointer can achieve inheritance of a method from a superclass.

We can further continue to polymorphism in C.

If for example we wanted to change the behavior of the length method to return 0 all the time in the ImmutableString class for some reason, all that would have to be done is to:

    Add a function that is going to serve as the overriding length method.
    Go to the "constructor" and set the function pointer to the overriding length method.

Adding an overriding length method in ImmutableString may be performed by adding an lengthOverrideMethod:

int lengthOverrideMethod(const void* self)
{
    return 0;
}

Then, the function pointer for the length method in the constructor is hooked up to the lengthOverrideMethod:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = &lengthOverrideMethod;

    self->base->set(self->base, (char*)value);

    return self;
}

Now, rather than having an identical behavior for the length method in ImmutableString class as the String class, now the length method will refer to the behavior defined in the lengthOverrideMethod function.

I must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn't explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.

For more information on how to perform object-oriented programming in C, please refer to the following questions:

    Object-Orientation in C?
    Can you write object oriented code in C?

shareimprove this answer
	
edited Oct 14 '14 at 7:19
	
community wiki

2 revs, 2 users 100%
coobird
	
6 	 
	
This answer is horrible! Not only it implies that OO somehow depends on dot notation, it also encourages putting junk into your objects! – Alexei Averchenko Sep 16 '12 at 14:30
12 	 
	
This is OO all right, but not anywhere near the C-style OO. What you have brokenly implemented is Javascript-style prototype-based OO. To get C++/Pascal-style OO, you'd need to: 1. Have a const struct for a virtual table of each class with virtual members. 2. Have pointer to that struct in polymorphic objects. 3. Call virtual methods via the virtual table, and all other methods directly -- usually by sticking to some ClassName_methodName function naming convention. Only then you get the same runtime and storage costs as you do in C++ and Pascal. – Kuba Ober Mar 18 '13 at 21:53
9 	 
	
Working OO with a language that is not intended to be OO is always a bad idea. If you want OO and still have C just work with C++. – rbaleksandar Jul 4 '13 at 15:21
6 	 
	
@rbaleksandar Tell that to the Linux kernel developers. "always a bad idea" is strictly your opinion, with which I firmly disagree. – Jonathon Reinhart Apr 30 '15 at 12:31
   	 
	
@KubaOber which sounds like GObject, right? – underscore_d Apr 20 at 21:17
show 4 more comments
up vote
139
down vote
	

The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:

    Returns the current value on the EAX register

    int eax = ((int(*)())("\xc3 <- This returns the value of the EAX register"))();

    Write a swap function

    int a = 10, b = 20;
    ((void(*)(int*,int*))"\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3 <- This swaps the values of a and b")(&a,&b);

    Write a for-loop counter to 1000, calling some function each time

    ((int(*)())"\x66\x31\xc0\x8b\x5c\x24\x04\x66\x40\x50\xff\xd3\x58\x66\x3d\xe8\x03\x75\xf4\xc3")(&function); // calls function with 1->1000

    You can even write a recursive function that counts to 100

    const char* lol = "\x8b\x5c\x24\x4\x3d\xe8\x3\x0\x0\x7e\x2\x31\xc0\x83\xf8\x64\x7d\x6\x40\x53\xff\xd3\x5b\xc3\xc3 <- Recursively calls the function at address lol.";
    i = ((int(*)())(lol))(lol);

shareimprove this answer
	
edited Apr 22 '15 at 11:53
	
community wiki

2 revs, 2 users 98%
Lee Gao
	
6 	 
	
Note: this doesn't work if Data Execution Prevention is enabled (e.g. on Windows XP SP2+), because C strings are not normally marked as executable. – SecurityMatt Feb 12 '13 at 5:53
1 	 
	
will this work on Visual Studio? I get:error C2440: 'type cast' : cannot convert from 'const char [68]' to 'void (__cdecl *)(int *,int *)' . Any ideas? – roboto1986 Jul 3 '13 at 18:42
3 	 
	
Hi Matt! Depending on the optimization level, GCC will often inline string constants into the TEXT segment, so this will work even on newer version of windows provided that you don't disallow this type of optimization. (IIRC, the MINGW version at the time of my post over two years ago inlines string literals at the default optimization level) – Lee Jan 2 '14 at 6:20
3 	 
	
could someone please explain what's happening here? What are those weird looking string literals? – ajay Jan 20 '14 at 10:17
18 	 
	
@ajay It looks like he's writing raw hexidecimal values (for instance '\x00' is the same as '/0', they're both equal to 0) into a string, then casting the string into a C function pointer, then executing the C function pointer because he's the devil. – ejk314 Feb 21 '14 at 21:27
show 9 more comments
up vote
68
down vote
	

One of my favorite uses for function pointers is as cheap and easy iterators -

#include <stdio.h>
#define MAX_COLORS  256

typedef struct {
    char* name;
    int red;
    int green;
    int blue;
} Color;

Color Colors[MAX_COLORS];


void eachColor (void (*fp)(Color *c)) {
    int i;
    for (i=0; i<MAX_COLORS; i++)
        (*fp)(&Colors[i]);
}

void printColor(Color* c) {
    if (c->name)
        printf("%s = %i,%i,%i\n", c->name, c->red, c->green, c->blue);
}

int main() {
    Colors[0].name="red";
    Colors[0].red=255;
    Colors[1].name="blue";
    Colors[1].blue=255;
    Colors[2].name="black";

    eachColor(printColor);
}

shareimprove this answer
	
edited Jul 24 '12 at 16:40
	
community wiki

2 revs, 2 users 99%
Nick
	
7 	 
	
You should also pass a pointer to user-specified data if you want to somehow extract any output from iterations (think closures). – Alexei Averchenko Sep 16 '12 at 14:32
   	 
	
Agreed. All of my iterators look like this: int (*cb)(void *arg, ...). The return value of the iterator also lets me stop early (if nonzero). – Jonathon Reinhart Apr 30 '15 at 12:35
add a comment
up vote
19
down vote
	

Function pointers become easy to declare once you have the basic declarators:

    id: ID: ID is a
    Pointer: *D: D pointer to
    Function: D(<parameters>): D function taking <parameters> returning

While D is another declarator built using those same rules. In the end, somewhere, it ends with ID (see below for an example), which is the name of the declared entity. Let's try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it's like this

typedef int ReturnFunction(char);
typedef int ParameterFunction(void);
ReturnFunction *f(ParameterFunction *p);

As you see, it's pretty easy to build it up using typedefs. Without typedefs, it's not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That's what appears at the very left of the declaration, and is not of interest: It's added at the end if one built up the declarator already. Let's do that. Building it up consistently, first wordy - showing the structure using [ and ]:

function taking 
    [pointer to [function taking [void] returning [int]]] 
returning
    [pointer to [function taking [char] returning [int]]]

As you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I'll show both ways.
Bottom Up

Construction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i'm going to number them:

D1(char);

Inserted the char parameter directly, since it's trivial. Adding a pointer to declarator by replacing D1 by *D2. Note that we have to wrap parentheses around *D2. That can be known by looking up the precedence of the *-operator and the function-call operator (). Without our parentheses, the compiler would read it as *(D2(char p)). But that would not be a plain replace of D1 by *D2 anymore, of course. Parentheses are always allowed around declarators. So you don't make anything wrong if you add too much of them, actually.

(*D2)(char);

Return type is complete! Now, let's replace D2 by the function declarator function taking <parameters> returning, which is D3(<parameters>) which we are at now.

(*D3(<parameters>))(char)

Note that no parentheses are needed, since we want D3 to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we've done the return type, just with char replaced by void. So i'll copy it:

(*D3(   (*ID1)(void)))(char)

I've replaced D2 by ID1, since we are finished with that parameter (it's already a pointer to a function - no need for another declarator). ID1 will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It's interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times int of course.

int (*ID0(int (*ID1)(void)))(char)

I've called the identifier of the function ID0 in that example.
Top Down

This starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with function taking <parameters> returning

ID0(<parameters>)

The next thing in the description (after "returning") was pointer to. Let's incorporate it:

*ID0(<parameters>)

Then the next thing was functon taking <parameters> returning. The parameter is a simple char, so we put it in right away again, since it's really trivial.

(*ID0(<parameters>))(char)

Note the parentheses we added, since we again want that the * binds first, and then the (char). Otherwise it would read function taking <parameters> returning function .... Noes, functions returning functions aren't even allowed.

Now we just need to put <parameters>. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.

pointer to: *ID1
... function taking void returning: (*ID1)(void)

Just put int before the declarators like we did with bottom-up, and we are finished

int (*ID0(int (*ID1)(void)))(char)

The nice thing

Is bottom-up or top-down better? I'm used to bottom-up, but some people may be more comfortable with top-down. It's a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:

int v = (*ID0(some_function_pointer))(some_char);

That is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It's like that for arrays too.

Hope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it.
shareimprove this answer
	
edited May 9 '09 at 13:38
	
community wiki

3 revs
Johannes Schaub - litb
	
add a comment
up vote
16
down vote
	
Another good use for function pointers:
Switching between versions painlessly

They're very handy to use for when you want different functions at different times, or different phases of development. For instance, I'm developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use printf to view status and error messages, but when I'm done, I don't want anything printed. Here's what I've done:
version.h

// First, undefine all macros associated with version.h
#undef DEBUG_VERSION
#undef RELEASE_VERSION
#undef INVALID_VERSION


// Define which version we want to use
#define DEBUG_VERSION       // The current version
// #define RELEASE_VERSION  // To be uncommented when finished debugging

#ifndef __VERSION_H_      /* prevent circular inclusions */
    #define __VERSION_H_  /* by using protection macros */
    void board_init();
    void noprintf(const char *c, ...); // mimic the printf prototype
#endif

// Mimics the printf function prototype. This is what I'll actually 
// use to print stuff to the screen
void (* zprintf)(const char*, ...); 

// If debug version, use printf
#ifdef DEBUG_VERSION
    #include <stdio.h>
#endif

// If both debug and release version, error
#ifdef DEBUG_VERSION
#ifdef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

// If neither debug or release version, error
#ifndef DEBUG_VERSION
#ifndef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

#ifdef INVALID_VERSION
    // Won't allow compilation without a valid version define
    #error "Invalid version definition"
#endif

In version.c I will define the 2 function prototypes present in version.h
version.c

#include "version.h"

/*****************************************************************************/
/**
* @name board_init
*
* Sets up the application based on the version type defined in version.h.
* Includes allowing or prohibiting printing to STDOUT.
*
* MUST BE CALLED FIRST THING IN MAIN
*
* @return    None
*
*****************************************************************************/
void board_init()
{
    // Assign the print function to the correct function pointer
    #ifdef DEBUG_VERSION
        zprintf = &printf;
    #else
        // Defined below this function
        zprintf = &noprintf;
    #endif
}

/*****************************************************************************/
/**
* @name noprintf
*
* simply returns with no actions performed
*
* @return   None
*
*****************************************************************************/
void noprintf(const char* c, ...)
{
    return;
}

Notice how the function pointer is prototyped in version.h as

void (* zprintf)(const char *, ...);

When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.

In version.c, notice in the board_init()function where zprintf is assigned a unique function (whose function signature matches) depending on the version that is defined in version.h

zprintf = &printf; zprintf calls printf for debugging purposes

or

zprintf = &noprint; zprintf just returns and will not run unnecessary code

Running the code will look like this:
mainProg.c

#include "version.h"
#include <stdlib.h>
int main()
{
    // Must run board_init(), which assigns the function
    // pointer to an actual function
    board_init();

    void *ptr = malloc(100); // Allocate 100 bytes of memory
    // malloc returns NULL if unable to allocate the memory.

    if (ptr == NULL)
    {
        zprintf("Unable to allocate memory\n");
        return 1;
    }

    // Other things to do...
    return 0;
}

The above code will use printf if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in version.h and the code will do the rest!
shareimprove this answer
	
edited Jun 11 '13 at 15:36
	
community wiki

2 revs
Zack Sheffield
	
add a comment
up vote
9
down vote
	

Function pointer is usually defined by typedef, and used as param & return value,

Above answers already explained a lot, I just give a full example:

#include <stdio.h>

#define NUM_A 1
#define NUM_B 2

// define a function pointer type
typedef int (*two_num_operation)(int, int);

// an actual standalone function
static int sum(int a, int b) {
    return a + b;
}

// use function pointer as param,
static int sum_via_pointer(int a, int b, two_num_operation funp) {
    return (*funp)(a, b);
}

// use function pointer as return value,
static two_num_operation get_sum_fun() {
    return &sum;
}

// test - use function pointer as variable,
void test_pointer_as_variable() {
    // create a pointer to function,
    two_num_operation sum_p = &sum;
    // call function via pointer
    printf("pointer as variable:\t %d + %d = %d\n", NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));
}

// test - use function pointer as param,
void test_pointer_as_param() {
    printf("pointer as param:\t %d + %d = %d\n", NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &sum));
}

// test - use function pointer as return value,
void test_pointer_as_return_value() {
    printf("pointer as return value:\t %d + %d = %d\n", NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));
}

int main() {
    test_pointer_as_variable();
    test_pointer_as_param();
    test_pointer_as_return_value();

    return 0;
}

shareimprove this answer
	
answered Nov 10 '14 at 8:50
	
community wiki

Eric Wang
	
add a comment
up vote
2
down vote
	

One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, qsort and bsearch, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use.

A very basic example, if there is one function called print(int x, int y) which in turn may require to call add() function or sub() which are of similar types then what we will do, we will add one function pointer argument to the print() function as shown below:-

int add()
{
   return (100+10);
}

int sub()
{
   return (100-10);
}

void print(int x, int y, int (*func)())
{
    printf("value is : %d", (x+y+(*func)()));
}

int main()
{
    int x=100, y=200;
    print(x,y,add);
    print(x,y,sub);

    return 0;
}

shareimprove this answer
	
edited Jan 3 '15 at 17:52
	
community wiki

2 revs, 2 users 96%
Vamsi
	
add a comment
up vote
1
down vote
	

Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call "function's memory address").Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C

1.First you need to declare a pointer to function 2.Pass the Address of the Desired function

****Note->the functions should be of same type****

This Simple Programme will Illustrate Every Thing.

#include<stdio.h>
void (*print)() ;//Declare a  Function Pointers
void sayhello();//Declare The Function Whose Address is to be passed
                //The Functions should Be of Same Type
int main()
{

 print=sayhello;//Addressof sayhello is assigned to print
 print();//print Does A call To The Function 
 return 0;
}

void sayhello()
{
 printf("\n Hello World");
}

enter image description hereAfter That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.

The red mark area is showing how the address is being exchanged and storing in eax.Then their is a call instruction on eax. eax contains the desired address of the function
shareimprove this answer
	
answered Sep 26 '14 at 8:09
	
community wiki

Mohit Dabas
	
add a comment
up vote
0
down vote
	

Since function pointers are often typed callbacks, you might want to have a look at type safe callbacks. The same applies to entry points, etc of functions that are not callbacks.

C is quite fickle and forgiving at the same time :)
shareimprove this answer
	
answered May 9 '09 at 13:56
	
community wiki

Tim Post
	
add a comment
up vote
-3
down vote
	

function pointers are useful in many situations, eg:

    COM objects members are pointer to function ag: This->lpVtbl->AddRef(This); AddRef is a pointer to a function.
    function callback, for example a user defined function to compares two variables to be passed as a callback to a special sort function.
    very useful for plugin implementation and application SDK.

shareimprove this answer
	
answered Jan 2 at 13:15
	
community wiki

milevyo
	
add a comment
protected by Sourav Ghosh May 16 '15 at 11:45

Thank you for your interest in this question. Because it has attracted low-quality or spam answers that had to be removed, posting an answer now requires 10 reputation on this site (the association bonus does not count).

Would you like to answer one of these unanswered questions instead?
Not the answer you're looking for? Browse other questions tagged c function-pointers or ask your own question.

asked
	

7 years ago

viewed
	

479255 times

active
	

12 months ago
Want a python job?

    Senior Python Developer
    HackerEarthBengaluru, India
    ₹1,500,000 - ₹2,500,000Relocation
    pythondjango
    Data Scientist
    MakemytripBengaluru, India
    Relocation
    machine-learningpython
    DevOps Engineer
    RedMartBengaluru, India
    pythonr
    Senior Systems Engineer
    DataXuBengaluru, India
    pythonjavascript

Linked
0
What does void *(*routine)(void *) mean in C?
3
Passing function pointers as arguments
0
Function Pointers Error In C
2
C pass pointer as argument in function
2
For function pointer “fptr”,why is value of “fptr” and *fptr same?What *fptr even mean?I only knew (*fptr)() or fptr()
2
How does function pointer in C actually work?
0
Passing a parameter in a callback in C
1
Can't understand code/function call
1
Please explain the following piece of code. I'm a beginner so please help me understand
0
What does an asterisk in empty parentheses mean?
see more linked questions…
Related
154
Why do function pointer definitions work with any number of ampersands '&' or asterisks '*'?
141
How does the C code that prints from 1 to 1000 without loops or conditional statements work?
7
How to use a function pointer in a C struct?
6
Pointers to any function?
7
function pointer to different functions with different arguments in C
2
Function pointer syntax in C
25
Returning function pointer type
0
Restart a computer using function pointers in C
2
How can a function pointer replace switch statement?
4
pattern for handling function pointer of functions of inhomogene signature in C
Hot Network Questions

    A bit, a nibble or byte?
    Could this kind of authentification be attacked?
    Animate tacky Christmas light decorations
    How is Sovereign Glue affected by Dispel Magic or an Antimagic Field?
    Help with a prime number spiral which turns 90 degrees at each prime
    Why does Hermione dislike Professor Trelawney from the start?
    How is the date of entry and exit of Schengen decided?
    What does this joke mean?
    Is the computer cheating at Dice Poker?
    Total count of Theorem like environments - In all chapters
    What is an asymmetric wheel and why would you use it?
    What's the first noticeable instance of Hermione showing the negative effects due to her timeturner use in the third year?
    When are there infinitely many primes in a sequence generated by a simple recurrence relation?
    I made it up with no more than one. But one what?
    A question about oversets in an equation
    NIntegrate into NDSolve with variable integrand
    How to understand 'quae prosum sola nocendo'?
    How did a Jedi die during the Battle of Geonosis?
    How can I easily double any size number in my head?
    Appropriate age for Rubik's cube
    changing user home directory has no effect
    What is the difference between motivation and inspiration?
    How do I prevent flight in a cyberpunk future?
    A program that guesses your number using bitwise operations C++

question feed
about us tour help blog chat data legal privacy policy work here advertising info mobile contact us feedback
Technology 	Life / Arts 	Culture / Recreation 	Science 	Other

    Stack Overflow
    Server Fault
    Super User
    Web Applications
    Ask Ubuntu
    Webmasters
    Game Development
    TeX - LaTeX

	

    Software Engineering
    Unix & Linux
    Ask Different (Apple)
    WordPress Development
    Geographic Information Systems
    Electrical Engineering
    Android Enthusiasts
    Information Security

	

    Database Administrators
    Drupal Answers
    SharePoint
    User Experience
    Mathematica
    Salesforce
    ExpressionEngine® Answers
    Cryptography

	

    Code Review
    Magento
    Signal Processing
    Raspberry Pi
    Programming Puzzles & Code Golf
    more (7)

	

    Photography
    Science Fiction & Fantasy
    Graphic Design
    Movies & TV
    Music: Practice & Theory
    Seasoned Advice (cooking)
    Home Improvement
    Personal Finance & Money

	

    Academia
    more (8)

	

    English Language & Usage
    Skeptics
    Mi Yodeya (Judaism)
    Travel
    Christianity
    English Language Learners
    Japanese Language
    Arqade (gaming)

	

    Bicycles
    Role-playing Games
    Anime & Manga
    Motor Vehicle Maintenance & Repair
    more (17)

	

    MathOverflow
    Mathematics
    Cross Validated (stats)
    Theoretical Computer Science
    Physics
    Chemistry
    Biology
    Computer Science

	

    Philosophy
    more (3)

	

    Meta Stack Exchange
    Stack Apps
    Area 51
    Stack Overflow Talent

site design / logo © 2016 Stack Exchange Inc; user contributions licensed under cc by-sa 3.0 with attribution required
rev 2016.12.24.1

Stack Exchange Inbox Reputation and Badges
sign up log in tour help

Stack Overflow

    Questions
    Jobs
    Documentation
    Tags
    Users
    Badges

    Ask Question

x Dismiss
Join the Stack Overflow Community
Stack Overflow is a community of 6.5 million programmers, just like you, helping each other.
Join them; it only takes a minute:
Sign up
How do function pointers in C work?
up vote
728
down vote
favorite
604
	

I had some experience lately with function pointers in C.

So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.
c function-pointers
shareimprove this question
	
asked May 8 '09 at 15:49
	
community wiki

Yuval Adam
	
17 	 
	
Also: For a bit of an in-depth analysis of C pointers, see blogs.oracle.com/ksplice/entry/the_ksplice_pointer_challenge‌​. Also, Programming from the Ground Up shows how they work on the machine level. Understanding C's "memory model" is very useful for understanding how C pointers work. – Abbafei May 22 '13 at 11:17
3 	 
	
Great info. By the title though, I would have expected to really see an explanation of how "function pointers work", not how they are coded :) – Bogdan Alexandru Aug 28 '14 at 12:39
26 	 
	
"How do function pointers in C work?" Just fine, thanks. – Keith Thompson Nov 17 '14 at 19:07
add a comment
11 Answers
active
oldest
votes
up vote
889
down vote
accepted
	
Functions pointers in C

Let's start with a basic function which we will be pointing to:

int addInt(int n, int m) {
    return n+m;
}

First thing, lets define a pointer to a function which receives 2 ints and returns and int:

int (*functionPtr)(int,int);

Now we can safely point to our function:

functionPtr = &addInt;

Now that we have a pointer to the function, lets use it:

int sum = (*functionPtr)(2, 3); // sum == 5

Passing the pointer to another function is basically the same:

int add2to3(int (*functionPtr)(int, int)) {
    return (*functionPtr)(2, 3);
}

We can use function pointers in return values as well (try to keep up, it gets messy):

// this is a function called functionFactory which receives parameter n
// and returns a pointer to another function which receives two ints
// and it returns another int
int (*functionFactory(int n))(int, int) {
    printf("Got parameter %d", n);
    int (*functionPtr)(int,int) = &addInt;
    return functionPtr;
}

But it's much nicer to use a typedef:

typedef int (*myFuncDef)(int, int);
// note that the typedef name is indeed myFuncDef

myFuncDef functionFactory(int n) {
    printf("Got parameter %d", n);
    myFuncDef functionPtr = &addInt;
    return functionPtr;
}

shareimprove this answer
	
edited May 20 '15 at 13:25
idmean
8,03262455
	
answered May 8 '09 at 15:49
Yuval Adam
88k63240332
	
9 	 
	
Thanks for the great info. Could you add some insight on where function pointers are used or happen to be particularly useful? – Rich.Carpenter May 8 '09 at 15:55
175 	 
	
"functionPtr = &addInt;" can also be written (and often is) as " functionPtr = addInt;" which is also valid since the standard says that a function name in this context is converted to the address of the function. – hlovdal May 9 '09 at 14:39
8 	 
	
hlovdal, in this context it's interesting to explain that this is what enables one to write functionPtr = ******************addInt; – Johannes Schaub - litb May 10 '09 at 17:54
53 	 
	
@Rich.Carpenter I know this is 4 years too late, but I figure other people might benefit from this: Function pointers are useful for passing functions as parameters to other functions. It took a lot of searching for me to find that answer for some odd reason. So basically, it gives C pseudo first-class functionality. – giant91 Oct 13 '13 at 2:28
7 	 
	
@Rich.Carpenter: function pointers are nice for runtime CPU detection. Have multiple versions of some functions to take advantage of SSE, popcnt, AVX, etc. At startup, set your function pointers to the best version of each function for the current CPU. In your other code, just call through the function pointer instead of having conditional branches on the CPU features everywhere. Then you can do complicated logic about deciding that well, even though this CPU supports pshufb, it's slow, so the earlier implementation is still faster. x264/x265 use this extensively, and are open source. – Peter Cordes Aug 30 '15 at 2:22
show 8 more comments
up vote
209
down vote
	

Function pointers in C can be used to perform object-oriented programming in C.

For example, the following lines is written in C:

String s1 = newString();
s1->set(s1, "hello");

Yes, the -> and the lack of a new operator is a dead give away, but it sure seems to imply that we're setting the text of some String class to be "hello".

By using function pointers, it is possible to emulate methods in C.

How is this accomplished?

The String class is actually a struct with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the String class:

typedef struct String_Struct* String;

struct String_Struct
{
    char* (*get)(const void* self);
    void (*set)(const void* self, char* value);
    int (*length)(const void* self);
};

char* getString(const void* self);
void setString(const void* self, char* value);
int lengthString(const void* self);

String newString();

As can be seen, the methods of the String class are actually function pointers to the declared function. In preparing the instance of the String, the newString function is called in order to set up the function pointers to their respective functions:

String newString()
{
    String self = (String)malloc(sizeof(struct String_Struct));

    self->get = &getString;
    self->set = &setString;
    self->length = &lengthString;

    self->set(self, "");

    return self;
}

For example, the getString function that is called by invoking the get method is defined as the following:

char* getString(const void* self_obj)
{
    return ((String)self_obj)->internal->value;
}

One thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a "self object" must be passed in on each invocation. (And the internal is just a hidden struct which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)

So, rather than being able to do s1->set("hello");, one must pass in the object to perform the action on s1->set(s1, "hello").

With that minor explanation having to pass in a reference to yourself out of the way, we'll move to the next part, which is inheritance in C.

Let's say we want to make a subclass of String, say an ImmutableString. In order to make the string immutable, the set method will not be accessible, while maintaining access to get and length, and force the "constructor" to accept a char*:

typedef struct ImmutableString_Struct* ImmutableString;

struct ImmutableString_Struct
{
    String base;

    char* (*get)(const void* self);
    int (*length)(const void* self);
};

ImmutableString newImmutableString(const char* value);

Basically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the set method is not present, therefore, it cannot be called in a ImmutableString.

As for the implementation of the ImmutableString, the only relevant code is the "constructor" function, the newImmutableString:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = self->base->length;

    self->base->set(self->base, (char*)value);

    return self;
}

In instantiating the ImmutableString, the function pointers to the get and length methods actually refer to the String.get and String.length method, by going through the base variable which is an internally stored String object.

The use of a function pointer can achieve inheritance of a method from a superclass.

We can further continue to polymorphism in C.

If for example we wanted to change the behavior of the length method to return 0 all the time in the ImmutableString class for some reason, all that would have to be done is to:

    Add a function that is going to serve as the overriding length method.
    Go to the "constructor" and set the function pointer to the overriding length method.

Adding an overriding length method in ImmutableString may be performed by adding an lengthOverrideMethod:

int lengthOverrideMethod(const void* self)
{
    return 0;
}

Then, the function pointer for the length method in the constructor is hooked up to the lengthOverrideMethod:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = &lengthOverrideMethod;

    self->base->set(self->base, (char*)value);

    return self;
}

Now, rather than having an identical behavior for the length method in ImmutableString class as the String class, now the length method will refer to the behavior defined in the lengthOverrideMethod function.

I must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn't explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.

For more information on how to perform object-oriented programming in C, please refer to the following questions:

    Object-Orientation in C?
    Can you write object oriented code in C?

shareimprove this answer
	
edited Oct 14 '14 at 7:19
	
community wiki

2 revs, 2 users 100%
coobird
	
6 	 
	
This answer is horrible! Not only it implies that OO somehow depends on dot notation, it also encourages putting junk into your objects! – Alexei Averchenko Sep 16 '12 at 14:30
12 	 
	
This is OO all right, but not anywhere near the C-style OO. What you have brokenly implemented is Javascript-style prototype-based OO. To get C++/Pascal-style OO, you'd need to: 1. Have a const struct for a virtual table of each class with virtual members. 2. Have pointer to that struct in polymorphic objects. 3. Call virtual methods via the virtual table, and all other methods directly -- usually by sticking to some ClassName_methodName function naming convention. Only then you get the same runtime and storage costs as you do in C++ and Pascal. – Kuba Ober Mar 18 '13 at 21:53
9 	 
	
Working OO with a language that is not intended to be OO is always a bad idea. If you want OO and still have C just work with C++. – rbaleksandar Jul 4 '13 at 15:21
6 	 
	
@rbaleksandar Tell that to the Linux kernel developers. "always a bad idea" is strictly your opinion, with which I firmly disagree. – Jonathon Reinhart Apr 30 '15 at 12:31
   	 
	
@KubaOber which sounds like GObject, right? – underscore_d Apr 20 at 21:17
show 4 more comments
up vote
139
down vote
	

The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:

    Returns the current value on the EAX register

    int eax = ((int(*)())("\xc3 <- This returns the value of the EAX register"))();

    Write a swap function

    int a = 10, b = 20;
    ((void(*)(int*,int*))"\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3 <- This swaps the values of a and b")(&a,&b);

    Write a for-loop counter to 1000, calling some function each time

    ((int(*)())"\x66\x31\xc0\x8b\x5c\x24\x04\x66\x40\x50\xff\xd3\x58\x66\x3d\xe8\x03\x75\xf4\xc3")(&function); // calls function with 1->1000

    You can even write a recursive function that counts to 100

    const char* lol = "\x8b\x5c\x24\x4\x3d\xe8\x3\x0\x0\x7e\x2\x31\xc0\x83\xf8\x64\x7d\x6\x40\x53\xff\xd3\x5b\xc3\xc3 <- Recursively calls the function at address lol.";
    i = ((int(*)())(lol))(lol);

shareimprove this answer
	
edited Apr 22 '15 at 11:53
	
community wiki

2 revs, 2 users 98%
Lee Gao
	
6 	 
	
Note: this doesn't work if Data Execution Prevention is enabled (e.g. on Windows XP SP2+), because C strings are not normally marked as executable. – SecurityMatt Feb 12 '13 at 5:53
1 	 
	
will this work on Visual Studio? I get:error C2440: 'type cast' : cannot convert from 'const char [68]' to 'void (__cdecl *)(int *,int *)' . Any ideas? – roboto1986 Jul 3 '13 at 18:42
3 	 
	
Hi Matt! Depending on the optimization level, GCC will often inline string constants into the TEXT segment, so this will work even on newer version of windows provided that you don't disallow this type of optimization. (IIRC, the MINGW version at the time of my post over two years ago inlines string literals at the default optimization level) – Lee Jan 2 '14 at 6:20
3 	 
	
could someone please explain what's happening here? What are those weird looking string literals? – ajay Jan 20 '14 at 10:17
18 	 
	
@ajay It looks like he's writing raw hexidecimal values (for instance '\x00' is the same as '/0', they're both equal to 0) into a string, then casting the string into a C function pointer, then executing the C function pointer because he's the devil. – ejk314 Feb 21 '14 at 21:27
show 9 more comments
up vote
68
down vote
	

One of my favorite uses for function pointers is as cheap and easy iterators -

#include <stdio.h>
#define MAX_COLORS  256

typedef struct {
    char* name;
    int red;
    int green;
    int blue;
} Color;

Color Colors[MAX_COLORS];


void eachColor (void (*fp)(Color *c)) {
    int i;
    for (i=0; i<MAX_COLORS; i++)
        (*fp)(&Colors[i]);
}

void printColor(Color* c) {
    if (c->name)
        printf("%s = %i,%i,%i\n", c->name, c->red, c->green, c->blue);
}

int main() {
    Colors[0].name="red";
    Colors[0].red=255;
    Colors[1].name="blue";
    Colors[1].blue=255;
    Colors[2].name="black";

    eachColor(printColor);
}

shareimprove this answer
	
edited Jul 24 '12 at 16:40
	
community wiki

2 revs, 2 users 99%
Nick
	
7 	 
	
You should also pass a pointer to user-specified data if you want to somehow extract any output from iterations (think closures). – Alexei Averchenko Sep 16 '12 at 14:32
   	 
	
Agreed. All of my iterators look like this: int (*cb)(void *arg, ...). The return value of the iterator also lets me stop early (if nonzero). – Jonathon Reinhart Apr 30 '15 at 12:35
add a comment
up vote
19
down vote
	

Function pointers become easy to declare once you have the basic declarators:

    id: ID: ID is a
    Pointer: *D: D pointer to
    Function: D(<parameters>): D function taking <parameters> returning

While D is another declarator built using those same rules. In the end, somewhere, it ends with ID (see below for an example), which is the name of the declared entity. Let's try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it's like this

typedef int ReturnFunction(char);
typedef int ParameterFunction(void);
ReturnFunction *f(ParameterFunction *p);

As you see, it's pretty easy to build it up using typedefs. Without typedefs, it's not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That's what appears at the very left of the declaration, and is not of interest: It's added at the end if one built up the declarator already. Let's do that. Building it up consistently, first wordy - showing the structure using [ and ]:

function taking 
    [pointer to [function taking [void] returning [int]]] 
returning
    [pointer to [function taking [char] returning [int]]]

As you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I'll show both ways.
Bottom Up

Construction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i'm going to number them:

D1(char);

Inserted the char parameter directly, since it's trivial. Adding a pointer to declarator by replacing D1 by *D2. Note that we have to wrap parentheses around *D2. That can be known by looking up the precedence of the *-operator and the function-call operator (). Without our parentheses, the compiler would read it as *(D2(char p)). But that would not be a plain replace of D1 by *D2 anymore, of course. Parentheses are always allowed around declarators. So you don't make anything wrong if you add too much of them, actually.

(*D2)(char);

Return type is complete! Now, let's replace D2 by the function declarator function taking <parameters> returning, which is D3(<parameters>) which we are at now.

(*D3(<parameters>))(char)

Note that no parentheses are needed, since we want D3 to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we've done the return type, just with char replaced by void. So i'll copy it:

(*D3(   (*ID1)(void)))(char)

I've replaced D2 by ID1, since we are finished with that parameter (it's already a pointer to a function - no need for another declarator). ID1 will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It's interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times int of course.

int (*ID0(int (*ID1)(void)))(char)

I've called the identifier of the function ID0 in that example.
Top Down

This starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with function taking <parameters> returning

ID0(<parameters>)

The next thing in the description (after "returning") was pointer to. Let's incorporate it:

*ID0(<parameters>)

Then the next thing was functon taking <parameters> returning. The parameter is a simple char, so we put it in right away again, since it's really trivial.

(*ID0(<parameters>))(char)

Note the parentheses we added, since we again want that the * binds first, and then the (char). Otherwise it would read function taking <parameters> returning function .... Noes, functions returning functions aren't even allowed.

Now we just need to put <parameters>. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.

pointer to: *ID1
... function taking void returning: (*ID1)(void)

Just put int before the declarators like we did with bottom-up, and we are finished

int (*ID0(int (*ID1)(void)))(char)

The nice thing

Is bottom-up or top-down better? I'm used to bottom-up, but some people may be more comfortable with top-down. It's a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:

int v = (*ID0(some_function_pointer))(some_char);

That is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It's like that for arrays too.

Hope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it.
shareimprove this answer
	
edited May 9 '09 at 13:38
	
community wiki

3 revs
Johannes Schaub - litb
	
add a comment
up vote
16
down vote
	
Another good use for function pointers:
Switching between versions painlessly

They're very handy to use for when you want different functions at different times, or different phases of development. For instance, I'm developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use printf to view status and error messages, but when I'm done, I don't want anything printed. Here's what I've done:
version.h

// First, undefine all macros associated with version.h
#undef DEBUG_VERSION
#undef RELEASE_VERSION
#undef INVALID_VERSION


// Define which version we want to use
#define DEBUG_VERSION       // The current version
// #define RELEASE_VERSION  // To be uncommented when finished debugging

#ifndef __VERSION_H_      /* prevent circular inclusions */
    #define __VERSION_H_  /* by using protection macros */
    void board_init();
    void noprintf(const char *c, ...); // mimic the printf prototype
#endif

// Mimics the printf function prototype. This is what I'll actually 
// use to print stuff to the screen
void (* zprintf)(const char*, ...); 

// If debug version, use printf
#ifdef DEBUG_VERSION
    #include <stdio.h>
#endif

// If both debug and release version, error
#ifdef DEBUG_VERSION
#ifdef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

// If neither debug or release version, error
#ifndef DEBUG_VERSION
#ifndef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

#ifdef INVALID_VERSION
    // Won't allow compilation without a valid version define
    #error "Invalid version definition"
#endif

In version.c I will define the 2 function prototypes present in version.h
version.c

#include "version.h"

/*****************************************************************************/
/**
* @name board_init
*
* Sets up the application based on the version type defined in version.h.
* Includes allowing or prohibiting printing to STDOUT.
*
* MUST BE CALLED FIRST THING IN MAIN
*
* @return    None
*
*****************************************************************************/
void board_init()
{
    // Assign the print function to the correct function pointer
    #ifdef DEBUG_VERSION
        zprintf = &printf;
    #else
        // Defined below this function
        zprintf = &noprintf;
    #endif
}

/*****************************************************************************/
/**
* @name noprintf
*
* simply returns with no actions performed
*
* @return   None
*
*****************************************************************************/
void noprintf(const char* c, ...)
{
    return;
}

Notice how the function pointer is prototyped in version.h as

void (* zprintf)(const char *, ...);

When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.

In version.c, notice in the board_init()function where zprintf is assigned a unique function (whose function signature matches) depending on the version that is defined in version.h

zprintf = &printf; zprintf calls printf for debugging purposes

or

zprintf = &noprint; zprintf just returns and will not run unnecessary code

Running the code will look like this:
mainProg.c

#include "version.h"
#include <stdlib.h>
int main()
{
    // Must run board_init(), which assigns the function
    // pointer to an actual function
    board_init();

    void *ptr = malloc(100); // Allocate 100 bytes of memory
    // malloc returns NULL if unable to allocate the memory.

    if (ptr == NULL)
    {
        zprintf("Unable to allocate memory\n");
        return 1;
    }

    // Other things to do...
    return 0;
}

The above code will use printf if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in version.h and the code will do the rest!
shareimprove this answer
	
edited Jun 11 '13 at 15:36
	
community wiki

2 revs
Zack Sheffield
	
add a comment
up vote
9
down vote
	

Function pointer is usually defined by typedef, and used as param & return value,

Above answers already explained a lot, I just give a full example:

#include <stdio.h>

#define NUM_A 1
#define NUM_B 2

// define a function pointer type
typedef int (*two_num_operation)(int, int);

// an actual standalone function
static int sum(int a, int b) {
    return a + b;
}

// use function pointer as param,
static int sum_via_pointer(int a, int b, two_num_operation funp) {
    return (*funp)(a, b);
}

// use function pointer as return value,
static two_num_operation get_sum_fun() {
    return &sum;
}

// test - use function pointer as variable,
void test_pointer_as_variable() {
    // create a pointer to function,
    two_num_operation sum_p = &sum;
    // call function via pointer
    printf("pointer as variable:\t %d + %d = %d\n", NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));
}

// test - use function pointer as param,
void test_pointer_as_param() {
    printf("pointer as param:\t %d + %d = %d\n", NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &sum));
}

// test - use function pointer as return value,
void test_pointer_as_return_value() {
    printf("pointer as return value:\t %d + %d = %d\n", NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));
}

int main() {
    test_pointer_as_variable();
    test_pointer_as_param();
    test_pointer_as_return_value();

    return 0;
}

shareimprove this answer
	
answered Nov 10 '14 at 8:50
	
community wiki

Eric Wang
	
add a comment
up vote
2
down vote
	

One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, qsort and bsearch, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use.

A very basic example, if there is one function called print(int x, int y) which in turn may require to call add() function or sub() which are of similar types then what we will do, we will add one function pointer argument to the print() function as shown below:-

int add()
{
   return (100+10);
}

int sub()
{
   return (100-10);
}

void print(int x, int y, int (*func)())
{
    printf("value is : %d", (x+y+(*func)()));
}

int main()
{
    int x=100, y=200;
    print(x,y,add);
    print(x,y,sub);

    return 0;
}

shareimprove this answer
	
edited Jan 3 '15 at 17:52
	
community wiki

2 revs, 2 users 96%
Vamsi
	
add a comment
up vote
1
down vote
	

Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call "function's memory address").Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C

1.First you need to declare a pointer to function 2.Pass the Address of the Desired function

****Note->the functions should be of same type****

This Simple Programme will Illustrate Every Thing.

#include<stdio.h>
void (*print)() ;//Declare a  Function Pointers
void sayhello();//Declare The Function Whose Address is to be passed
                //The Functions should Be of Same Type
int main()
{

 print=sayhello;//Addressof sayhello is assigned to print
 print();//print Does A call To The Function 
 return 0;
}

void sayhello()
{
 printf("\n Hello World");
}

enter image description hereAfter That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.

The red mark area is showing how the address is being exchanged and storing in eax.Then their is a call instruction on eax. eax contains the desired address of the function
shareimprove this answer
	
answered Sep 26 '14 at 8:09
	
community wiki

Mohit Dabas
	
add a comment
up vote
0
down vote
	

Since function pointers are often typed callbacks, you might want to have a look at type safe callbacks. The same applies to entry points, etc of functions that are not callbacks.

C is quite fickle and forgiving at the same time :)
shareimprove this answer
	
answered May 9 '09 at 13:56
	
community wiki

Tim Post
	
add a comment
up vote
-3
down vote
	

function pointers are useful in many situations, eg:

    COM objects members are pointer to function ag: This->lpVtbl->AddRef(This); AddRef is a pointer to a function.
    function callback, for example a user defined function to compares two variables to be passed as a callback to a special sort function.
    very useful for plugin implementation and application SDK.

shareimprove this answer
	
answered Jan 2 at 13:15
	
community wiki

milevyo
	
add a comment
protected by Sourav Ghosh May 16 '15 at 11:45

Thank you for your interest in this question. Because it has attracted low-quality or spam answers that had to be removed, posting an answer now requires 10 reputation on this site (the association bonus does not count).

Would you like to answer one of these unanswered questions instead?
Not the answer you're looking for? Browse other questions tagged c function-pointers or ask your own question.

asked
	

7 years ago

viewed
	

479255 times

active
	

12 months ago
Want a python job?

    Senior Python Developer
    HackerEarthBengaluru, India
    ₹1,500,000 - ₹2,500,000Relocation
    pythondjango
    Data Scientist
    MakemytripBengaluru, India
    Relocation
    machine-learningpython
    DevOps Engineer
    RedMartBengaluru, India
    pythonr
    Senior Systems Engineer
    DataXuBengaluru, India
    pythonjavascript

Linked
0
What does void *(*routine)(void *) mean in C?
3
Passing function pointers as arguments
0
Function Pointers Error In C
2
C pass pointer as argument in function
2
For function pointer “fptr”,why is value of “fptr” and *fptr same?What *fptr even mean?I only knew (*fptr)() or fptr()
2
How does function pointer in C actually work?
0
Passing a parameter in a callback in C
1
Can't understand code/function call
1
Please explain the following piece of code. I'm a beginner so please help me understand
0
What does an asterisk in empty parentheses mean?
see more linked questions…
Related
154
Why do function pointer definitions work with any number of ampersands '&' or asterisks '*'?
141
How does the C code that prints from 1 to 1000 without loops or conditional statements work?
7
How to use a function pointer in a C struct?
6
Pointers to any function?
7
function pointer to different functions with different arguments in C
2
Function pointer syntax in C
25
Returning function pointer type
0
Restart a computer using function pointers in C
2
How can a function pointer replace switch statement?
4
pattern for handling function pointer of functions of inhomogene signature in C
Hot Network Questions

    A bit, a nibble or byte?
    Could this kind of authentification be attacked?
    Animate tacky Christmas light decorations
    How is Sovereign Glue affected by Dispel Magic or an Antimagic Field?
    Help with a prime number spiral which turns 90 degrees at each prime
    Why does Hermione dislike Professor Trelawney from the start?
    How is the date of entry and exit of Schengen decided?
    What does this joke mean?
    Is the computer cheating at Dice Poker?
    Total count of Theorem like environments - In all chapters
    What is an asymmetric wheel and why would you use it?
    What's the first noticeable instance of Hermione showing the negative effects due to her timeturner use in the third year?
    When are there infinitely many primes in a sequence generated by a simple recurrence relation?
    I made it up with no more than one. But one what?
    A question about oversets in an equation
    NIntegrate into NDSolve with variable integrand
    How to understand 'quae prosum sola nocendo'?
    How did a Jedi die during the Battle of Geonosis?
    How can I easily double any size number in my head?
    Appropriate age for Rubik's cube
    changing user home directory has no effect
    What is the difference between motivation and inspiration?
    How do I prevent flight in a cyberpunk future?
    A program that guesses your number using bitwise operations C++

question feed
about us tour help blog chat data legal privacy policy work here advertising info mobile contact us feedback
Technology 	Life / Arts 	Culture / Recreation 	Science 	Other

    Stack Overflow
    Server Fault
    Super User
    Web Applications
    Ask Ubuntu
    Webmasters
    Game Development
    TeX - LaTeX

	

    Software Engineering
    Unix & Linux
    Ask Different (Apple)
    WordPress Development
    Geographic Information Systems
    Electrical Engineering
    Android Enthusiasts
    Information Security

	

    Database Administrators
    Drupal Answers
    SharePoint
    User Experience
    Mathematica
    Salesforce
    ExpressionEngine® Answers
    Cryptography

	

    Code Review
    Magento
    Signal Processing
    Raspberry Pi
    Programming Puzzles & Code Golf
    more (7)

	

    Photography
    Science Fiction & Fantasy
    Graphic Design
    Movies & TV
    Music: Practice & Theory
    Seasoned Advice (cooking)
    Home Improvement
    Personal Finance & Money

	

    Academia
    more (8)

	

    English Language & Usage
    Skeptics
    Mi Yodeya (Judaism)
    Travel
    Christianity
    English Language Learners
    Japanese Language
    Arqade (gaming)

	

    Bicycles
    Role-playing Games
    Anime & Manga
    Motor Vehicle Maintenance & Repair
    more (17)

	

    MathOverflow
    Mathematics
    Cross Validated (stats)
    Theoretical Computer Science
    Physics
    Chemistry
    Biology
    Computer Science

	

    Philosophy
    more (3)

	

    Meta Stack Exchange
    Stack Apps
    Area 51
    Stack Overflow Talent

site design / logo © 2016 Stack Exchange Inc; user contributions licensed under cc by-sa 3.0 with attribution required
rev 2016.12.24.1

Stack Exchange Inbox Reputation and Badges
sign up log in tour help

Stack Overflow

    Questions
    Jobs
    Documentation
    Tags
    Users
    Badges

    Ask Question

x Dismiss
Join the Stack Overflow Community
Stack Overflow is a community of 6.5 million programmers, just like you, helping each other.
Join them; it only takes a minute:
Sign up
How do function pointers in C work?
up vote
728
down vote
favorite
604
	

I had some experience lately with function pointers in C.

So going on with the tradition of answering your own questions, I decided to make a small summary of the very basics, for those who need a quick dive-in to the subject.
c function-pointers
shareimprove this question
	
asked May 8 '09 at 15:49
	
community wiki

Yuval Adam
	
17 	 
	
Also: For a bit of an in-depth analysis of C pointers, see blogs.oracle.com/ksplice/entry/the_ksplice_pointer_challenge‌​. Also, Programming from the Ground Up shows how they work on the machine level. Understanding C's "memory model" is very useful for understanding how C pointers work. – Abbafei May 22 '13 at 11:17
3 	 
	
Great info. By the title though, I would have expected to really see an explanation of how "function pointers work", not how they are coded :) – Bogdan Alexandru Aug 28 '14 at 12:39
26 	 
	
"How do function pointers in C work?" Just fine, thanks. – Keith Thompson Nov 17 '14 at 19:07
add a comment
11 Answers
active
oldest
votes
up vote
889
down vote
accepted
	
Functions pointers in C

Let's start with a basic function which we will be pointing to:

int addInt(int n, int m) {
    return n+m;
}

First thing, lets define a pointer to a function which receives 2 ints and returns and int:

int (*functionPtr)(int,int);

Now we can safely point to our function:

functionPtr = &addInt;

Now that we have a pointer to the function, lets use it:

int sum = (*functionPtr)(2, 3); // sum == 5

Passing the pointer to another function is basically the same:

int add2to3(int (*functionPtr)(int, int)) {
    return (*functionPtr)(2, 3);
}

We can use function pointers in return values as well (try to keep up, it gets messy):

// this is a function called functionFactory which receives parameter n
// and returns a pointer to another function which receives two ints
// and it returns another int
int (*functionFactory(int n))(int, int) {
    printf("Got parameter %d", n);
    int (*functionPtr)(int,int) = &addInt;
    return functionPtr;
}

But it's much nicer to use a typedef:

typedef int (*myFuncDef)(int, int);
// note that the typedef name is indeed myFuncDef

myFuncDef functionFactory(int n) {
    printf("Got parameter %d", n);
    myFuncDef functionPtr = &addInt;
    return functionPtr;
}

shareimprove this answer
	
edited May 20 '15 at 13:25
idmean
8,03262455
	
answered May 8 '09 at 15:49
Yuval Adam
88k63240332
	
9 	 
	
Thanks for the great info. Could you add some insight on where function pointers are used or happen to be particularly useful? – Rich.Carpenter May 8 '09 at 15:55
175 	 
	
"functionPtr = &addInt;" can also be written (and often is) as " functionPtr = addInt;" which is also valid since the standard says that a function name in this context is converted to the address of the function. – hlovdal May 9 '09 at 14:39
8 	 
	
hlovdal, in this context it's interesting to explain that this is what enables one to write functionPtr = ******************addInt; – Johannes Schaub - litb May 10 '09 at 17:54
53 	 
	
@Rich.Carpenter I know this is 4 years too late, but I figure other people might benefit from this: Function pointers are useful for passing functions as parameters to other functions. It took a lot of searching for me to find that answer for some odd reason. So basically, it gives C pseudo first-class functionality. – giant91 Oct 13 '13 at 2:28
7 	 
	
@Rich.Carpenter: function pointers are nice for runtime CPU detection. Have multiple versions of some functions to take advantage of SSE, popcnt, AVX, etc. At startup, set your function pointers to the best version of each function for the current CPU. In your other code, just call through the function pointer instead of having conditional branches on the CPU features everywhere. Then you can do complicated logic about deciding that well, even though this CPU supports pshufb, it's slow, so the earlier implementation is still faster. x264/x265 use this extensively, and are open source. – Peter Cordes Aug 30 '15 at 2:22
show 8 more comments
up vote
209
down vote
	

Function pointers in C can be used to perform object-oriented programming in C.

For example, the following lines is written in C:

String s1 = newString();
s1->set(s1, "hello");

Yes, the -> and the lack of a new operator is a dead give away, but it sure seems to imply that we're setting the text of some String class to be "hello".

By using function pointers, it is possible to emulate methods in C.

How is this accomplished?

The String class is actually a struct with a bunch of function pointers which act as a way to simulate methods. The following is a partial declaration of the String class:

typedef struct String_Struct* String;

struct String_Struct
{
    char* (*get)(const void* self);
    void (*set)(const void* self, char* value);
    int (*length)(const void* self);
};

char* getString(const void* self);
void setString(const void* self, char* value);
int lengthString(const void* self);

String newString();

As can be seen, the methods of the String class are actually function pointers to the declared function. In preparing the instance of the String, the newString function is called in order to set up the function pointers to their respective functions:

String newString()
{
    String self = (String)malloc(sizeof(struct String_Struct));

    self->get = &getString;
    self->set = &setString;
    self->length = &lengthString;

    self->set(self, "");

    return self;
}

For example, the getString function that is called by invoking the get method is defined as the following:

char* getString(const void* self_obj)
{
    return ((String)self_obj)->internal->value;
}

One thing that can be noticed is that there is no concept of an instance of an object and having methods that are actually a part of an object, so a "self object" must be passed in on each invocation. (And the internal is just a hidden struct which was omitted from the code listing earlier -- it is a way of performing information hiding, but that is not relevant to function pointers.)

So, rather than being able to do s1->set("hello");, one must pass in the object to perform the action on s1->set(s1, "hello").

With that minor explanation having to pass in a reference to yourself out of the way, we'll move to the next part, which is inheritance in C.

Let's say we want to make a subclass of String, say an ImmutableString. In order to make the string immutable, the set method will not be accessible, while maintaining access to get and length, and force the "constructor" to accept a char*:

typedef struct ImmutableString_Struct* ImmutableString;

struct ImmutableString_Struct
{
    String base;

    char* (*get)(const void* self);
    int (*length)(const void* self);
};

ImmutableString newImmutableString(const char* value);

Basically, for all subclasses, the available methods are once again function pointers. This time, the declaration for the set method is not present, therefore, it cannot be called in a ImmutableString.

As for the implementation of the ImmutableString, the only relevant code is the "constructor" function, the newImmutableString:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = self->base->length;

    self->base->set(self->base, (char*)value);

    return self;
}

In instantiating the ImmutableString, the function pointers to the get and length methods actually refer to the String.get and String.length method, by going through the base variable which is an internally stored String object.

The use of a function pointer can achieve inheritance of a method from a superclass.

We can further continue to polymorphism in C.

If for example we wanted to change the behavior of the length method to return 0 all the time in the ImmutableString class for some reason, all that would have to be done is to:

    Add a function that is going to serve as the overriding length method.
    Go to the "constructor" and set the function pointer to the overriding length method.

Adding an overriding length method in ImmutableString may be performed by adding an lengthOverrideMethod:

int lengthOverrideMethod(const void* self)
{
    return 0;
}

Then, the function pointer for the length method in the constructor is hooked up to the lengthOverrideMethod:

ImmutableString newImmutableString(const char* value)
{
    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));

    self->base = newString();

    self->get = self->base->get;
    self->length = &lengthOverrideMethod;

    self->base->set(self->base, (char*)value);

    return self;
}

Now, rather than having an identical behavior for the length method in ImmutableString class as the String class, now the length method will refer to the behavior defined in the lengthOverrideMethod function.

I must add a disclaimer that I am still learning how to write with an object-oriented programming style in C, so there probably are points that I didn't explain well, or may just be off mark in terms of how best to implement OOP in C. But my purpose was to try to illustrate one of many uses of function pointers.

For more information on how to perform object-oriented programming in C, please refer to the following questions:

    Object-Orientation in C?
    Can you write object oriented code in C?

shareimprove this answer
	
edited Oct 14 '14 at 7:19
	
community wiki

2 revs, 2 users 100%
coobird
	
6 	 
	
This answer is horrible! Not only it implies that OO somehow depends on dot notation, it also encourages putting junk into your objects! – Alexei Averchenko Sep 16 '12 at 14:30
12 	 
	
This is OO all right, but not anywhere near the C-style OO. What you have brokenly implemented is Javascript-style prototype-based OO. To get C++/Pascal-style OO, you'd need to: 1. Have a const struct for a virtual table of each class with virtual members. 2. Have pointer to that struct in polymorphic objects. 3. Call virtual methods via the virtual table, and all other methods directly -- usually by sticking to some ClassName_methodName function naming convention. Only then you get the same runtime and storage costs as you do in C++ and Pascal. – Kuba Ober Mar 18 '13 at 21:53
9 	 
	
Working OO with a language that is not intended to be OO is always a bad idea. If you want OO and still have C just work with C++. – rbaleksandar Jul 4 '13 at 15:21
6 	 
	
@rbaleksandar Tell that to the Linux kernel developers. "always a bad idea" is strictly your opinion, with which I firmly disagree. – Jonathon Reinhart Apr 30 '15 at 12:31
   	 
	
@KubaOber which sounds like GObject, right? – underscore_d Apr 20 at 21:17
show 4 more comments
up vote
139
down vote
	

The guide to getting fired: How to abuse function pointers in GCC on x86 machines by compiling your code by hand:

    Returns the current value on the EAX register

    int eax = ((int(*)())("\xc3 <- This returns the value of the EAX register"))();

    Write a swap function

    int a = 10, b = 20;
    ((void(*)(int*,int*))"\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3 <- This swaps the values of a and b")(&a,&b);

    Write a for-loop counter to 1000, calling some function each time

    ((int(*)())"\x66\x31\xc0\x8b\x5c\x24\x04\x66\x40\x50\xff\xd3\x58\x66\x3d\xe8\x03\x75\xf4\xc3")(&function); // calls function with 1->1000

    You can even write a recursive function that counts to 100

    const char* lol = "\x8b\x5c\x24\x4\x3d\xe8\x3\x0\x0\x7e\x2\x31\xc0\x83\xf8\x64\x7d\x6\x40\x53\xff\xd3\x5b\xc3\xc3 <- Recursively calls the function at address lol.";
    i = ((int(*)())(lol))(lol);

shareimprove this answer
	
edited Apr 22 '15 at 11:53
	
community wiki

2 revs, 2 users 98%
Lee Gao
	
6 	 
	
Note: this doesn't work if Data Execution Prevention is enabled (e.g. on Windows XP SP2+), because C strings are not normally marked as executable. – SecurityMatt Feb 12 '13 at 5:53
1 	 
	
will this work on Visual Studio? I get:error C2440: 'type cast' : cannot convert from 'const char [68]' to 'void (__cdecl *)(int *,int *)' . Any ideas? – roboto1986 Jul 3 '13 at 18:42
3 	 
	
Hi Matt! Depending on the optimization level, GCC will often inline string constants into the TEXT segment, so this will work even on newer version of windows provided that you don't disallow this type of optimization. (IIRC, the MINGW version at the time of my post over two years ago inlines string literals at the default optimization level) – Lee Jan 2 '14 at 6:20
3 	 
	
could someone please explain what's happening here? What are those weird looking string literals? – ajay Jan 20 '14 at 10:17
18 	 
	
@ajay It looks like he's writing raw hexidecimal values (for instance '\x00' is the same as '/0', they're both equal to 0) into a string, then casting the string into a C function pointer, then executing the C function pointer because he's the devil. – ejk314 Feb 21 '14 at 21:27
show 9 more comments
up vote
68
down vote
	

One of my favorite uses for function pointers is as cheap and easy iterators -

#include <stdio.h>
#define MAX_COLORS  256

typedef struct {
    char* name;
    int red;
    int green;
    int blue;
} Color;

Color Colors[MAX_COLORS];


void eachColor (void (*fp)(Color *c)) {
    int i;
    for (i=0; i<MAX_COLORS; i++)
        (*fp)(&Colors[i]);
}

void printColor(Color* c) {
    if (c->name)
        printf("%s = %i,%i,%i\n", c->name, c->red, c->green, c->blue);
}

int main() {
    Colors[0].name="red";
    Colors[0].red=255;
    Colors[1].name="blue";
    Colors[1].blue=255;
    Colors[2].name="black";

    eachColor(printColor);
}

shareimprove this answer
	
edited Jul 24 '12 at 16:40
	
community wiki

2 revs, 2 users 99%
Nick
	
7 	 
	
You should also pass a pointer to user-specified data if you want to somehow extract any output from iterations (think closures). – Alexei Averchenko Sep 16 '12 at 14:32
   	 
	
Agreed. All of my iterators look like this: int (*cb)(void *arg, ...). The return value of the iterator also lets me stop early (if nonzero). – Jonathon Reinhart Apr 30 '15 at 12:35
add a comment
up vote
19
down vote
	

Function pointers become easy to declare once you have the basic declarators:

    id: ID: ID is a
    Pointer: *D: D pointer to
    Function: D(<parameters>): D function taking <parameters> returning

While D is another declarator built using those same rules. In the end, somewhere, it ends with ID (see below for an example), which is the name of the declared entity. Let's try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int. With type-defs it's like this

typedef int ReturnFunction(char);
typedef int ParameterFunction(void);
ReturnFunction *f(ParameterFunction *p);

As you see, it's pretty easy to build it up using typedefs. Without typedefs, it's not hard either with the above declarator rules, applied consistently. As you see i missed out the part the pointer points to, and the thing the function returns. That's what appears at the very left of the declaration, and is not of interest: It's added at the end if one built up the declarator already. Let's do that. Building it up consistently, first wordy - showing the structure using [ and ]:

function taking 
    [pointer to [function taking [void] returning [int]]] 
returning
    [pointer to [function taking [char] returning [int]]]

As you see, one can describe a type completely by appending declarators one after each other. Construction can be done in two ways. One is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier. The other way is top-down, starting at the identifier, working the way down to the leaves. I'll show both ways.
Bottom Up

Construction starts with the thing at the right: The thing returned, which is the function taking char. To keep the declarators distinct, i'm going to number them:

D1(char);

Inserted the char parameter directly, since it's trivial. Adding a pointer to declarator by replacing D1 by *D2. Note that we have to wrap parentheses around *D2. That can be known by looking up the precedence of the *-operator and the function-call operator (). Without our parentheses, the compiler would read it as *(D2(char p)). But that would not be a plain replace of D1 by *D2 anymore, of course. Parentheses are always allowed around declarators. So you don't make anything wrong if you add too much of them, actually.

(*D2)(char);

Return type is complete! Now, let's replace D2 by the function declarator function taking <parameters> returning, which is D3(<parameters>) which we are at now.

(*D3(<parameters>))(char)

Note that no parentheses are needed, since we want D3 to be a function-declarator and not a pointer declarator this time. Great, only thing left is the parameters for it. The parameter is done exactly the same as we've done the return type, just with char replaced by void. So i'll copy it:

(*D3(   (*ID1)(void)))(char)

I've replaced D2 by ID1, since we are finished with that parameter (it's already a pointer to a function - no need for another declarator). ID1 will be the name of the parameter. Now, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration. For functions, that becomes the return type. For pointers the pointed to type etc... It's interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration. Both times int of course.

int (*ID0(int (*ID1)(void)))(char)

I've called the identifier of the function ID0 in that example.
Top Down

This starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right. Start with function taking <parameters> returning

ID0(<parameters>)

The next thing in the description (after "returning") was pointer to. Let's incorporate it:

*ID0(<parameters>)

Then the next thing was functon taking <parameters> returning. The parameter is a simple char, so we put it in right away again, since it's really trivial.

(*ID0(<parameters>))(char)

Note the parentheses we added, since we again want that the * binds first, and then the (char). Otherwise it would read function taking <parameters> returning function .... Noes, functions returning functions aren't even allowed.

Now we just need to put <parameters>. I will show a short version of the deriveration, since i think you already by now have the idea how to do it.

pointer to: *ID1
... function taking void returning: (*ID1)(void)

Just put int before the declarators like we did with bottom-up, and we are finished

int (*ID0(int (*ID1)(void)))(char)

The nice thing

Is bottom-up or top-down better? I'm used to bottom-up, but some people may be more comfortable with top-down. It's a matter of taste i think. Incidentally, if you apply all the operators in that declaration, you will end up getting an int:

int v = (*ID0(some_function_pointer))(some_char);

That is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left. It's like that for arrays too.

Hope you liked this little tutorial! Now we can link to this when people wonder about the strange declaration syntax of functions. I tried to put as little C internals as possible. Feel free to edit/fix things in it.
shareimprove this answer
	
edited May 9 '09 at 13:38
	
community wiki

3 revs
Johannes Schaub - litb
	
add a comment
up vote
16
down vote
	
Another good use for function pointers:
Switching between versions painlessly

They're very handy to use for when you want different functions at different times, or different phases of development. For instance, I'm developing an application on a host computer that has a console, but the final release of the software will be put on an Avnet ZedBoard (which has ports for displays and consoles, but they are not needed/wanted for the final release). So during development, I will use printf to view status and error messages, but when I'm done, I don't want anything printed. Here's what I've done:
version.h

// First, undefine all macros associated with version.h
#undef DEBUG_VERSION
#undef RELEASE_VERSION
#undef INVALID_VERSION


// Define which version we want to use
#define DEBUG_VERSION       // The current version
// #define RELEASE_VERSION  // To be uncommented when finished debugging

#ifndef __VERSION_H_      /* prevent circular inclusions */
    #define __VERSION_H_  /* by using protection macros */
    void board_init();
    void noprintf(const char *c, ...); // mimic the printf prototype
#endif

// Mimics the printf function prototype. This is what I'll actually 
// use to print stuff to the screen
void (* zprintf)(const char*, ...); 

// If debug version, use printf
#ifdef DEBUG_VERSION
    #include <stdio.h>
#endif

// If both debug and release version, error
#ifdef DEBUG_VERSION
#ifdef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

// If neither debug or release version, error
#ifndef DEBUG_VERSION
#ifndef RELEASE_VERSION
    #define INVALID_VERSION
#endif
#endif

#ifdef INVALID_VERSION
    // Won't allow compilation without a valid version define
    #error "Invalid version definition"
#endif

In version.c I will define the 2 function prototypes present in version.h
version.c

#include "version.h"

/*****************************************************************************/
/**
* @name board_init
*
* Sets up the application based on the version type defined in version.h.
* Includes allowing or prohibiting printing to STDOUT.
*
* MUST BE CALLED FIRST THING IN MAIN
*
* @return    None
*
*****************************************************************************/
void board_init()
{
    // Assign the print function to the correct function pointer
    #ifdef DEBUG_VERSION
        zprintf = &printf;
    #else
        // Defined below this function
        zprintf = &noprintf;
    #endif
}

/*****************************************************************************/
/**
* @name noprintf
*
* simply returns with no actions performed
*
* @return   None
*
*****************************************************************************/
void noprintf(const char* c, ...)
{
    return;
}

Notice how the function pointer is prototyped in version.h as

void (* zprintf)(const char *, ...);

When it is referenced in the application, it will start executing wherever it is pointing, which has yet to be defined.

In version.c, notice in the board_init()function where zprintf is assigned a unique function (whose function signature matches) depending on the version that is defined in version.h

zprintf = &printf; zprintf calls printf for debugging purposes

or

zprintf = &noprint; zprintf just returns and will not run unnecessary code

Running the code will look like this:
mainProg.c

#include "version.h"
#include <stdlib.h>
int main()
{
    // Must run board_init(), which assigns the function
    // pointer to an actual function
    board_init();

    void *ptr = malloc(100); // Allocate 100 bytes of memory
    // malloc returns NULL if unable to allocate the memory.

    if (ptr == NULL)
    {
        zprintf("Unable to allocate memory\n");
        return 1;
    }

    // Other things to do...
    return 0;
}

The above code will use printf if in debug mode, or do nothing if in release mode. This is much easier than going through the entire project and commenting out or deleting code. All that I need to do is change the version in version.h and the code will do the rest!
shareimprove this answer
	
edited Jun 11 '13 at 15:36
	
community wiki

2 revs
Zack Sheffield
	
add a comment
up vote
9
down vote
	

Function pointer is usually defined by typedef, and used as param & return value,

Above answers already explained a lot, I just give a full example:

#include <stdio.h>

#define NUM_A 1
#define NUM_B 2

// define a function pointer type
typedef int (*two_num_operation)(int, int);

// an actual standalone function
static int sum(int a, int b) {
    return a + b;
}

// use function pointer as param,
static int sum_via_pointer(int a, int b, two_num_operation funp) {
    return (*funp)(a, b);
}

// use function pointer as return value,
static two_num_operation get_sum_fun() {
    return &sum;
}

// test - use function pointer as variable,
void test_pointer_as_variable() {
    // create a pointer to function,
    two_num_operation sum_p = &sum;
    // call function via pointer
    printf("pointer as variable:\t %d + %d = %d\n", NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));
}

// test - use function pointer as param,
void test_pointer_as_param() {
    printf("pointer as param:\t %d + %d = %d\n", NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &sum));
}

// test - use function pointer as return value,
void test_pointer_as_return_value() {
    printf("pointer as return value:\t %d + %d = %d\n", NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));
}

int main() {
    test_pointer_as_variable();
    test_pointer_as_param();
    test_pointer_as_return_value();

    return 0;
}

shareimprove this answer
	
answered Nov 10 '14 at 8:50
	
community wiki

Eric Wang
	
add a comment
up vote
2
down vote
	

One of the big uses for function pointers in C is to call a function selected at run-time. For example, the C run-time library has two routines, qsort and bsearch, which take a pointer to a function that is called to compare two items being sorted; this allows you to sort or search, respectively, anything, based on any criteria you wish to use.

A very basic example, if there is one function called print(int x, int y) which in turn may require to call add() function or sub() which are of similar types then what we will do, we will add one function pointer argument to the print() function as shown below:-

int add()
{
   return (100+10);
}

int sub()
{
   return (100-10);
}

void print(int x, int y, int (*func)())
{
    printf("value is : %d", (x+y+(*func)()));
}

int main()
{
    int x=100, y=200;
    print(x,y,add);
    print(x,y,sub);

    return 0;
}

shareimprove this answer
	
edited Jan 3 '15 at 17:52
	
community wiki

2 revs, 2 users 96%
Vamsi
	
add a comment
up vote
1
down vote
	

Starting from scratch function has Some Memory Address From Where They start executing. In Assembly Language They Are called as (call "function's memory address").Now come back to C If function has a memory address then they can be manipulated by Pointers in C.So By the rules of C

1.First you need to declare a pointer to function 2.Pass the Address of the Desired function

****Note->the functions should be of same type****

This Simple Programme will Illustrate Every Thing.

#include<stdio.h>
void (*print)() ;//Declare a  Function Pointers
void sayhello();//Declare The Function Whose Address is to be passed
                //The Functions should Be of Same Type
int main()
{

 print=sayhello;//Addressof sayhello is assigned to print
 print();//print Does A call To The Function 
 return 0;
}

void sayhello()
{
 printf("\n Hello World");
}

enter image description hereAfter That lets See How machine Understands Them.Glimpse of machine instruction of the above programme in 32 bit architecture.

The red mark area is showing how the address is being exchanged and storing in eax.Then their is a call instruction on eax. eax contains the desired address of the function
shareimprove this answer
	
answered Sep 26 '14 at 8:09
	
community wiki

Mohit Dabas
	
add a comment
up vote
0
down vote
	

Since function pointers are often typed callbacks, you might want to have a look at type safe callbacks. The same applies to entry points, etc of functions that are not callbacks.

C is quite fickle and forgiving at the same time :)
shareimprove this answer
	
answered May 9 '09 at 13:56
	
community wiki

Tim Post
	
add a comment
up vote
-3
down vote
	

function pointers are useful in many situations, eg:

    COM objects members are pointer to function ag: This->lpVtbl->AddRef(This); AddRef is a pointer to a function.
    function callback, for example a user defined function to compares two variables to be passed as a callback to a special sort function.
    very useful for plugin implementation and application SDK.

shareimprove this answer
	
answered Jan 2 at 13:15
	
community wiki

milevyo
	
add a comment
protected by Sourav Ghosh May 16 '15 at 11:45

Thank you for your interest in this question. Because it has attracted low-quality or spam answers that had to be removed, posting an answer now requires 10 reputation on this site (the association bonus does not count).

Would you like to answer one of these unanswered questions instead?
Not the answer you're looking for? Browse other questions tagged c function-pointers or ask your own question.

asked
	

7 years ago

viewed
	

479255 times

active
	

12 months ago
Want a python job?

    Senior Python Developer
    HackerEarthBengaluru, India
    ₹1,500,000 - ₹2,500,000Relocation
    pythondjango
    Data Scientist
    MakemytripBengaluru, India
    Relocation
    machine-learningpython
    DevOps Engineer
    RedMartBengaluru, India
    pythonr
    Senior Systems Engineer
    DataXuBengaluru, India
    pythonjavascript

Linked
0
What does void *(*routine)(void *) mean in C?
3
Passing function pointers as arguments
0
Function Pointers Error In C
2
C pass pointer as argument in function
2
For function pointer “fptr”,why is value of “fptr” and *fptr same?What *fptr even mean?I only knew (*fptr)() or fptr()
2
How does function pointer in C actually work?
0
Passing a parameter in a callback in C
1
Can't understand code/function call
1
Please explain the following piece of code. I'm a beginner so please help me understand
0
What does an asterisk in empty parentheses mean?
see more linked questions…
Related
154
Why do function pointer definitions work with any number of ampersands '&' or asterisks '*'?
141
How does the C code that prints from 1 to 1000 without loops or conditional statements work?
7
How to use a function pointer in a C struct?
6
Pointers to any function?
7
function pointer to different functions with different arguments in C
2
Function pointer syntax in C
25
Returning function pointer type
0
Restart a computer using function pointers in C
2
How can a function pointer replace switch statement?
4
pattern for handling function pointer of functions of inhomogene signature in C
Hot Network Questions

    A bit, a nibble or byte?
    Could this kind of authentification be attacked?
    Animate tacky Christmas light decorations
    How is Sovereign Glue affected by Dispel Magic or an Antimagic Field?
    Help with a prime number spiral which turns 90 degrees at each prime
    Why does Hermione dislike Professor Trelawney from the start?
    How is the date of entry and exit of Schengen decided?
    What does this joke mean?
    Is the computer cheating at Dice Poker?
    Total count of Theorem like environments - In all chapters
    What is an asymmetric wheel and why would you use it?
    What's the first noticeable instance of Hermione showing the negative effects due to her timeturner use in the third year?
    When are there infinitely many primes in a sequence generated by a simple recurrence relation?
    I made it up with no more than one. But one what?
    A question about oversets in an equation
    NIntegrate into NDSolve with variable integrand
    How to understand 'quae prosum sola nocendo'?
    How did a Jedi die during the Battle of Geonosis?
    How can I easily double any size number in my head?
    Appropriate age for Rubik's cube
    changing user home directory has no effect
    What is the difference between motivation and inspiration?
    How do I prevent flight in a cyberpunk future?
    A program that guesses your number using bitwise operations C++

question feed
about us tour help blog chat data legal privacy policy work here advertising info mobile contact us feedback
Technology 	Life / Arts 	Culture / Recreation 	Science 	Other

    Stack Overflow
    Server Fault
    Super User
    Web Applications
    Ask Ubuntu
    Webmasters
    Game Development
    TeX - LaTeX

	

    Software Engineering
    Unix & Linux
    Ask Different (Apple)
    WordPress Development
    Geographic Information Systems
    Electrical Engineering
    Android Enthusiasts
    Information Security

	

    Database Administrators
    Drupal Answers
    SharePoint
    User Experience
    Mathematica
    Salesforce
    ExpressionEngine® Answers
    Cryptography

	

    Code Review
    Magento
    Signal Processing
    Raspberry Pi
    Programming Puzzles & Code Golf
    more (7)

	

    Photography
    Science Fiction & Fantasy
    Graphic Design
    Movies & TV
    Music: Practice & Theory
    Seasoned Advice (cooking)
    Home Improvement
    Personal Finance & Money

	

    Academia
    more (8)

	

    English Language & Usage
    Skeptics
    Mi Yodeya (Judaism)
    Travel
    Christianity
    English Language Learners
    Japanese Language
    Arqade (gaming)

	

    Bicycles
    Role-playing Games
    Anime & Manga
    Motor Vehicle Maintenance & Repair
    more (17)

	

    MathOverflow
    Mathematics
    Cross Validated (stats)
    Theoretical Computer Science
    Physics
    Chemistry
    Biology
    Computer Science

	

    Philosophy
    more (3)

	

    Meta Stack Exchange
    Stack Apps
    Area 51
    Stack Overflow Talent

site design / logo © 2016 Stack Exchange Inc; user contributions licensed under cc by-sa 3.0 with attribution required
rev 2016.12.24.1

