                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.9.0 #11195 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _HELPER_strncmp_PARM_3
                                     12 	.globl _HELPER_strncmp_PARM_2
                                     13 	.globl _HELPER_strcmp_PARM_2
                                     14 	.globl _spi_transfer_PARM_2
                                     15 	.globl _SERIAL_LOADER_VERSION_INFO
                                     16 	.globl _main
                                     17 	.globl _SelectFileAndFileOpen
                                     18 	.globl _SelectFAT16PartitionPrompt
                                     19 	.globl _SL_getcmd
                                     20 	.globl _SL_read
                                     21 	.globl _SL_write
                                     22 	.globl _SL_enable_write_protection
                                     23 	.globl _SL_disable_write_protection
                                     24 	.globl _FAT16_FILE_CAT
                                     25 	.globl _FAT16_FILE_READ
                                     26 	.globl _FAT16_GET_NEXT_CLUSTER
                                     27 	.globl _FAT16_FILE_OPEN
                                     28 	.globl _FAT16_ROOTENTRY_SCAN
                                     29 	.globl _FAT16_ROOTENTRY_SCAN_RESET
                                     30 	.globl _FAT16_ROOTENTRY_READ
                                     31 	.globl _FAT16_IS_ROOTENTRY_VALID_FILE
                                     32 	.globl _FAT16_LOAD_ROOTENTRY
                                     33 	.globl _FAT16_ROOTENTRY_DUMP
                                     34 	.globl _VBR_FAT16_CHECK_COMPATIBILITY
                                     35 	.globl _VBR_MOUNT_VBR
                                     36 	.globl _MBR_DETECT_FAT16
                                     37 	.globl _MBR_LOAD_PARTITION_TABLE_ENTRY
                                     38 	.globl _MBR_CHECK__SIGNATURE
                                     39 	.globl _HELPER_filename_to_8dot3filename
                                     40 	.globl _HELPER_to_uppercase
                                     41 	.globl _HELPER_rootentry_type
                                     42 	.globl _HELPER_strlen
                                     43 	.globl _HELPER_strncmp
                                     44 	.globl _HELPER_strcmp
                                     45 	.globl _HELPER_load_littleendian32
                                     46 	.globl _HELPER_load_littleendian16
                                     47 	.globl _SDreadBlock
                                     48 	.globl _SDread
                                     49 	.globl _SDinit
                                     50 	.globl _sd_acmd
                                     51 	.globl _sd_cmd
                                     52 	.globl _sd_initial_clk
                                     53 	.globl _sd_isbusy
                                     54 	.globl _spi_transfer_all
                                     55 	.globl _spi_transfer
                                     56 	.globl _spi_init
                                     57 	.globl _UartScanLine
                                     58 	.globl _UartScanByte
                                     59 	.globl _UartPrintNumber
                                     60 	.globl _UartWriteNumbers
                                     61 	.globl _UartWriteNumber
                                     62 	.globl _UartPrint
                                     63 	.globl _UartReadBuff
                                     64 	.globl _UartWriteBuff
                                     65 	.globl _UartWrite
                                     66 	.globl _UartRead
                                     67 	.globl _UartReadReady
                                     68 	.globl _UartBegin
                                     69 	.globl _dec2hexNibble
                                     70 	.globl _hex2dec
                                     71 	.globl _hexNibble2dec
                                     72 	.globl _TF2
                                     73 	.globl _EXF2
                                     74 	.globl _RCLK
                                     75 	.globl _TCLK
                                     76 	.globl _EXEN2
                                     77 	.globl _TR2
                                     78 	.globl _C_T2
                                     79 	.globl _CP_RL2
                                     80 	.globl _T2CON_7
                                     81 	.globl _T2CON_6
                                     82 	.globl _T2CON_5
                                     83 	.globl _T2CON_4
                                     84 	.globl _T2CON_3
                                     85 	.globl _T2CON_2
                                     86 	.globl _T2CON_1
                                     87 	.globl _T2CON_0
                                     88 	.globl _PT2
                                     89 	.globl _ET2
                                     90 	.globl _CY
                                     91 	.globl _AC
                                     92 	.globl _F0
                                     93 	.globl _RS1
                                     94 	.globl _RS0
                                     95 	.globl _OV
                                     96 	.globl _F1
                                     97 	.globl _P
                                     98 	.globl _PS
                                     99 	.globl _PT1
                                    100 	.globl _PX1
                                    101 	.globl _PT0
                                    102 	.globl _PX0
                                    103 	.globl _RD
                                    104 	.globl _WR
                                    105 	.globl _T1
                                    106 	.globl _T0
                                    107 	.globl _INT1
                                    108 	.globl _INT0
                                    109 	.globl _TXD
                                    110 	.globl _RXD
                                    111 	.globl _P3_7
                                    112 	.globl _P3_6
                                    113 	.globl _P3_5
                                    114 	.globl _P3_4
                                    115 	.globl _P3_3
                                    116 	.globl _P3_2
                                    117 	.globl _P3_1
                                    118 	.globl _P3_0
                                    119 	.globl _EA
                                    120 	.globl _ES
                                    121 	.globl _ET1
                                    122 	.globl _EX1
                                    123 	.globl _ET0
                                    124 	.globl _EX0
                                    125 	.globl _P2_7
                                    126 	.globl _P2_6
                                    127 	.globl _P2_5
                                    128 	.globl _P2_4
                                    129 	.globl _P2_3
                                    130 	.globl _P2_2
                                    131 	.globl _P2_1
                                    132 	.globl _P2_0
                                    133 	.globl _SM0
                                    134 	.globl _SM1
                                    135 	.globl _SM2
                                    136 	.globl _REN
                                    137 	.globl _TB8
                                    138 	.globl _RB8
                                    139 	.globl _TI
                                    140 	.globl _RI
                                    141 	.globl _P1_7
                                    142 	.globl _P1_6
                                    143 	.globl _P1_5
                                    144 	.globl _P1_4
                                    145 	.globl _P1_3
                                    146 	.globl _P1_2
                                    147 	.globl _P1_1
                                    148 	.globl _P1_0
                                    149 	.globl _TF1
                                    150 	.globl _TR1
                                    151 	.globl _TF0
                                    152 	.globl _TR0
                                    153 	.globl _IE1
                                    154 	.globl _IT1
                                    155 	.globl _IE0
                                    156 	.globl _IT0
                                    157 	.globl _P0_7
                                    158 	.globl _P0_6
                                    159 	.globl _P0_5
                                    160 	.globl _P0_4
                                    161 	.globl _P0_3
                                    162 	.globl _P0_2
                                    163 	.globl _P0_1
                                    164 	.globl _P0_0
                                    165 	.globl _TH2
                                    166 	.globl _TL2
                                    167 	.globl _RCAP2H
                                    168 	.globl _RCAP2L
                                    169 	.globl _T2CON
                                    170 	.globl _B
                                    171 	.globl _ACC
                                    172 	.globl _PSW
                                    173 	.globl _IP
                                    174 	.globl _P3
                                    175 	.globl _IE
                                    176 	.globl _P2
                                    177 	.globl _SBUF
                                    178 	.globl _SCON
                                    179 	.globl _P1
                                    180 	.globl _TH1
                                    181 	.globl _TH0
                                    182 	.globl _TL1
                                    183 	.globl _TL0
                                    184 	.globl _TMOD
                                    185 	.globl _TCON
                                    186 	.globl _PCON
                                    187 	.globl _DPH
                                    188 	.globl _DPL
                                    189 	.globl _SP
                                    190 	.globl _P0
                                    191 	.globl _EEPROM_WRITE_PROTECTION
                                    192 	.globl _HELPER_filename_to_8dot3filename_PARM_2
                                    193 	.globl _SDreadBlock_PARM_2
                                    194 	.globl _sd_acmd_PARM_2
                                    195 	.globl _sd_cmd_PARM_2
                                    196 	.globl _spi_transfer_all_PARM_3
                                    197 	.globl _spi_transfer_all_PARM_2
                                    198 	.globl _UartReadBuff_PARM_2
                                    199 	.globl _UartWriteBuff_PARM_2
                                    200 	.globl _hex2dec_PARM_2
                                    201 ;--------------------------------------------------------
                                    202 ; special function registers
                                    203 ;--------------------------------------------------------
                                    204 	.area RSEG    (ABS,DATA)
      000000                        205 	.org 0x0000
                           000080   206 _P0	=	0x0080
                           000081   207 _SP	=	0x0081
                           000082   208 _DPL	=	0x0082
                           000083   209 _DPH	=	0x0083
                           000087   210 _PCON	=	0x0087
                           000088   211 _TCON	=	0x0088
                           000089   212 _TMOD	=	0x0089
                           00008A   213 _TL0	=	0x008a
                           00008B   214 _TL1	=	0x008b
                           00008C   215 _TH0	=	0x008c
                           00008D   216 _TH1	=	0x008d
                           000090   217 _P1	=	0x0090
                           000098   218 _SCON	=	0x0098
                           000099   219 _SBUF	=	0x0099
                           0000A0   220 _P2	=	0x00a0
                           0000A8   221 _IE	=	0x00a8
                           0000B0   222 _P3	=	0x00b0
                           0000B8   223 _IP	=	0x00b8
                           0000D0   224 _PSW	=	0x00d0
                           0000E0   225 _ACC	=	0x00e0
                           0000F0   226 _B	=	0x00f0
                           0000C8   227 _T2CON	=	0x00c8
                           0000CA   228 _RCAP2L	=	0x00ca
                           0000CB   229 _RCAP2H	=	0x00cb
                           0000CC   230 _TL2	=	0x00cc
                           0000CD   231 _TH2	=	0x00cd
                                    232 ;--------------------------------------------------------
                                    233 ; special function bits
                                    234 ;--------------------------------------------------------
                                    235 	.area RSEG    (ABS,DATA)
      000000                        236 	.org 0x0000
                           000080   237 _P0_0	=	0x0080
                           000081   238 _P0_1	=	0x0081
                           000082   239 _P0_2	=	0x0082
                           000083   240 _P0_3	=	0x0083
                           000084   241 _P0_4	=	0x0084
                           000085   242 _P0_5	=	0x0085
                           000086   243 _P0_6	=	0x0086
                           000087   244 _P0_7	=	0x0087
                           000088   245 _IT0	=	0x0088
                           000089   246 _IE0	=	0x0089
                           00008A   247 _IT1	=	0x008a
                           00008B   248 _IE1	=	0x008b
                           00008C   249 _TR0	=	0x008c
                           00008D   250 _TF0	=	0x008d
                           00008E   251 _TR1	=	0x008e
                           00008F   252 _TF1	=	0x008f
                           000090   253 _P1_0	=	0x0090
                           000091   254 _P1_1	=	0x0091
                           000092   255 _P1_2	=	0x0092
                           000093   256 _P1_3	=	0x0093
                           000094   257 _P1_4	=	0x0094
                           000095   258 _P1_5	=	0x0095
                           000096   259 _P1_6	=	0x0096
                           000097   260 _P1_7	=	0x0097
                           000098   261 _RI	=	0x0098
                           000099   262 _TI	=	0x0099
                           00009A   263 _RB8	=	0x009a
                           00009B   264 _TB8	=	0x009b
                           00009C   265 _REN	=	0x009c
                           00009D   266 _SM2	=	0x009d
                           00009E   267 _SM1	=	0x009e
                           00009F   268 _SM0	=	0x009f
                           0000A0   269 _P2_0	=	0x00a0
                           0000A1   270 _P2_1	=	0x00a1
                           0000A2   271 _P2_2	=	0x00a2
                           0000A3   272 _P2_3	=	0x00a3
                           0000A4   273 _P2_4	=	0x00a4
                           0000A5   274 _P2_5	=	0x00a5
                           0000A6   275 _P2_6	=	0x00a6
                           0000A7   276 _P2_7	=	0x00a7
                           0000A8   277 _EX0	=	0x00a8
                           0000A9   278 _ET0	=	0x00a9
                           0000AA   279 _EX1	=	0x00aa
                           0000AB   280 _ET1	=	0x00ab
                           0000AC   281 _ES	=	0x00ac
                           0000AF   282 _EA	=	0x00af
                           0000B0   283 _P3_0	=	0x00b0
                           0000B1   284 _P3_1	=	0x00b1
                           0000B2   285 _P3_2	=	0x00b2
                           0000B3   286 _P3_3	=	0x00b3
                           0000B4   287 _P3_4	=	0x00b4
                           0000B5   288 _P3_5	=	0x00b5
                           0000B6   289 _P3_6	=	0x00b6
                           0000B7   290 _P3_7	=	0x00b7
                           0000B0   291 _RXD	=	0x00b0
                           0000B1   292 _TXD	=	0x00b1
                           0000B2   293 _INT0	=	0x00b2
                           0000B3   294 _INT1	=	0x00b3
                           0000B4   295 _T0	=	0x00b4
                           0000B5   296 _T1	=	0x00b5
                           0000B6   297 _WR	=	0x00b6
                           0000B7   298 _RD	=	0x00b7
                           0000B8   299 _PX0	=	0x00b8
                           0000B9   300 _PT0	=	0x00b9
                           0000BA   301 _PX1	=	0x00ba
                           0000BB   302 _PT1	=	0x00bb
                           0000BC   303 _PS	=	0x00bc
                           0000D0   304 _P	=	0x00d0
                           0000D1   305 _F1	=	0x00d1
                           0000D2   306 _OV	=	0x00d2
                           0000D3   307 _RS0	=	0x00d3
                           0000D4   308 _RS1	=	0x00d4
                           0000D5   309 _F0	=	0x00d5
                           0000D6   310 _AC	=	0x00d6
                           0000D7   311 _CY	=	0x00d7
                           0000AD   312 _ET2	=	0x00ad
                           0000BD   313 _PT2	=	0x00bd
                           0000C8   314 _T2CON_0	=	0x00c8
                           0000C9   315 _T2CON_1	=	0x00c9
                           0000CA   316 _T2CON_2	=	0x00ca
                           0000CB   317 _T2CON_3	=	0x00cb
                           0000CC   318 _T2CON_4	=	0x00cc
                           0000CD   319 _T2CON_5	=	0x00cd
                           0000CE   320 _T2CON_6	=	0x00ce
                           0000CF   321 _T2CON_7	=	0x00cf
                           0000C8   322 _CP_RL2	=	0x00c8
                           0000C9   323 _C_T2	=	0x00c9
                           0000CA   324 _TR2	=	0x00ca
                           0000CB   325 _EXEN2	=	0x00cb
                           0000CC   326 _TCLK	=	0x00cc
                           0000CD   327 _RCLK	=	0x00cd
                           0000CE   328 _EXF2	=	0x00ce
                           0000CF   329 _TF2	=	0x00cf
                                    330 ;--------------------------------------------------------
                                    331 ; overlayable register banks
                                    332 ;--------------------------------------------------------
                                    333 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        334 	.ds 8
                                    335 ;--------------------------------------------------------
                                    336 ; internal ram data
                                    337 ;--------------------------------------------------------
                                    338 	.area DSEG    (DATA)
      000000                        339 _hex2dec_PARM_2:
      000000                        340 	.ds 1
      000001                        341 _UartWriteBuff_PARM_2:
      000001                        342 	.ds 1
      000002                        343 _UartReadBuff_PARM_2:
      000002                        344 	.ds 1
      000003                        345 _spi_transfer_all_PARM_2:
      000003                        346 	.ds 1
      000004                        347 _spi_transfer_all_PARM_3:
      000004                        348 	.ds 1
      000005                        349 _sd_cmd_PARM_2:
      000005                        350 	.ds 4
      000009                        351 _sd_acmd_PARM_2:
      000009                        352 	.ds 4
      00000D                        353 _SDreadBlock_PARM_2:
      00000D                        354 	.ds 3
      000010                        355 _HELPER_filename_to_8dot3filename_PARM_2:
      000010                        356 	.ds 3
      000013                        357 _HELPER_filename_to_8dot3filename_fname_65536_120:
      000013                        358 	.ds 3
      000016                        359 _HELPER_filename_to_8dot3filename_i_131072_126:
      000016                        360 	.ds 1
      000017                        361 _VBR_MOUNT_VBR_sloc0_1_0:
      000017                        362 	.ds 4
      00001B                        363 _FAT16_LOAD_ROOTENTRY_roote_number_65536_149:
      00001B                        364 	.ds 2
      00001D                        365 _FAT16_LOAD_ROOTENTRY_sloc0_1_0:
      00001D                        366 	.ds 4
      000021                        367 _FAT16_LOAD_ROOTENTRY_sloc1_1_0:
      000021                        368 	.ds 2
      000023                        369 _EEPROM_WRITE_PROTECTION::
      000023                        370 	.ds 1
      000024                        371 _main_buff_65536_214:
      000024                        372 	.ds 16
                                    373 ;--------------------------------------------------------
                                    374 ; overlayable items in internal ram 
                                    375 ;--------------------------------------------------------
                                    376 	.area	OSEG    (OVR,DATA)
                                    377 	.area	OSEG    (OVR,DATA)
                                    378 	.area	OSEG    (OVR,DATA)
                                    379 	.area	OSEG    (OVR,DATA)
                                    380 	.area	OSEG    (OVR,DATA)
      000000                        381 _spi_transfer_PARM_2:
      000000                        382 	.ds 1
                                    383 	.area	OSEG    (OVR,DATA)
      000000                        384 _HELPER_strcmp_PARM_2:
      000000                        385 	.ds 3
                                    386 	.area	OSEG    (OVR,DATA)
      000000                        387 _HELPER_strncmp_PARM_2:
      000000                        388 	.ds 3
      000003                        389 _HELPER_strncmp_PARM_3:
      000003                        390 	.ds 1
                                    391 	.area	OSEG    (OVR,DATA)
                                    392 	.area	OSEG    (OVR,DATA)
                                    393 	.area	OSEG    (OVR,DATA)
                                    394 ;--------------------------------------------------------
                                    395 ; Stack segment in internal ram 
                                    396 ;--------------------------------------------------------
                                    397 	.area	SSEG
      000000                        398 __start__stack:
      000000                        399 	.ds	1
                                    400 
                                    401 ;--------------------------------------------------------
                                    402 ; indirectly addressable internal ram data
                                    403 ;--------------------------------------------------------
                                    404 	.area ISEG    (DATA)
      000000                        405 ___global_partitionTableEntry:
      000000                        406 	.ds 9
      000009                        407 ___global_vbr:
      000009                        408 	.ds 31
      000028                        409 ___global_nthPartitionVBRmounted:
      000028                        410 	.ds 1
      000029                        411 ___global_rootEntry:
      000029                        412 	.ds 24
      000041                        413 _MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_132:
      000041                        414 	.ds 16
      000051                        415 _VBR_MOUNT_VBR_temp_65536_138:
      000051                        416 	.ds 16
      000061                        417 _FAT16_LOAD_ROOTENTRY_temp_65536_150:
      000061                        418 	.ds 32
                                    419 ;--------------------------------------------------------
                                    420 ; absolute internal ram data
                                    421 ;--------------------------------------------------------
                                    422 	.area IABS    (ABS,DATA)
                                    423 	.area IABS    (ABS,DATA)
                                    424 ;--------------------------------------------------------
                                    425 ; bit data
                                    426 ;--------------------------------------------------------
                                    427 	.area BSEG    (BIT)
                                    428 ;--------------------------------------------------------
                                    429 ; paged external ram data
                                    430 ;--------------------------------------------------------
                                    431 	.area PSEG    (PAG,XDATA)
                                    432 ;--------------------------------------------------------
                                    433 ; external ram data
                                    434 ;--------------------------------------------------------
                                    435 	.area XSEG    (XDATA)
                                    436 ;--------------------------------------------------------
                                    437 ; absolute external ram data
                                    438 ;--------------------------------------------------------
                                    439 	.area XABS    (ABS,XDATA)
                                    440 ;--------------------------------------------------------
                                    441 ; external initialized ram data
                                    442 ;--------------------------------------------------------
                                    443 	.area XISEG   (XDATA)
                                    444 	.area HOME    (CODE)
                                    445 	.area GSINIT0 (CODE)
                                    446 	.area GSINIT1 (CODE)
                                    447 	.area GSINIT2 (CODE)
                                    448 	.area GSINIT3 (CODE)
                                    449 	.area GSINIT4 (CODE)
                                    450 	.area GSINIT5 (CODE)
                                    451 	.area GSINIT  (CODE)
                                    452 	.area GSFINAL (CODE)
                                    453 	.area CSEG    (CODE)
                                    454 ;--------------------------------------------------------
                                    455 ; interrupt vector 
                                    456 ;--------------------------------------------------------
                                    457 	.area HOME    (CODE)
      000000                        458 __interrupt_vect:
      000000 02r00r00         [24]  459 	ljmp	__sdcc_gsinit_startup
                                    460 ;--------------------------------------------------------
                                    461 ; global & static initialisations
                                    462 ;--------------------------------------------------------
                                    463 	.area HOME    (CODE)
                                    464 	.area GSINIT  (CODE)
                                    465 	.area GSFINAL (CODE)
                                    466 	.area GSINIT  (CODE)
                                    467 	.globl __sdcc_gsinit_startup
                                    468 	.globl __sdcc_program_startup
                                    469 	.globl __start__stack
                                    470 	.globl __mcs51_genXINIT
                                    471 	.globl __mcs51_genXRAMCLEAR
                                    472 	.globl __mcs51_genRAMCLEAR
                                    473 ;	serialloader.h:20: volatile unsigned char EEPROM_WRITE_PROTECTION=1;
      000000 75*23 01         [24]  474 	mov	_EEPROM_WRITE_PROTECTION,#0x01
                                    475 ;	fat.h:238: __idata static uint8_t __global_nthPartitionVBRmounted=255; //mounted if value is 0-3 for the 4 partitions,else not mounted
      000003 78r28            [12]  476 	mov	r0,#___global_nthPartitionVBRmounted
      000005 76 FF            [12]  477 	mov	@r0,#0xff
                                    478 	.area GSFINAL (CODE)
      000000 02r00r03         [24]  479 	ljmp	__sdcc_program_startup
                                    480 ;--------------------------------------------------------
                                    481 ; Home
                                    482 ;--------------------------------------------------------
                                    483 	.area HOME    (CODE)
                                    484 	.area HOME    (CODE)
      000003                        485 __sdcc_program_startup:
      000003 02r18rF6         [24]  486 	ljmp	_main
                                    487 ;	return from main will return to caller
                                    488 ;--------------------------------------------------------
                                    489 ; code
                                    490 ;--------------------------------------------------------
                                    491 	.area CSEG    (CODE)
                                    492 ;------------------------------------------------------------
                                    493 ;Allocation info for local variables in function 'hexNibble2dec'
                                    494 ;------------------------------------------------------------
                                    495 ;nibble                    Allocated to registers r7 
                                    496 ;------------------------------------------------------------
                                    497 ;	uart.h:6: unsigned char hexNibble2dec(char nibble)
                                    498 ;	-----------------------------------------
                                    499 ;	 function hexNibble2dec
                                    500 ;	-----------------------------------------
      000000                        501 _hexNibble2dec:
                           000007   502 	ar7 = 0x07
                           000006   503 	ar6 = 0x06
                           000005   504 	ar5 = 0x05
                           000004   505 	ar4 = 0x04
                           000003   506 	ar3 = 0x03
                           000002   507 	ar2 = 0x02
                           000001   508 	ar1 = 0x01
                           000000   509 	ar0 = 0x00
      000000 AF 82            [24]  510 	mov	r7,dpl
                                    511 ;	uart.h:8: if('0' <= nibble && nibble <= '9') return nibble - 0x30;
      000002 BF 30 00         [24]  512 	cjne	r7,#0x30,00139$
      000005                        513 00139$:
      000005 40 0D            [24]  514 	jc	00110$
      000007 EF               [12]  515 	mov	a,r7
      000008 24 C6            [12]  516 	add	a,#0xff - 0x39
      00000A 40 08            [24]  517 	jc	00110$
      00000C 8F 06            [24]  518 	mov	ar6,r7
      00000E EE               [12]  519 	mov	a,r6
      00000F 24 D0            [12]  520 	add	a,#0xd0
      000011 F5 82            [12]  521 	mov	dpl,a
      000013 22               [24]  522 	ret
      000014                        523 00110$:
                                    524 ;	uart.h:9: else if('A' <= nibble && nibble <= 'F') return 10 + nibble - 'A';
      000014 BF 41 00         [24]  525 	cjne	r7,#0x41,00142$
      000017                        526 00142$:
      000017 40 0D            [24]  527 	jc	00106$
      000019 EF               [12]  528 	mov	a,r7
      00001A 24 B9            [12]  529 	add	a,#0xff - 0x46
      00001C 40 08            [24]  530 	jc	00106$
      00001E 8F 06            [24]  531 	mov	ar6,r7
      000020 74 C9            [12]  532 	mov	a,#0xc9
      000022 2E               [12]  533 	add	a,r6
      000023 F5 82            [12]  534 	mov	dpl,a
      000025 22               [24]  535 	ret
      000026                        536 00106$:
                                    537 ;	uart.h:10: else if('a' <= nibble && nibble <= 'f') return 10 + nibble - 'a';
      000026 BF 61 00         [24]  538 	cjne	r7,#0x61,00145$
      000029                        539 00145$:
      000029 40 0B            [24]  540 	jc	00102$
      00002B EF               [12]  541 	mov	a,r7
      00002C 24 99            [12]  542 	add	a,#0xff - 0x66
      00002E 40 06            [24]  543 	jc	00102$
      000030 74 A9            [12]  544 	mov	a,#0xa9
      000032 2F               [12]  545 	add	a,r7
      000033 F5 82            [12]  546 	mov	dpl,a
      000035 22               [24]  547 	ret
      000036                        548 00102$:
                                    549 ;	uart.h:11: else return 0;
      000036 75 82 00         [24]  550 	mov	dpl,#0x00
                                    551 ;	uart.h:12: }
      000039 22               [24]  552 	ret
                                    553 ;------------------------------------------------------------
                                    554 ;Allocation info for local variables in function 'hex2dec'
                                    555 ;------------------------------------------------------------
                                    556 ;LSnibble                  Allocated with name '_hex2dec_PARM_2'
                                    557 ;MSnibble                  Allocated to registers r7 
                                    558 ;------------------------------------------------------------
                                    559 ;	uart.h:14: unsigned char hex2dec(char MSnibble,char LSnibble)
                                    560 ;	-----------------------------------------
                                    561 ;	 function hex2dec
                                    562 ;	-----------------------------------------
      00003A                        563 _hex2dec:
                                    564 ;	uart.h:17: return 16*hexNibble2dec(MSnibble) + hexNibble2dec(LSnibble);
      00003A 12r00r00         [24]  565 	lcall	_hexNibble2dec
      00003D E5 82            [12]  566 	mov	a,dpl
      00003F C4               [12]  567 	swap	a
      000040 54 F0            [12]  568 	anl	a,#0xf0
      000042 FF               [12]  569 	mov	r7,a
      000043 85*00 82         [24]  570 	mov	dpl,_hex2dec_PARM_2
      000046 C0 07            [24]  571 	push	ar7
      000048 12r00r00         [24]  572 	lcall	_hexNibble2dec
      00004B AE 82            [24]  573 	mov	r6,dpl
      00004D D0 07            [24]  574 	pop	ar7
      00004F EE               [12]  575 	mov	a,r6
      000050 2F               [12]  576 	add	a,r7
      000051 F5 82            [12]  577 	mov	dpl,a
                                    578 ;	uart.h:18: }
      000053 22               [24]  579 	ret
                                    580 ;------------------------------------------------------------
                                    581 ;Allocation info for local variables in function 'dec2hexNibble'
                                    582 ;------------------------------------------------------------
                                    583 ;dec                       Allocated to registers r7 
                                    584 ;------------------------------------------------------------
                                    585 ;	uart.h:21: unsigned char dec2hexNibble(unsigned char dec)
                                    586 ;	-----------------------------------------
                                    587 ;	 function dec2hexNibble
                                    588 ;	-----------------------------------------
      000054                        589 _dec2hexNibble:
                                    590 ;	uart.h:24: if(dec>15) return 'X'; // X for invalid
      000054 E5 82            [12]  591 	mov	a,dpl
      000056 FF               [12]  592 	mov	r7,a
      000057 24 F0            [12]  593 	add	a,#0xff - 0x0f
      000059 50 04            [24]  594 	jnc	00102$
      00005B 75 82 58         [24]  595 	mov	dpl,#0x58
      00005E 22               [24]  596 	ret
      00005F                        597 00102$:
                                    598 ;	uart.h:26: if(dec<=9) return 0x30 + dec;
      00005F EF               [12]  599 	mov	a,r7
      000060 24 F6            [12]  600 	add	a,#0xff - 0x09
      000062 40 08            [24]  601 	jc	00104$
      000064 8F 06            [24]  602 	mov	ar6,r7
      000066 74 30            [12]  603 	mov	a,#0x30
      000068 2E               [12]  604 	add	a,r6
      000069 F5 82            [12]  605 	mov	dpl,a
      00006B 22               [24]  606 	ret
      00006C                        607 00104$:
                                    608 ;	uart.h:27: else return 'A' + dec - 10;
      00006C 74 37            [12]  609 	mov	a,#0x37
      00006E 2F               [12]  610 	add	a,r7
      00006F F5 82            [12]  611 	mov	dpl,a
                                    612 ;	uart.h:28: }
      000071 22               [24]  613 	ret
                                    614 ;------------------------------------------------------------
                                    615 ;Allocation info for local variables in function 'UartBegin'
                                    616 ;------------------------------------------------------------
                                    617 ;	uart.h:33: void UartBegin()
                                    618 ;	-----------------------------------------
                                    619 ;	 function UartBegin
                                    620 ;	-----------------------------------------
      000072                        621 _UartBegin:
                                    622 ;	uart.h:37: TMOD = 0X20; //TIMER1 8 BIT AUTO-RELOAD
      000072 75 89 20         [24]  623 	mov	_TMOD,#0x20
                                    624 ;	uart.h:39: TH1 = 0XF3; //2400
      000075 75 8D F3         [24]  625 	mov	_TH1,#0xf3
                                    626 ;	uart.h:40: SCON = 0X50;
      000078 75 98 50         [24]  627 	mov	_SCON,#0x50
                                    628 ;	uart.h:42: PCON |= 1<<7; //double the baudrate - 4800
      00007B 43 87 80         [24]  629 	orl	_PCON,#0x80
                                    630 ;	uart.h:44: TR1 = 1; //START TIMER
                                    631 ;	assignBit
      00007E D2 8E            [12]  632 	setb	_TR1
                                    633 ;	uart.h:45: }
      000080 22               [24]  634 	ret
                                    635 ;------------------------------------------------------------
                                    636 ;Allocation info for local variables in function 'UartReadReady'
                                    637 ;------------------------------------------------------------
                                    638 ;	uart.h:47: unsigned char UartReadReady()
                                    639 ;	-----------------------------------------
                                    640 ;	 function UartReadReady
                                    641 ;	-----------------------------------------
      000081                        642 _UartReadReady:
                                    643 ;	uart.h:49: if(RI==0)return 0; //not received any char
      000081 20 98 04         [24]  644 	jb	_RI,00102$
      000084 75 82 00         [24]  645 	mov	dpl,#0x00
      000087 22               [24]  646 	ret
      000088                        647 00102$:
                                    648 ;	uart.h:50: else return 1; //received and ready
      000088 75 82 01         [24]  649 	mov	dpl,#0x01
                                    650 ;	uart.h:51: }
      00008B 22               [24]  651 	ret
                                    652 ;------------------------------------------------------------
                                    653 ;Allocation info for local variables in function 'UartRead'
                                    654 ;------------------------------------------------------------
                                    655 ;value                     Allocated to registers 
                                    656 ;------------------------------------------------------------
                                    657 ;	uart.h:53: unsigned char UartRead()
                                    658 ;	-----------------------------------------
                                    659 ;	 function UartRead
                                    660 ;	-----------------------------------------
      00008C                        661 _UartRead:
                                    662 ;	uart.h:56: while(RI==0); //wait till RX
      00008C                        663 00101$:
                                    664 ;	uart.h:57: RI=0;
                                    665 ;	assignBit
      00008C 10 98 02         [24]  666 	jbc	_RI,00114$
      00008F 80 FB            [24]  667 	sjmp	00101$
      000091                        668 00114$:
                                    669 ;	uart.h:58: value = SBUF;
      000091 85 99 82         [24]  670 	mov	dpl,_SBUF
                                    671 ;	uart.h:59: return value;
                                    672 ;	uart.h:60: }
      000094 22               [24]  673 	ret
                                    674 ;------------------------------------------------------------
                                    675 ;Allocation info for local variables in function 'UartWrite'
                                    676 ;------------------------------------------------------------
                                    677 ;value                     Allocated to registers 
                                    678 ;------------------------------------------------------------
                                    679 ;	uart.h:63: void UartWrite(unsigned char value)
                                    680 ;	-----------------------------------------
                                    681 ;	 function UartWrite
                                    682 ;	-----------------------------------------
      000095                        683 _UartWrite:
      000095 85 82 99         [24]  684 	mov	_SBUF,dpl
                                    685 ;	uart.h:66: while(TI==0); // wait till TX
      000098                        686 00101$:
                                    687 ;	uart.h:67: TI=0;
                                    688 ;	assignBit
      000098 10 99 02         [24]  689 	jbc	_TI,00114$
      00009B 80 FB            [24]  690 	sjmp	00101$
      00009D                        691 00114$:
                                    692 ;	uart.h:68: }
      00009D 22               [24]  693 	ret
                                    694 ;------------------------------------------------------------
                                    695 ;Allocation info for local variables in function 'UartWriteBuff'
                                    696 ;------------------------------------------------------------
                                    697 ;length                    Allocated with name '_UartWriteBuff_PARM_2'
                                    698 ;p                         Allocated to registers r5 r6 r7 
                                    699 ;i                         Allocated to registers r4 
                                    700 ;------------------------------------------------------------
                                    701 ;	uart.h:70: void UartWriteBuff(unsigned char *p, unsigned char length)
                                    702 ;	-----------------------------------------
                                    703 ;	 function UartWriteBuff
                                    704 ;	-----------------------------------------
      00009E                        705 _UartWriteBuff:
      00009E AD 82            [24]  706 	mov	r5,dpl
      0000A0 AE 83            [24]  707 	mov	r6,dph
      0000A2 AF F0            [24]  708 	mov	r7,b
                                    709 ;	uart.h:73: for (i=0;i<length;i++)
      0000A4 7C 00            [12]  710 	mov	r4,#0x00
      0000A6                        711 00103$:
      0000A6 C3               [12]  712 	clr	c
      0000A7 EC               [12]  713 	mov	a,r4
      0000A8 95*01            [12]  714 	subb	a,_UartWriteBuff_PARM_2
      0000AA 50 29            [24]  715 	jnc	00105$
                                    716 ;	uart.h:75: UartWrite(p[i]);
      0000AC EC               [12]  717 	mov	a,r4
      0000AD 2D               [12]  718 	add	a,r5
      0000AE F9               [12]  719 	mov	r1,a
      0000AF E4               [12]  720 	clr	a
      0000B0 3E               [12]  721 	addc	a,r6
      0000B1 FA               [12]  722 	mov	r2,a
      0000B2 8F 03            [24]  723 	mov	ar3,r7
      0000B4 89 82            [24]  724 	mov	dpl,r1
      0000B6 8A 83            [24]  725 	mov	dph,r2
      0000B8 8B F0            [24]  726 	mov	b,r3
      0000BA 12r00r00         [24]  727 	lcall	__gptrget
      0000BD F5 82            [12]  728 	mov	dpl,a
      0000BF C0 07            [24]  729 	push	ar7
      0000C1 C0 06            [24]  730 	push	ar6
      0000C3 C0 05            [24]  731 	push	ar5
      0000C5 C0 04            [24]  732 	push	ar4
      0000C7 12r00r95         [24]  733 	lcall	_UartWrite
      0000CA D0 04            [24]  734 	pop	ar4
      0000CC D0 05            [24]  735 	pop	ar5
      0000CE D0 06            [24]  736 	pop	ar6
      0000D0 D0 07            [24]  737 	pop	ar7
                                    738 ;	uart.h:73: for (i=0;i<length;i++)
      0000D2 0C               [12]  739 	inc	r4
      0000D3 80 D1            [24]  740 	sjmp	00103$
      0000D5                        741 00105$:
                                    742 ;	uart.h:77: }
      0000D5 22               [24]  743 	ret
                                    744 ;------------------------------------------------------------
                                    745 ;Allocation info for local variables in function 'UartReadBuff'
                                    746 ;------------------------------------------------------------
                                    747 ;length                    Allocated with name '_UartReadBuff_PARM_2'
                                    748 ;p                         Allocated to registers r5 r6 r7 
                                    749 ;i                         Allocated to registers r4 
                                    750 ;------------------------------------------------------------
                                    751 ;	uart.h:79: void UartReadBuff(unsigned char *p, unsigned char length)
                                    752 ;	-----------------------------------------
                                    753 ;	 function UartReadBuff
                                    754 ;	-----------------------------------------
      0000D6                        755 _UartReadBuff:
      0000D6 AD 82            [24]  756 	mov	r5,dpl
      0000D8 AE 83            [24]  757 	mov	r6,dph
      0000DA AF F0            [24]  758 	mov	r7,b
                                    759 ;	uart.h:82: for (i=0;i<length;i++)
      0000DC 7C 00            [12]  760 	mov	r4,#0x00
      0000DE                        761 00103$:
      0000DE C3               [12]  762 	clr	c
      0000DF EC               [12]  763 	mov	a,r4
      0000E0 95*02            [12]  764 	subb	a,_UartReadBuff_PARM_2
      0000E2 50 36            [24]  765 	jnc	00105$
                                    766 ;	uart.h:84: p[i] = UartRead();
      0000E4 EC               [12]  767 	mov	a,r4
      0000E5 2D               [12]  768 	add	a,r5
      0000E6 F9               [12]  769 	mov	r1,a
      0000E7 E4               [12]  770 	clr	a
      0000E8 3E               [12]  771 	addc	a,r6
      0000E9 FA               [12]  772 	mov	r2,a
      0000EA 8F 03            [24]  773 	mov	ar3,r7
      0000EC C0 07            [24]  774 	push	ar7
      0000EE C0 06            [24]  775 	push	ar6
      0000F0 C0 05            [24]  776 	push	ar5
      0000F2 C0 04            [24]  777 	push	ar4
      0000F4 C0 03            [24]  778 	push	ar3
      0000F6 C0 02            [24]  779 	push	ar2
      0000F8 C0 01            [24]  780 	push	ar1
      0000FA 12r00r8C         [24]  781 	lcall	_UartRead
      0000FD A8 82            [24]  782 	mov	r0,dpl
      0000FF D0 01            [24]  783 	pop	ar1
      000101 D0 02            [24]  784 	pop	ar2
      000103 D0 03            [24]  785 	pop	ar3
      000105 D0 04            [24]  786 	pop	ar4
      000107 D0 05            [24]  787 	pop	ar5
      000109 D0 06            [24]  788 	pop	ar6
      00010B D0 07            [24]  789 	pop	ar7
      00010D 89 82            [24]  790 	mov	dpl,r1
      00010F 8A 83            [24]  791 	mov	dph,r2
      000111 8B F0            [24]  792 	mov	b,r3
      000113 E8               [12]  793 	mov	a,r0
      000114 12r00r00         [24]  794 	lcall	__gptrput
                                    795 ;	uart.h:82: for (i=0;i<length;i++)
      000117 0C               [12]  796 	inc	r4
      000118 80 C4            [24]  797 	sjmp	00103$
      00011A                        798 00105$:
                                    799 ;	uart.h:86: }
      00011A 22               [24]  800 	ret
                                    801 ;------------------------------------------------------------
                                    802 ;Allocation info for local variables in function 'UartPrint'
                                    803 ;------------------------------------------------------------
                                    804 ;p                         Allocated to registers 
                                    805 ;------------------------------------------------------------
                                    806 ;	uart.h:88: void UartPrint(unsigned char *p)
                                    807 ;	-----------------------------------------
                                    808 ;	 function UartPrint
                                    809 ;	-----------------------------------------
      00011B                        810 _UartPrint:
      00011B AD 82            [24]  811 	mov	r5,dpl
      00011D AE 83            [24]  812 	mov	r6,dph
      00011F AF F0            [24]  813 	mov	r7,b
                                    814 ;	uart.h:90: do
      000121                        815 00101$:
                                    816 ;	uart.h:92: UartWrite(*p);
      000121 8D 82            [24]  817 	mov	dpl,r5
      000123 8E 83            [24]  818 	mov	dph,r6
      000125 8F F0            [24]  819 	mov	b,r7
      000127 12r00r00         [24]  820 	lcall	__gptrget
      00012A FC               [12]  821 	mov	r4,a
      00012B A3               [24]  822 	inc	dptr
      00012C AD 82            [24]  823 	mov	r5,dpl
      00012E AE 83            [24]  824 	mov	r6,dph
      000130 8C 82            [24]  825 	mov	dpl,r4
      000132 C0 07            [24]  826 	push	ar7
      000134 C0 06            [24]  827 	push	ar6
      000136 C0 05            [24]  828 	push	ar5
      000138 12r00r95         [24]  829 	lcall	_UartWrite
      00013B D0 05            [24]  830 	pop	ar5
      00013D D0 06            [24]  831 	pop	ar6
      00013F D0 07            [24]  832 	pop	ar7
                                    833 ;	uart.h:93: }while(*(++p)!=0);
      000141 8D 82            [24]  834 	mov	dpl,r5
      000143 8E 83            [24]  835 	mov	dph,r6
      000145 8F F0            [24]  836 	mov	b,r7
      000147 12r00r00         [24]  837 	lcall	__gptrget
      00014A 70 D5            [24]  838 	jnz	00101$
                                    839 ;	uart.h:94: }
      00014C 22               [24]  840 	ret
                                    841 ;------------------------------------------------------------
                                    842 ;Allocation info for local variables in function 'UartWriteNumber'
                                    843 ;------------------------------------------------------------
                                    844 ;format                    Allocated to stack - _bp -3
                                    845 ;num                       Allocated to registers r7 
                                    846 ;msd                       Allocated to registers r4 
                                    847 ;lsd                       Allocated to registers r6 
                                    848 ;extra                     Allocated to registers r3 
                                    849 ;------------------------------------------------------------
                                    850 ;	uart.h:99: void UartWriteNumber(unsigned char num,unsigned char format) __reentrant
                                    851 ;	-----------------------------------------
                                    852 ;	 function UartWriteNumber
                                    853 ;	-----------------------------------------
      00014D                        854 _UartWriteNumber:
      00014D C0*00            [24]  855 	push	_bp
      00014F 85 81*00         [24]  856 	mov	_bp,sp
      000152 AF 82            [24]  857 	mov	r7,dpl
                                    858 ;	uart.h:104: if(format==HEX)
      000154 E5*00            [12]  859 	mov	a,_bp
      000156 24 FD            [12]  860 	add	a,#0xfd
      000158 F8               [12]  861 	mov	r0,a
      000159 E6               [12]  862 	mov	a,@r0
                                    863 ;	uart.h:106: msd = num/16;
      00015A 70 32            [24]  864 	jnz	00104$
      00015C 8F 05            [24]  865 	mov	ar5,r7
      00015E FE               [12]  866 	mov	r6,a
      00015F 75*00 10         [24]  867 	mov	__divsint_PARM_2,#0x10
                                    868 ;	1-genFromRTrack replaced	mov	(__divsint_PARM_2 + 1),#0x00
      000162 8E*01            [24]  869 	mov	(__divsint_PARM_2 + 1),r6
      000164 8D 82            [24]  870 	mov	dpl,r5
      000166 8E 83            [24]  871 	mov	dph,r6
      000168 C0 06            [24]  872 	push	ar6
      00016A C0 05            [24]  873 	push	ar5
      00016C 12r00r00         [24]  874 	lcall	__divsint
      00016F AB 82            [24]  875 	mov	r3,dpl
      000171 D0 05            [24]  876 	pop	ar5
      000173 D0 06            [24]  877 	pop	ar6
                                    878 ;	uart.h:107: lsd = num%16;
      000175 53 05 0F         [24]  879 	anl	ar5,#0x0f
                                    880 ;	uart.h:108: UartWrite(dec2hexNibble(msd));
      000178 8B 82            [24]  881 	mov	dpl,r3
      00017A C0 05            [24]  882 	push	ar5
      00017C 12r00r54         [24]  883 	lcall	_dec2hexNibble
      00017F 12r00r95         [24]  884 	lcall	_UartWrite
      000182 D0 05            [24]  885 	pop	ar5
                                    886 ;	uart.h:109: UartWrite(dec2hexNibble(lsd));
      000184 8D 82            [24]  887 	mov	dpl,r5
      000186 12r00r54         [24]  888 	lcall	_dec2hexNibble
      000189 12r00r95         [24]  889 	lcall	_UartWrite
      00018C 80 7B            [24]  890 	sjmp	00106$
      00018E                        891 00104$:
                                    892 ;	uart.h:112: else if(format==DEC)
      00018E E5*00            [12]  893 	mov	a,_bp
      000190 24 FD            [12]  894 	add	a,#0xfd
      000192 F8               [12]  895 	mov	r0,a
      000193 B6 01 73         [24]  896 	cjne	@r0,#0x01,00106$
                                    897 ;	uart.h:114: msd = num/100; // 100s place
      000196 7E 00            [12]  898 	mov	r6,#0x00
      000198 75*00 64         [24]  899 	mov	__divsint_PARM_2,#0x64
                                    900 ;	1-genFromRTrack replaced	mov	(__divsint_PARM_2 + 1),#0x00
      00019B 8E*01            [24]  901 	mov	(__divsint_PARM_2 + 1),r6
      00019D 8F 82            [24]  902 	mov	dpl,r7
      00019F 8E 83            [24]  903 	mov	dph,r6
      0001A1 C0 07            [24]  904 	push	ar7
      0001A3 C0 06            [24]  905 	push	ar6
      0001A5 12r00r00         [24]  906 	lcall	__divsint
      0001A8 AC 82            [24]  907 	mov	r4,dpl
      0001AA D0 06            [24]  908 	pop	ar6
      0001AC D0 07            [24]  909 	pop	ar7
                                    910 ;	uart.h:115: extra = (num%100)/10; //tenth place
      0001AE 75*00 64         [24]  911 	mov	__modsint_PARM_2,#0x64
      0001B1 75*01 00         [24]  912 	mov	(__modsint_PARM_2 + 1),#0x00
      0001B4 8F 82            [24]  913 	mov	dpl,r7
      0001B6 8E 83            [24]  914 	mov	dph,r6
      0001B8 C0 07            [24]  915 	push	ar7
      0001BA C0 06            [24]  916 	push	ar6
      0001BC C0 04            [24]  917 	push	ar4
      0001BE 12r00r00         [24]  918 	lcall	__modsint
      0001C1 75*00 0A         [24]  919 	mov	__divsint_PARM_2,#0x0a
      0001C4 75*01 00         [24]  920 	mov	(__divsint_PARM_2 + 1),#0x00
      0001C7 12r00r00         [24]  921 	lcall	__divsint
      0001CA AB 82            [24]  922 	mov	r3,dpl
      0001CC D0 04            [24]  923 	pop	ar4
      0001CE D0 06            [24]  924 	pop	ar6
      0001D0 D0 07            [24]  925 	pop	ar7
                                    926 ;	uart.h:116: lsd = num%10;
      0001D2 75*00 0A         [24]  927 	mov	__modsint_PARM_2,#0x0a
      0001D5 75*01 00         [24]  928 	mov	(__modsint_PARM_2 + 1),#0x00
      0001D8 8F 82            [24]  929 	mov	dpl,r7
      0001DA 8E 83            [24]  930 	mov	dph,r6
      0001DC C0 04            [24]  931 	push	ar4
      0001DE C0 03            [24]  932 	push	ar3
      0001E0 12r00r00         [24]  933 	lcall	__modsint
      0001E3 AE 82            [24]  934 	mov	r6,dpl
      0001E5 D0 03            [24]  935 	pop	ar3
      0001E7 D0 04            [24]  936 	pop	ar4
                                    937 ;	uart.h:118: UartWrite(msd + 0x30);
      0001E9 74 30            [12]  938 	mov	a,#0x30
      0001EB 2C               [12]  939 	add	a,r4
      0001EC F5 82            [12]  940 	mov	dpl,a
      0001EE C0 06            [24]  941 	push	ar6
      0001F0 C0 03            [24]  942 	push	ar3
      0001F2 12r00r95         [24]  943 	lcall	_UartWrite
      0001F5 D0 03            [24]  944 	pop	ar3
                                    945 ;	uart.h:119: UartWrite(extra + 0x30);
      0001F7 74 30            [12]  946 	mov	a,#0x30
      0001F9 2B               [12]  947 	add	a,r3
      0001FA F5 82            [12]  948 	mov	dpl,a
      0001FC 12r00r95         [24]  949 	lcall	_UartWrite
      0001FF D0 06            [24]  950 	pop	ar6
                                    951 ;	uart.h:120: UartWrite(lsd + 0x30);
      000201 74 30            [12]  952 	mov	a,#0x30
      000203 2E               [12]  953 	add	a,r6
      000204 F5 82            [12]  954 	mov	dpl,a
      000206 12r00r95         [24]  955 	lcall	_UartWrite
      000209                        956 00106$:
                                    957 ;	uart.h:123: }
      000209 D0*00            [24]  958 	pop	_bp
      00020B 22               [24]  959 	ret
                                    960 ;------------------------------------------------------------
                                    961 ;Allocation info for local variables in function 'UartWriteNumbers'
                                    962 ;------------------------------------------------------------
                                    963 ;length                    Allocated to stack - _bp -3
                                    964 ;format                    Allocated to stack - _bp -4
                                    965 ;delimiter                 Allocated to stack - _bp -5
                                    966 ;p                         Allocated to registers 
                                    967 ;i                         Allocated to registers r4 
                                    968 ;------------------------------------------------------------
                                    969 ;	uart.h:125: void UartWriteNumbers(unsigned char *p, unsigned char length,unsigned char format,unsigned char delimiter) __reentrant
                                    970 ;	-----------------------------------------
                                    971 ;	 function UartWriteNumbers
                                    972 ;	-----------------------------------------
      00020C                        973 _UartWriteNumbers:
      00020C C0*00            [24]  974 	push	_bp
      00020E 85 81*00         [24]  975 	mov	_bp,sp
      000211 AD 82            [24]  976 	mov	r5,dpl
      000213 AE 83            [24]  977 	mov	r6,dph
      000215 AF F0            [24]  978 	mov	r7,b
                                    979 ;	uart.h:129: for(i=0;i<length;i++,p++)
      000217 7C 00            [12]  980 	mov	r4,#0x00
      000219                        981 00103$:
      000219 E5*00            [12]  982 	mov	a,_bp
      00021B 24 FD            [12]  983 	add	a,#0xfd
      00021D F8               [12]  984 	mov	r0,a
      00021E C3               [12]  985 	clr	c
      00021F EC               [12]  986 	mov	a,r4
      000220 96               [12]  987 	subb	a,@r0
      000221 50 3B            [24]  988 	jnc	00105$
                                    989 ;	uart.h:131: UartWriteNumber(*p,format);
      000223 8D 82            [24]  990 	mov	dpl,r5
      000225 8E 83            [24]  991 	mov	dph,r6
      000227 8F F0            [24]  992 	mov	b,r7
      000229 12r00r00         [24]  993 	lcall	__gptrget
      00022C FB               [12]  994 	mov	r3,a
      00022D A3               [24]  995 	inc	dptr
      00022E AD 82            [24]  996 	mov	r5,dpl
      000230 AE 83            [24]  997 	mov	r6,dph
      000232 C0 07            [24]  998 	push	ar7
      000234 C0 06            [24]  999 	push	ar6
      000236 C0 05            [24] 1000 	push	ar5
      000238 C0 04            [24] 1001 	push	ar4
      00023A E5*00            [12] 1002 	mov	a,_bp
      00023C 24 FC            [12] 1003 	add	a,#0xfc
      00023E F8               [12] 1004 	mov	r0,a
      00023F E6               [12] 1005 	mov	a,@r0
      000240 C0 E0            [24] 1006 	push	acc
      000242 8B 82            [24] 1007 	mov	dpl,r3
      000244 12r01r4D         [24] 1008 	lcall	_UartWriteNumber
      000247 15 81            [12] 1009 	dec	sp
                                   1010 ;	uart.h:132: UartWrite(delimiter);
      000249 E5*00            [12] 1011 	mov	a,_bp
      00024B 24 FB            [12] 1012 	add	a,#0xfb
      00024D F8               [12] 1013 	mov	r0,a
      00024E 86 82            [24] 1014 	mov	dpl,@r0
      000250 12r00r95         [24] 1015 	lcall	_UartWrite
      000253 D0 04            [24] 1016 	pop	ar4
      000255 D0 05            [24] 1017 	pop	ar5
      000257 D0 06            [24] 1018 	pop	ar6
      000259 D0 07            [24] 1019 	pop	ar7
                                   1020 ;	uart.h:129: for(i=0;i<length;i++,p++)
      00025B 0C               [12] 1021 	inc	r4
      00025C 80 BB            [24] 1022 	sjmp	00103$
      00025E                       1023 00105$:
                                   1024 ;	uart.h:134: }
      00025E D0*00            [24] 1025 	pop	_bp
      000260 22               [24] 1026 	ret
                                   1027 ;------------------------------------------------------------
                                   1028 ;Allocation info for local variables in function 'UartPrintNumber'
                                   1029 ;------------------------------------------------------------
                                   1030 ;n                         Allocated to stack - _bp +1
                                   1031 ;digit                     Allocated to stack - _bp +7
                                   1032 ;i                         Allocated to stack - _bp +5
                                   1033 ;j                         Allocated to registers r3 
                                   1034 ;leading_zeroes_flag       Allocated to stack - _bp +6
                                   1035 ;sloc0                     Allocated to stack - _bp +12
                                   1036 ;------------------------------------------------------------
                                   1037 ;	uart.h:136: void UartPrintNumber(unsigned long n) __reentrant
                                   1038 ;	-----------------------------------------
                                   1039 ;	 function UartPrintNumber
                                   1040 ;	-----------------------------------------
      000261                       1041 _UartPrintNumber:
      000261 C0*00            [24] 1042 	push	_bp
      000263 85 81*00         [24] 1043 	mov	_bp,sp
      000266 C0 82            [24] 1044 	push	dpl
      000268 C0 83            [24] 1045 	push	dph
      00026A C0 F0            [24] 1046 	push	b
      00026C C0 E0            [24] 1047 	push	acc
      00026E E5 81            [12] 1048 	mov	a,sp
      000270 24 06            [12] 1049 	add	a,#0x06
      000272 F5 81            [12] 1050 	mov	sp,a
                                   1051 ;	uart.h:152: char i,j,leading_zeroes_flag=1;
      000274 E5*00            [12] 1052 	mov	a,_bp
      000276 24 06            [12] 1053 	add	a,#0x06
      000278 F8               [12] 1054 	mov	r0,a
      000279 76 01            [12] 1055 	mov	@r0,#0x01
                                   1056 ;	uart.h:153: for(i=8;i>0;i--)
      00027B E5*00            [12] 1057 	mov	a,_bp
      00027D 24 05            [12] 1058 	add	a,#0x05
      00027F F8               [12] 1059 	mov	r0,a
      000280 76 08            [12] 1060 	mov	@r0,#0x08
      000282                       1061 00112$:
                                   1062 ;	uart.h:155: digit=n;
      000282 A8*00            [24] 1063 	mov	r0,_bp
      000284 08               [12] 1064 	inc	r0
      000285 E5*00            [12] 1065 	mov	a,_bp
      000287 24 07            [12] 1066 	add	a,#0x07
      000289 F9               [12] 1067 	mov	r1,a
      00028A E6               [12] 1068 	mov	a,@r0
      00028B F7               [12] 1069 	mov	@r1,a
      00028C 08               [12] 1070 	inc	r0
      00028D 09               [12] 1071 	inc	r1
      00028E E6               [12] 1072 	mov	a,@r0
      00028F F7               [12] 1073 	mov	@r1,a
      000290 08               [12] 1074 	inc	r0
      000291 09               [12] 1075 	inc	r1
      000292 E6               [12] 1076 	mov	a,@r0
      000293 F7               [12] 1077 	mov	@r1,a
      000294 08               [12] 1078 	inc	r0
      000295 09               [12] 1079 	inc	r1
      000296 E6               [12] 1080 	mov	a,@r0
      000297 F7               [12] 1081 	mov	@r1,a
                                   1082 ;	uart.h:156: for(j=1;j<i;j++) digit/=10;
      000298 7B 01            [12] 1083 	mov	r3,#0x01
      00029A                       1084 00110$:
      00029A E5*00            [12] 1085 	mov	a,_bp
      00029C 24 05            [12] 1086 	add	a,#0x05
      00029E F8               [12] 1087 	mov	r0,a
      00029F C3               [12] 1088 	clr	c
      0002A0 EB               [12] 1089 	mov	a,r3
      0002A1 96               [12] 1090 	subb	a,@r0
      0002A2 50 3A            [24] 1091 	jnc	00101$
      0002A4 75*00 0A         [24] 1092 	mov	__divulong_PARM_2,#0x0a
      0002A7 E4               [12] 1093 	clr	a
      0002A8 F5*01            [12] 1094 	mov	(__divulong_PARM_2 + 1),a
      0002AA F5*02            [12] 1095 	mov	(__divulong_PARM_2 + 2),a
      0002AC F5*03            [12] 1096 	mov	(__divulong_PARM_2 + 3),a
      0002AE E5*00            [12] 1097 	mov	a,_bp
      0002B0 24 07            [12] 1098 	add	a,#0x07
      0002B2 F8               [12] 1099 	mov	r0,a
      0002B3 86 82            [24] 1100 	mov	dpl,@r0
      0002B5 08               [12] 1101 	inc	r0
      0002B6 86 83            [24] 1102 	mov	dph,@r0
      0002B8 08               [12] 1103 	inc	r0
      0002B9 86 F0            [24] 1104 	mov	b,@r0
      0002BB 08               [12] 1105 	inc	r0
      0002BC E6               [12] 1106 	mov	a,@r0
      0002BD C0 03            [24] 1107 	push	ar3
      0002BF 12r00r00         [24] 1108 	lcall	__divulong
      0002C2 AC 82            [24] 1109 	mov	r4,dpl
      0002C4 AD 83            [24] 1110 	mov	r5,dph
      0002C6 AE F0            [24] 1111 	mov	r6,b
      0002C8 FF               [12] 1112 	mov	r7,a
      0002C9 D0 03            [24] 1113 	pop	ar3
      0002CB E5*00            [12] 1114 	mov	a,_bp
      0002CD 24 07            [12] 1115 	add	a,#0x07
      0002CF F8               [12] 1116 	mov	r0,a
      0002D0 A6 04            [24] 1117 	mov	@r0,ar4
      0002D2 08               [12] 1118 	inc	r0
      0002D3 A6 05            [24] 1119 	mov	@r0,ar5
      0002D5 08               [12] 1120 	inc	r0
      0002D6 A6 06            [24] 1121 	mov	@r0,ar6
      0002D8 08               [12] 1122 	inc	r0
      0002D9 A6 07            [24] 1123 	mov	@r0,ar7
      0002DB 0B               [12] 1124 	inc	r3
      0002DC 80 BC            [24] 1125 	sjmp	00110$
      0002DE                       1126 00101$:
                                   1127 ;	uart.h:158: if(leading_zeroes_flag && digit%10) leading_zeroes_flag=0; //flag to start printing
      0002DE E5*00            [12] 1128 	mov	a,_bp
      0002E0 24 06            [12] 1129 	add	a,#0x06
      0002E2 F8               [12] 1130 	mov	r0,a
      0002E3 E6               [12] 1131 	mov	a,@r0
      0002E4 60 30            [24] 1132 	jz	00103$
      0002E6 75*00 0A         [24] 1133 	mov	__modulong_PARM_2,#0x0a
      0002E9 E4               [12] 1134 	clr	a
      0002EA F5*01            [12] 1135 	mov	(__modulong_PARM_2 + 1),a
      0002EC F5*02            [12] 1136 	mov	(__modulong_PARM_2 + 2),a
      0002EE F5*03            [12] 1137 	mov	(__modulong_PARM_2 + 3),a
      0002F0 E5*00            [12] 1138 	mov	a,_bp
      0002F2 24 07            [12] 1139 	add	a,#0x07
      0002F4 F8               [12] 1140 	mov	r0,a
      0002F5 86 82            [24] 1141 	mov	dpl,@r0
      0002F7 08               [12] 1142 	inc	r0
      0002F8 86 83            [24] 1143 	mov	dph,@r0
      0002FA 08               [12] 1144 	inc	r0
      0002FB 86 F0            [24] 1145 	mov	b,@r0
      0002FD 08               [12] 1146 	inc	r0
      0002FE E6               [12] 1147 	mov	a,@r0
      0002FF 12r00r00         [24] 1148 	lcall	__modulong
      000302 AA 82            [24] 1149 	mov	r2,dpl
      000304 AB 83            [24] 1150 	mov	r3,dph
      000306 AE F0            [24] 1151 	mov	r6,b
      000308 FF               [12] 1152 	mov	r7,a
      000309 EA               [12] 1153 	mov	a,r2
      00030A 4B               [12] 1154 	orl	a,r3
      00030B 4E               [12] 1155 	orl	a,r6
      00030C 4F               [12] 1156 	orl	a,r7
      00030D 60 07            [24] 1157 	jz	00103$
      00030F E5*00            [12] 1158 	mov	a,_bp
      000311 24 06            [12] 1159 	add	a,#0x06
      000313 F8               [12] 1160 	mov	r0,a
      000314 76 00            [12] 1161 	mov	@r0,#0x00
      000316                       1162 00103$:
                                   1163 ;	uart.h:160: if(leading_zeroes_flag); //pass - do not print
      000316 E5*00            [12] 1164 	mov	a,_bp
      000318 24 06            [12] 1165 	add	a,#0x06
      00031A F8               [12] 1166 	mov	r0,a
      00031B E6               [12] 1167 	mov	a,@r0
      00031C 70 26            [24] 1168 	jnz	00113$
                                   1169 ;	uart.h:161: else UartWrite(0x30 + digit%10);
      00031E 75*00 0A         [24] 1170 	mov	__modulong_PARM_2,#0x0a
      000321 E4               [12] 1171 	clr	a
      000322 F5*01            [12] 1172 	mov	(__modulong_PARM_2 + 1),a
      000324 F5*02            [12] 1173 	mov	(__modulong_PARM_2 + 2),a
      000326 F5*03            [12] 1174 	mov	(__modulong_PARM_2 + 3),a
      000328 E5*00            [12] 1175 	mov	a,_bp
      00032A 24 07            [12] 1176 	add	a,#0x07
      00032C F8               [12] 1177 	mov	r0,a
      00032D 86 82            [24] 1178 	mov	dpl,@r0
      00032F 08               [12] 1179 	inc	r0
      000330 86 83            [24] 1180 	mov	dph,@r0
      000332 08               [12] 1181 	inc	r0
      000333 86 F0            [24] 1182 	mov	b,@r0
      000335 08               [12] 1183 	inc	r0
      000336 E6               [12] 1184 	mov	a,@r0
      000337 12r00r00         [24] 1185 	lcall	__modulong
      00033A AC 82            [24] 1186 	mov	r4,dpl
      00033C 74 30            [12] 1187 	mov	a,#0x30
      00033E 2C               [12] 1188 	add	a,r4
      00033F F5 82            [12] 1189 	mov	dpl,a
      000341 12r00r95         [24] 1190 	lcall	_UartWrite
      000344                       1191 00113$:
                                   1192 ;	uart.h:153: for(i=8;i>0;i--)
      000344 E5*00            [12] 1193 	mov	a,_bp
      000346 24 05            [12] 1194 	add	a,#0x05
      000348 F8               [12] 1195 	mov	r0,a
      000349 16               [12] 1196 	dec	@r0
      00034A E5*00            [12] 1197 	mov	a,_bp
      00034C 24 05            [12] 1198 	add	a,#0x05
      00034E F8               [12] 1199 	mov	r0,a
      00034F E6               [12] 1200 	mov	a,@r0
      000350 60 03            [24] 1201 	jz	00149$
      000352 02r02r82         [24] 1202 	ljmp	00112$
      000355                       1203 00149$:
                                   1204 ;	uart.h:163: }
      000355 85*00 81         [24] 1205 	mov	sp,_bp
      000358 D0*00            [24] 1206 	pop	_bp
      00035A 22               [24] 1207 	ret
                                   1208 ;------------------------------------------------------------
                                   1209 ;Allocation info for local variables in function 'UartScanByte'
                                   1210 ;------------------------------------------------------------
                                   1211 ;unibble                   Allocated to registers r7 
                                   1212 ;lnibble                   Allocated to registers r6 
                                   1213 ;------------------------------------------------------------
                                   1214 ;	uart.h:166: uint8_t UartScanByte() __reentrant
                                   1215 ;	-----------------------------------------
                                   1216 ;	 function UartScanByte
                                   1217 ;	-----------------------------------------
      00035B                       1218 _UartScanByte:
                                   1219 ;	uart.h:170: while(UartReadReady()) UartRead(); //flush
      00035B                       1220 00101$:
      00035B 12r00r81         [24] 1221 	lcall	_UartReadReady
      00035E E5 82            [12] 1222 	mov	a,dpl
      000360 60 05            [24] 1223 	jz	00103$
      000362 12r00r8C         [24] 1224 	lcall	_UartRead
      000365 80 F4            [24] 1225 	sjmp	00101$
      000367                       1226 00103$:
                                   1227 ;	uart.h:171: UartPrint("Number(hex) < ");
      000367 90r00r00         [24] 1228 	mov	dptr,#___str_0
      00036A 75 F0 80         [24] 1229 	mov	b,#0x80
      00036D 12r01r1B         [24] 1230 	lcall	_UartPrint
                                   1231 ;	uart.h:173: unibble = UartRead();
      000370 12r00r8C         [24] 1232 	lcall	_UartRead
                                   1233 ;	uart.h:174: UartWrite(unibble);
      000373 AF 82            [24] 1234 	mov  r7,dpl
      000375 C0 07            [24] 1235 	push	ar7
      000377 12r00r95         [24] 1236 	lcall	_UartWrite
                                   1237 ;	uart.h:175: lnibble = UartRead();
      00037A 12r00r8C         [24] 1238 	lcall	_UartRead
                                   1239 ;	uart.h:176: UartWrite(lnibble);
      00037D AE 82            [24] 1240 	mov  r6,dpl
      00037F C0 06            [24] 1241 	push	ar6
      000381 12r00r95         [24] 1242 	lcall	_UartWrite
                                   1243 ;	uart.h:178: UartWrite('\n');
      000384 75 82 0A         [24] 1244 	mov	dpl,#0x0a
      000387 12r00r95         [24] 1245 	lcall	_UartWrite
      00038A D0 06            [24] 1246 	pop	ar6
      00038C D0 07            [24] 1247 	pop	ar7
                                   1248 ;	uart.h:180: return hex2dec(unibble,lnibble);
      00038E 8E*00            [24] 1249 	mov	_hex2dec_PARM_2,r6
      000390 8F 82            [24] 1250 	mov	dpl,r7
                                   1251 ;	uart.h:181: }
      000392 02r00r3A         [24] 1252 	ljmp	_hex2dec
                                   1253 ;------------------------------------------------------------
                                   1254 ;Allocation info for local variables in function 'UartScanLine'
                                   1255 ;------------------------------------------------------------
                                   1256 ;maxLength                 Allocated to stack - _bp -3
                                   1257 ;dst                       Allocated to stack - _bp +1
                                   1258 ;recv                      Allocated to registers r2 
                                   1259 ;count                     Allocated to registers r4 
                                   1260 ;------------------------------------------------------------
                                   1261 ;	uart.h:183: uint8_t UartScanLine(uint8_t *dst, uint8_t maxLength) __reentrant
                                   1262 ;	-----------------------------------------
                                   1263 ;	 function UartScanLine
                                   1264 ;	-----------------------------------------
      000395                       1265 _UartScanLine:
      000395 C0*00            [24] 1266 	push	_bp
      000397 85 81*00         [24] 1267 	mov	_bp,sp
      00039A C0 82            [24] 1268 	push	dpl
      00039C C0 83            [24] 1269 	push	dph
      00039E C0 F0            [24] 1270 	push	b
                                   1271 ;	uart.h:185: uint8_t recv,count=0;
      0003A0 7C 00            [12] 1272 	mov	r4,#0x00
                                   1273 ;	uart.h:187: while(UartReadReady()) UartRead(); //flush
      0003A2                       1274 00101$:
      0003A2 C0 04            [24] 1275 	push	ar4
      0003A4 12r00r81         [24] 1276 	lcall	_UartReadReady
      0003A7 E5 82            [12] 1277 	mov	a,dpl
      0003A9 D0 04            [24] 1278 	pop	ar4
      0003AB 60 09            [24] 1279 	jz	00118$
      0003AD C0 04            [24] 1280 	push	ar4
      0003AF 12r00r8C         [24] 1281 	lcall	_UartRead
      0003B2 D0 04            [24] 1282 	pop	ar4
                                   1283 ;	uart.h:189: while(1)
      0003B4 80 EC            [24] 1284 	sjmp	00101$
      0003B6                       1285 00118$:
      0003B6 7B 00            [12] 1286 	mov	r3,#0x00
      0003B8                       1287 00110$:
                                   1288 ;	uart.h:192: recv=UartRead();
      0003B8 C0 04            [24] 1289 	push	ar4
      0003BA C0 03            [24] 1290 	push	ar3
      0003BC 12r00r8C         [24] 1291 	lcall	_UartRead
                                   1292 ;	uart.h:193: UartWrite(recv);
      0003BF AA 82            [24] 1293 	mov  r2,dpl
      0003C1 C0 02            [24] 1294 	push	ar2
      0003C3 12r00r95         [24] 1295 	lcall	_UartWrite
      0003C6 D0 02            [24] 1296 	pop	ar2
      0003C8 D0 03            [24] 1297 	pop	ar3
      0003CA D0 04            [24] 1298 	pop	ar4
                                   1299 ;	uart.h:194: if(recv == '\n') 
      0003CC BA 0A 19         [24] 1300 	cjne	r2,#0x0a,00105$
                                   1301 ;	uart.h:196: *(dst+count)=0; //add string terminate
      0003CF A8*00            [24] 1302 	mov	r0,_bp
      0003D1 08               [12] 1303 	inc	r0
      0003D2 EC               [12] 1304 	mov	a,r4
      0003D3 26               [12] 1305 	add	a,@r0
      0003D4 FD               [12] 1306 	mov	r5,a
      0003D5 E4               [12] 1307 	clr	a
      0003D6 08               [12] 1308 	inc	r0
      0003D7 36               [12] 1309 	addc	a,@r0
      0003D8 FE               [12] 1310 	mov	r6,a
      0003D9 08               [12] 1311 	inc	r0
      0003DA 86 07            [24] 1312 	mov	ar7,@r0
      0003DC 8D 82            [24] 1313 	mov	dpl,r5
      0003DE 8E 83            [24] 1314 	mov	dph,r6
      0003E0 8F F0            [24] 1315 	mov	b,r7
      0003E2 E4               [12] 1316 	clr	a
      0003E3 12r00r00         [24] 1317 	lcall	__gptrput
                                   1318 ;	uart.h:197: break;
      0003E6 80 31            [24] 1319 	sjmp	00111$
      0003E8                       1320 00105$:
                                   1321 ;	uart.h:199: else *(dst+count)=recv;
      0003E8 A8*00            [24] 1322 	mov	r0,_bp
      0003EA 08               [12] 1323 	inc	r0
      0003EB EB               [12] 1324 	mov	a,r3
      0003EC 26               [12] 1325 	add	a,@r0
      0003ED FD               [12] 1326 	mov	r5,a
      0003EE E4               [12] 1327 	clr	a
      0003EF 08               [12] 1328 	inc	r0
      0003F0 36               [12] 1329 	addc	a,@r0
      0003F1 FE               [12] 1330 	mov	r6,a
      0003F2 08               [12] 1331 	inc	r0
      0003F3 86 07            [24] 1332 	mov	ar7,@r0
      0003F5 8D 82            [24] 1333 	mov	dpl,r5
      0003F7 8E 83            [24] 1334 	mov	dph,r6
      0003F9 8F F0            [24] 1335 	mov	b,r7
      0003FB EA               [12] 1336 	mov	a,r2
      0003FC 12r00r00         [24] 1337 	lcall	__gptrput
                                   1338 ;	uart.h:201: if(count==maxLength) 
      0003FF E5*00            [12] 1339 	mov	a,_bp
      000401 24 FD            [12] 1340 	add	a,#0xfd
      000403 F8               [12] 1341 	mov	r0,a
      000404 E6               [12] 1342 	mov	a,@r0
      000405 B5 03 0C         [24] 1343 	cjne	a,ar3,00108$
                                   1344 ;	uart.h:203: *(dst+count)=0; // terminate string.
      000408 8D 82            [24] 1345 	mov	dpl,r5
      00040A 8E 83            [24] 1346 	mov	dph,r6
      00040C 8F F0            [24] 1347 	mov	b,r7
      00040E E4               [12] 1348 	clr	a
      00040F 12r00r00         [24] 1349 	lcall	__gptrput
                                   1350 ;	uart.h:204: break;
      000412 80 05            [24] 1351 	sjmp	00111$
      000414                       1352 00108$:
                                   1353 ;	uart.h:207: count++;
      000414 0B               [12] 1354 	inc	r3
      000415 8B 04            [24] 1355 	mov	ar4,r3
      000417 80 9F            [24] 1356 	sjmp	00110$
      000419                       1357 00111$:
                                   1358 ;	uart.h:211: return count;
      000419 8C 82            [24] 1359 	mov	dpl,r4
                                   1360 ;	uart.h:213: }
      00041B 85*00 81         [24] 1361 	mov	sp,_bp
      00041E D0*00            [24] 1362 	pop	_bp
      000420 22               [24] 1363 	ret
                                   1364 ;------------------------------------------------------------
                                   1365 ;Allocation info for local variables in function 'spi_init'
                                   1366 ;------------------------------------------------------------
                                   1367 ;	spi.h:38: void spi_init()
                                   1368 ;	-----------------------------------------
                                   1369 ;	 function spi_init
                                   1370 ;	-----------------------------------------
      000421                       1371 _spi_init:
                                   1372 ;	spi.h:41: spi_miso_high(); //make MISO input
      000421 43 90 01         [24] 1373 	orl	_P1,#0x01
                                   1374 ;	spi.h:42: spi_mosi_high(); //recommended in sd card tutorial
      000424 43 90 02         [24] 1375 	orl	_P1,#0x02
                                   1376 ;	spi.h:43: spi_cs_high(); //deselect
      000427 43 90 08         [24] 1377 	orl	_P1,#0x08
                                   1378 ;	spi.h:44: spi_clk_low(); //mode 0, idle clk is low
      00042A 53 90 FB         [24] 1379 	anl	_P1,#0xfb
                                   1380 ;	spi.h:45: }
      00042D 22               [24] 1381 	ret
                                   1382 ;------------------------------------------------------------
                                   1383 ;Allocation info for local variables in function 'spi_transfer'
                                   1384 ;------------------------------------------------------------
                                   1385 ;handle_cs                 Allocated with name '_spi_transfer_PARM_2'
                                   1386 ;tx                        Allocated to registers r7 
                                   1387 ;rx                        Allocated to registers r6 
                                   1388 ;i                         Allocated to registers r5 
                                   1389 ;------------------------------------------------------------
                                   1390 ;	spi.h:47: uint8_t spi_transfer(uint8_t tx,uint8_t handle_cs)
                                   1391 ;	-----------------------------------------
                                   1392 ;	 function spi_transfer
                                   1393 ;	-----------------------------------------
      00042E                       1394 _spi_transfer:
      00042E AF 82            [24] 1395 	mov	r7,dpl
                                   1396 ;	spi.h:50: rx=0; //clear the rx - sdcc compiler throws warning otherwise
      000430 7E 00            [12] 1397 	mov	r6,#0x00
                                   1398 ;	spi.h:53: spi_clk_low();
      000432 53 90 FB         [24] 1399 	anl	_P1,#0xfb
                                   1400 ;	spi.h:56: if(handle_cs)
      000435 E5*00            [12] 1401 	mov	a,_spi_transfer_PARM_2
      000437 60 03            [24] 1402 	jz	00139$
                                   1403 ;	spi.h:57: spi_cs_low();
      000439 53 90 F7         [24] 1404 	anl	_P1,#0xf7
                                   1405 ;	spi.h:60: for(i=0;i<8;i++)
      00043C                       1406 00139$:
      00043C 7D 00            [12] 1407 	mov	r5,#0x00
      00043E                       1408 00132$:
                                   1409 ;	spi.h:63: if(tx & 0x80) spi_mosi_high();
      00043E EF               [12] 1410 	mov	a,r7
      00043F 30 E7 05         [24] 1411 	jnb	acc.7,00112$
      000442 43 90 02         [24] 1412 	orl	_P1,#0x02
                                   1413 ;	spi.h:64: else spi_mosi_low();
      000445 80 03            [24] 1414 	sjmp	00117$
      000447                       1415 00112$:
      000447 53 90 FD         [24] 1416 	anl	_P1,#0xfd
      00044A                       1417 00117$:
                                   1418 ;	spi.h:66: tx <<=1;
      00044A 8F 04            [24] 1419 	mov	ar4,r7
      00044C EC               [12] 1420 	mov	a,r4
      00044D 2C               [12] 1421 	add	a,r4
      00044E FF               [12] 1422 	mov	r7,a
                                   1423 ;	spi.h:71: rx <<=1;
      00044F 8E 04            [24] 1424 	mov	ar4,r6
      000451 EC               [12] 1425 	mov	a,r4
      000452 2C               [12] 1426 	add	a,r4
      000453 FE               [12] 1427 	mov	r6,a
                                   1428 ;	spi.h:74: spi_clk_high();
      000454 43 90 04         [24] 1429 	orl	_P1,#0x04
                                   1430 ;	spi.h:77: if(spi_read_miso()) rx |=1;
      000457 E5 90            [12] 1431 	mov	a,_P1
      000459 30 E0 03         [24] 1432 	jnb	acc.0,00123$
      00045C 43 06 01         [24] 1433 	orl	ar6,#0x01
                                   1434 ;	spi.h:82: spi_clk_low();
      00045F                       1435 00123$:
      00045F 53 90 FB         [24] 1436 	anl	_P1,#0xfb
                                   1437 ;	spi.h:60: for(i=0;i<8;i++)
      000462 0D               [12] 1438 	inc	r5
      000463 BD 08 00         [24] 1439 	cjne	r5,#0x08,00164$
      000466                       1440 00164$:
      000466 40 D6            [24] 1441 	jc	00132$
                                   1442 ;	spi.h:87: if(handle_cs)
      000468 E5*00            [12] 1443 	mov	a,_spi_transfer_PARM_2
      00046A 60 03            [24] 1444 	jz	00131$
                                   1445 ;	spi.h:88: spi_cs_high();
      00046C 43 90 08         [24] 1446 	orl	_P1,#0x08
      00046F                       1447 00131$:
                                   1448 ;	spi.h:90: return rx;
      00046F 8E 82            [24] 1449 	mov	dpl,r6
                                   1450 ;	spi.h:91: }
      000471 22               [24] 1451 	ret
                                   1452 ;------------------------------------------------------------
                                   1453 ;Allocation info for local variables in function 'spi_transfer_all'
                                   1454 ;------------------------------------------------------------
                                   1455 ;len                       Allocated with name '_spi_transfer_all_PARM_2'
                                   1456 ;handle_cs                 Allocated with name '_spi_transfer_all_PARM_3'
                                   1457 ;buff                      Allocated to registers r5 r6 r7 
                                   1458 ;i                         Allocated to registers r4 
                                   1459 ;------------------------------------------------------------
                                   1460 ;	spi.h:95: void spi_transfer_all(uint8_t *buff, uint8_t len,uint8_t handle_cs)
                                   1461 ;	-----------------------------------------
                                   1462 ;	 function spi_transfer_all
                                   1463 ;	-----------------------------------------
      000472                       1464 _spi_transfer_all:
      000472 AD 82            [24] 1465 	mov	r5,dpl
      000474 AE 83            [24] 1466 	mov	r6,dph
      000476 AF F0            [24] 1467 	mov	r7,b
                                   1468 ;	spi.h:100: if(handle_cs)spi_cs_low();
      000478 E5*04            [12] 1469 	mov	a,_spi_transfer_all_PARM_3
      00047A 60 03            [24] 1470 	jz	00119$
      00047C 53 90 F7         [24] 1471 	anl	_P1,#0xf7
                                   1472 ;	spi.h:102: for(i=0;i<len;i++)
      00047F                       1473 00119$:
      00047F 7C 00            [12] 1474 	mov	r4,#0x00
      000481                       1475 00113$:
      000481 C3               [12] 1476 	clr	c
      000482 EC               [12] 1477 	mov	a,r4
      000483 95*03            [12] 1478 	subb	a,_spi_transfer_all_PARM_2
      000485 50 2D            [24] 1479 	jnc	00106$
                                   1480 ;	spi.h:104: spi_transfer(buff[i],0);
      000487 EC               [12] 1481 	mov	a,r4
      000488 2D               [12] 1482 	add	a,r5
      000489 F9               [12] 1483 	mov	r1,a
      00048A E4               [12] 1484 	clr	a
      00048B 3E               [12] 1485 	addc	a,r6
      00048C FA               [12] 1486 	mov	r2,a
      00048D 8F 03            [24] 1487 	mov	ar3,r7
      00048F 89 82            [24] 1488 	mov	dpl,r1
      000491 8A 83            [24] 1489 	mov	dph,r2
      000493 8B F0            [24] 1490 	mov	b,r3
      000495 12r00r00         [24] 1491 	lcall	__gptrget
      000498 F9               [12] 1492 	mov	r1,a
      000499 75*00 00         [24] 1493 	mov	_spi_transfer_PARM_2,#0x00
      00049C 89 82            [24] 1494 	mov	dpl,r1
      00049E C0 07            [24] 1495 	push	ar7
      0004A0 C0 06            [24] 1496 	push	ar6
      0004A2 C0 05            [24] 1497 	push	ar5
      0004A4 C0 04            [24] 1498 	push	ar4
      0004A6 12r04r2E         [24] 1499 	lcall	_spi_transfer
      0004A9 D0 04            [24] 1500 	pop	ar4
      0004AB D0 05            [24] 1501 	pop	ar5
      0004AD D0 06            [24] 1502 	pop	ar6
      0004AF D0 07            [24] 1503 	pop	ar7
                                   1504 ;	spi.h:102: for(i=0;i<len;i++)
      0004B1 0C               [12] 1505 	inc	r4
      0004B2 80 CD            [24] 1506 	sjmp	00113$
      0004B4                       1507 00106$:
                                   1508 ;	spi.h:108: if(handle_cs)spi_cs_high();
      0004B4 E5*04            [12] 1509 	mov	a,_spi_transfer_all_PARM_3
      0004B6 60 03            [24] 1510 	jz	00115$
      0004B8 43 90 08         [24] 1511 	orl	_P1,#0x08
      0004BB                       1512 00115$:
                                   1513 ;	spi.h:110: }
      0004BB 22               [24] 1514 	ret
                                   1515 ;------------------------------------------------------------
                                   1516 ;Allocation info for local variables in function 'sd_isbusy'
                                   1517 ;------------------------------------------------------------
                                   1518 ;i                         Allocated to registers r7 
                                   1519 ;------------------------------------------------------------
                                   1520 ;	sdcard.h:26: uint8_t sd_isbusy()
                                   1521 ;	-----------------------------------------
                                   1522 ;	 function sd_isbusy
                                   1523 ;	-----------------------------------------
      0004BC                       1524 _sd_isbusy:
                                   1525 ;	sdcard.h:29: for(i=0;i<254;i++) //could have been anything(100/200/etc.)
      0004BC 7F 00            [12] 1526 	mov	r7,#0x00
      0004BE                       1527 00104$:
                                   1528 ;	sdcard.h:31: if(sd_spi_write(0xff)==0xff) return 0; //not busy
      0004BE 75*00 00         [24] 1529 	mov	_spi_transfer_PARM_2,#0x00
      0004C1 75 82 FF         [24] 1530 	mov	dpl,#0xff
      0004C4 C0 07            [24] 1531 	push	ar7
      0004C6 12r04r2E         [24] 1532 	lcall	_spi_transfer
      0004C9 AE 82            [24] 1533 	mov	r6,dpl
      0004CB D0 07            [24] 1534 	pop	ar7
      0004CD BE FF 04         [24] 1535 	cjne	r6,#0xff,00105$
      0004D0 75 82 00         [24] 1536 	mov	dpl,#0x00
      0004D3 22               [24] 1537 	ret
      0004D4                       1538 00105$:
                                   1539 ;	sdcard.h:29: for(i=0;i<254;i++) //could have been anything(100/200/etc.)
      0004D4 0F               [12] 1540 	inc	r7
      0004D5 BF FE 00         [24] 1541 	cjne	r7,#0xfe,00122$
      0004D8                       1542 00122$:
      0004D8 40 E4            [24] 1543 	jc	00104$
                                   1544 ;	sdcard.h:34: return 1; //busy
      0004DA 75 82 01         [24] 1545 	mov	dpl,#0x01
                                   1546 ;	sdcard.h:35: }
      0004DD 22               [24] 1547 	ret
                                   1548 ;------------------------------------------------------------
                                   1549 ;Allocation info for local variables in function 'sd_initial_clk'
                                   1550 ;------------------------------------------------------------
                                   1551 ;i                         Allocated to registers r7 
                                   1552 ;------------------------------------------------------------
                                   1553 ;	sdcard.h:37: void sd_initial_clk()
                                   1554 ;	-----------------------------------------
                                   1555 ;	 function sd_initial_clk
                                   1556 ;	-----------------------------------------
      0004DE                       1557 _sd_initial_clk:
                                   1558 ;	sdcard.h:45: spi_cs_high(); // required by spec but works fine even when cs pin of SDCARD is always pulled to ground to save uC pins
      0004DE 43 90 08         [24] 1559 	orl	_P1,#0x08
                                   1560 ;	sdcard.h:46: for(uint8_t i=0;i<10;i++)spi_transfer(0xff,0);
      0004E1 7F 00            [12] 1561 	mov	r7,#0x00
      0004E3                       1562 00106$:
      0004E3 BF 0A 00         [24] 1563 	cjne	r7,#0x0a,00119$
      0004E6                       1564 00119$:
      0004E6 50 10            [24] 1565 	jnc	00108$
      0004E8 75*00 00         [24] 1566 	mov	_spi_transfer_PARM_2,#0x00
      0004EB 75 82 FF         [24] 1567 	mov	dpl,#0xff
      0004EE C0 07            [24] 1568 	push	ar7
      0004F0 12r04r2E         [24] 1569 	lcall	_spi_transfer
      0004F3 D0 07            [24] 1570 	pop	ar7
      0004F5 0F               [12] 1571 	inc	r7
      0004F6 80 EB            [24] 1572 	sjmp	00106$
      0004F8                       1573 00108$:
                                   1574 ;	sdcard.h:47: }
      0004F8 22               [24] 1575 	ret
                                   1576 ;------------------------------------------------------------
                                   1577 ;Allocation info for local variables in function 'sd_cmd'
                                   1578 ;------------------------------------------------------------
                                   1579 ;arg                       Allocated with name '_sd_cmd_PARM_2'
                                   1580 ;cmd                       Allocated to registers r7 
                                   1581 ;_resp                     Allocated to registers r5 
                                   1582 ;retries                   Allocated to registers r6 
                                   1583 ;crc                       Allocated to registers r6 
                                   1584 ;i                         Allocated to registers r6 
                                   1585 ;i                         Allocated to registers r7 
                                   1586 ;------------------------------------------------------------
                                   1587 ;	sdcard.h:49: uint8_t sd_cmd(uint8_t cmd, uint32_t arg)
                                   1588 ;	-----------------------------------------
                                   1589 ;	 function sd_cmd
                                   1590 ;	-----------------------------------------
      0004F9                       1591 _sd_cmd:
      0004F9 AF 82            [24] 1592 	mov	r7,dpl
                                   1593 ;	sdcard.h:51: uint8_t _resp=0,retries=0,crc=0xff;
      0004FB 7E FF            [12] 1594 	mov	r6,#0xff
                                   1595 ;	sdcard.h:53: spi_cs_low();
      0004FD 53 90 F7         [24] 1596 	anl	_P1,#0xf7
                                   1597 ;	sdcard.h:55: sd_isbusy(); //wait while sd is busy
      000500 C0 07            [24] 1598 	push	ar7
      000502 C0 06            [24] 1599 	push	ar6
      000504 12r04rBC         [24] 1600 	lcall	_sd_isbusy
      000507 D0 06            [24] 1601 	pop	ar6
      000509 D0 07            [24] 1602 	pop	ar7
                                   1603 ;	sdcard.h:63: sd_spi_write(cmd | 0x40);
      00050B 74 40            [12] 1604 	mov	a,#0x40
      00050D 4F               [12] 1605 	orl	a,r7
      00050E F5 82            [12] 1606 	mov	dpl,a
      000510 75*00 00         [24] 1607 	mov	_spi_transfer_PARM_2,#0x00
      000513 C0 07            [24] 1608 	push	ar7
      000515 C0 06            [24] 1609 	push	ar6
      000517 12r04r2E         [24] 1610 	lcall	_spi_transfer
      00051A D0 06            [24] 1611 	pop	ar6
      00051C D0 07            [24] 1612 	pop	ar7
                                   1613 ;	sdcard.h:65: sd_spi_write((arg >> 24) & 0xff);
      00051E 85*08 82         [24] 1614 	mov	dpl,(_sd_cmd_PARM_2 + 3)
      000521 75*00 00         [24] 1615 	mov	_spi_transfer_PARM_2,#0x00
      000524 C0 07            [24] 1616 	push	ar7
      000526 C0 06            [24] 1617 	push	ar6
      000528 12r04r2E         [24] 1618 	lcall	_spi_transfer
      00052B D0 06            [24] 1619 	pop	ar6
      00052D D0 07            [24] 1620 	pop	ar7
                                   1621 ;	sdcard.h:66: sd_spi_write((arg >> 16) & 0xff);
      00052F 85*07 82         [24] 1622 	mov	dpl,(_sd_cmd_PARM_2 + 2)
      000532 75*00 00         [24] 1623 	mov	_spi_transfer_PARM_2,#0x00
      000535 C0 07            [24] 1624 	push	ar7
      000537 C0 06            [24] 1625 	push	ar6
      000539 12r04r2E         [24] 1626 	lcall	_spi_transfer
      00053C D0 06            [24] 1627 	pop	ar6
      00053E D0 07            [24] 1628 	pop	ar7
                                   1629 ;	sdcard.h:67: sd_spi_write((arg >> 8) & 0xff);
      000540 85*06 82         [24] 1630 	mov	dpl,(_sd_cmd_PARM_2 + 1)
      000543 75*00 00         [24] 1631 	mov	_spi_transfer_PARM_2,#0x00
      000546 C0 07            [24] 1632 	push	ar7
      000548 C0 06            [24] 1633 	push	ar6
      00054A 12r04r2E         [24] 1634 	lcall	_spi_transfer
      00054D D0 06            [24] 1635 	pop	ar6
      00054F D0 07            [24] 1636 	pop	ar7
                                   1637 ;	sdcard.h:68: sd_spi_write(arg & 0xff);
      000551 85*05 82         [24] 1638 	mov	dpl,_sd_cmd_PARM_2
      000554 75*00 00         [24] 1639 	mov	_spi_transfer_PARM_2,#0x00
      000557 C0 07            [24] 1640 	push	ar7
      000559 C0 06            [24] 1641 	push	ar6
      00055B 12r04r2E         [24] 1642 	lcall	_spi_transfer
      00055E D0 06            [24] 1643 	pop	ar6
      000560 D0 07            [24] 1644 	pop	ar7
                                   1645 ;	sdcard.h:70: if(cmd==CMD0) 
      000562 EF               [12] 1646 	mov	a,r7
      000563 70 04            [24] 1647 	jnz	00107$
                                   1648 ;	sdcard.h:72: crc=0x95;
      000565 7E 95            [12] 1649 	mov	r6,#0x95
      000567 80 05            [24] 1650 	sjmp	00108$
      000569                       1651 00107$:
                                   1652 ;	sdcard.h:74: else if(cmd==CMD8) 
      000569 BF 08 02         [24] 1653 	cjne	r7,#0x08,00108$
                                   1654 ;	sdcard.h:76: crc=0x87;
      00056C 7E 87            [12] 1655 	mov	r6,#0x87
      00056E                       1656 00108$:
                                   1657 ;	sdcard.h:78: sd_spi_write(crc);	
      00056E 75*00 00         [24] 1658 	mov	_spi_transfer_PARM_2,#0x00
      000571 8E 82            [24] 1659 	mov	dpl,r6
      000573 C0 07            [24] 1660 	push	ar7
      000575 12r04r2E         [24] 1661 	lcall	_spi_transfer
      000578 D0 07            [24] 1662 	pop	ar7
                                   1663 ;	sdcard.h:81: while(1) 
      00057A 7E 00            [12] 1664 	mov	r6,#0x00
      00057C                       1665 00115$:
                                   1666 ;	sdcard.h:83: _resp = sd_spi_write(0xff);
      00057C 75*00 00         [24] 1667 	mov	_spi_transfer_PARM_2,#0x00
      00057F 75 82 FF         [24] 1668 	mov	dpl,#0xff
      000582 C0 07            [24] 1669 	push	ar7
      000584 C0 06            [24] 1670 	push	ar6
      000586 12r04r2E         [24] 1671 	lcall	_spi_transfer
      000589 AD 82            [24] 1672 	mov	r5,dpl
      00058B D0 06            [24] 1673 	pop	ar6
      00058D D0 07            [24] 1674 	pop	ar7
                                   1675 ;	sdcard.h:85: if(_resp & 0x80);
      00058F ED               [12] 1676 	mov	a,r5
      000590 30 E7 0A         [24] 1677 	jnb	acc.7,00116$
                                   1678 ;	sdcard.h:88: if(retries++ == SD_MAX_RETRIES) 
      000593 8E 04            [24] 1679 	mov	ar4,r6
      000595 0E               [12] 1680 	inc	r6
      000596 BC 19 E3         [24] 1681 	cjne	r4,#0x19,00115$
                                   1682 ;	sdcard.h:94: return SD_MAX_RETRIES_FAIL; // 0xff means failed
      000599 75 82 FE         [24] 1683 	mov	dpl,#0xfe
      00059C 22               [24] 1684 	ret
      00059D                       1685 00116$:
                                   1686 ;	sdcard.h:106: if(cmd==CMD8 || cmd==CMD58)
      00059D E4               [12] 1687 	clr	a
      00059E BF 08 01         [24] 1688 	cjne	r7,#0x08,00203$
      0005A1 04               [12] 1689 	inc	a
      0005A2                       1690 00203$:
      0005A2 FE               [12] 1691 	mov	r6,a
      0005A3 70 08            [24] 1692 	jnz	00128$
      0005A5 BF 3A 02         [24] 1693 	cjne	r7,#0x3a,00206$
      0005A8 80 03            [24] 1694 	sjmp	00207$
      0005AA                       1695 00206$:
      0005AA 02r06r26         [24] 1696 	ljmp	00129$
      0005AD                       1697 00207$:
      0005AD                       1698 00128$:
                                   1699 ;	sdcard.h:114: if(cmd==CMD8)
      0005AD EE               [12] 1700 	mov	a,r6
      0005AE 60 33            [24] 1701 	jz	00126$
                                   1702 ;	sdcard.h:116: for(uint8_t i=0;i<3;i++) sd_spi_write(0xff);//waste the 3 bytes
      0005B0 7E 00            [12] 1703 	mov	r6,#0x00
      0005B2                       1704 00132$:
      0005B2 BE 03 00         [24] 1705 	cjne	r6,#0x03,00209$
      0005B5                       1706 00209$:
      0005B5 50 14            [24] 1707 	jnc	00117$
      0005B7 75*00 00         [24] 1708 	mov	_spi_transfer_PARM_2,#0x00
      0005BA 75 82 FF         [24] 1709 	mov	dpl,#0xff
      0005BD C0 06            [24] 1710 	push	ar6
      0005BF C0 05            [24] 1711 	push	ar5
      0005C1 12r04r2E         [24] 1712 	lcall	_spi_transfer
      0005C4 D0 05            [24] 1713 	pop	ar5
      0005C6 D0 06            [24] 1714 	pop	ar6
      0005C8 0E               [12] 1715 	inc	r6
      0005C9 80 E7            [24] 1716 	sjmp	00132$
      0005CB                       1717 00117$:
                                   1718 ;	sdcard.h:117: if(sd_spi_write(0xff)!=0xAA) return SD_CMD_FAIL;
      0005CB 75*00 00         [24] 1719 	mov	_spi_transfer_PARM_2,#0x00
      0005CE 75 82 FF         [24] 1720 	mov	dpl,#0xff
      0005D1 C0 05            [24] 1721 	push	ar5
      0005D3 12r04r2E         [24] 1722 	lcall	_spi_transfer
      0005D6 AE 82            [24] 1723 	mov	r6,dpl
      0005D8 D0 05            [24] 1724 	pop	ar5
      0005DA BE AA 02         [24] 1725 	cjne	r6,#0xaa,00211$
      0005DD 80 3A            [24] 1726 	sjmp	00127$
      0005DF                       1727 00211$:
      0005DF 75 82 FF         [24] 1728 	mov	dpl,#0xff
      0005E2 22               [24] 1729 	ret
      0005E3                       1730 00126$:
                                   1731 ;	sdcard.h:119: else if(cmd==CMD58)
      0005E3 BF 3A 33         [24] 1732 	cjne	r7,#0x3a,00127$
                                   1733 ;	sdcard.h:121: if(sd_spi_write(0xff)!=0xC0) return SD_CMD_FAIL;
      0005E6 75*00 00         [24] 1734 	mov	_spi_transfer_PARM_2,#0x00
      0005E9 75 82 FF         [24] 1735 	mov	dpl,#0xff
      0005EC C0 05            [24] 1736 	push	ar5
      0005EE 12r04r2E         [24] 1737 	lcall	_spi_transfer
      0005F1 AF 82            [24] 1738 	mov	r7,dpl
      0005F3 D0 05            [24] 1739 	pop	ar5
      0005F5 BF C0 02         [24] 1740 	cjne	r7,#0xc0,00214$
      0005F8 80 04            [24] 1741 	sjmp	00152$
      0005FA                       1742 00214$:
      0005FA 75 82 FF         [24] 1743 	mov	dpl,#0xff
                                   1744 ;	sdcard.h:123: for(uint8_t i=0;i<3;i++) sd_spi_write(0xff);//waste the 3 bytes
      0005FD 22               [24] 1745 	ret
      0005FE                       1746 00152$:
      0005FE 7F 00            [12] 1747 	mov	r7,#0x00
      000600                       1748 00135$:
      000600 BF 03 00         [24] 1749 	cjne	r7,#0x03,00215$
      000603                       1750 00215$:
      000603 50 14            [24] 1751 	jnc	00127$
      000605 75*00 00         [24] 1752 	mov	_spi_transfer_PARM_2,#0x00
      000608 75 82 FF         [24] 1753 	mov	dpl,#0xff
      00060B C0 07            [24] 1754 	push	ar7
      00060D C0 05            [24] 1755 	push	ar5
      00060F 12r04r2E         [24] 1756 	lcall	_spi_transfer
      000612 D0 05            [24] 1757 	pop	ar5
      000614 D0 07            [24] 1758 	pop	ar7
      000616 0F               [12] 1759 	inc	r7
      000617 80 E7            [24] 1760 	sjmp	00135$
      000619                       1761 00127$:
                                   1762 ;	sdcard.h:128: sd_spi_write(0xff);
      000619 75*00 00         [24] 1763 	mov	_spi_transfer_PARM_2,#0x00
      00061C 75 82 FF         [24] 1764 	mov	dpl,#0xff
      00061F C0 05            [24] 1765 	push	ar5
      000621 12r04r2E         [24] 1766 	lcall	_spi_transfer
      000624 D0 05            [24] 1767 	pop	ar5
      000626                       1768 00129$:
                                   1769 ;	sdcard.h:136: return _resp;
      000626 8D 82            [24] 1770 	mov	dpl,r5
                                   1771 ;	sdcard.h:138: }
      000628 22               [24] 1772 	ret
                                   1773 ;------------------------------------------------------------
                                   1774 ;Allocation info for local variables in function 'sd_acmd'
                                   1775 ;------------------------------------------------------------
                                   1776 ;arg                       Allocated with name '_sd_acmd_PARM_2'
                                   1777 ;cmd                       Allocated to registers r7 
                                   1778 ;_resp                     Allocated to registers 
                                   1779 ;------------------------------------------------------------
                                   1780 ;	sdcard.h:140: uint8_t sd_acmd(uint8_t cmd, uint32_t arg)
                                   1781 ;	-----------------------------------------
                                   1782 ;	 function sd_acmd
                                   1783 ;	-----------------------------------------
      000629                       1784 _sd_acmd:
      000629 AF 82            [24] 1785 	mov	r7,dpl
                                   1786 ;	sdcard.h:144: _resp=sd_cmd(CMD55,0);
      00062B E4               [12] 1787 	clr	a
      00062C F5*05            [12] 1788 	mov	_sd_cmd_PARM_2,a
      00062E F5*06            [12] 1789 	mov	(_sd_cmd_PARM_2 + 1),a
      000630 F5*07            [12] 1790 	mov	(_sd_cmd_PARM_2 + 2),a
      000632 F5*08            [12] 1791 	mov	(_sd_cmd_PARM_2 + 3),a
      000634 75 82 37         [24] 1792 	mov	dpl,#0x37
      000637 C0 07            [24] 1793 	push	ar7
      000639 12r04rF9         [24] 1794 	lcall	_sd_cmd
      00063C AE 82            [24] 1795 	mov	r6,dpl
      00063E D0 07            [24] 1796 	pop	ar7
                                   1797 ;	sdcard.h:145: if(_resp!=1) return SD_CMD_FAIL;
      000640 BE 01 02         [24] 1798 	cjne	r6,#0x01,00110$
      000643 80 04            [24] 1799 	sjmp	00102$
      000645                       1800 00110$:
      000645 75 82 FF         [24] 1801 	mov	dpl,#0xff
      000648 22               [24] 1802 	ret
      000649                       1803 00102$:
                                   1804 ;	sdcard.h:148: _resp=sd_cmd(cmd,arg);
      000649 85*09*05         [24] 1805 	mov	_sd_cmd_PARM_2,_sd_acmd_PARM_2
      00064C 85*0A*06         [24] 1806 	mov	(_sd_cmd_PARM_2 + 1),(_sd_acmd_PARM_2 + 1)
      00064F 85*0B*07         [24] 1807 	mov	(_sd_cmd_PARM_2 + 2),(_sd_acmd_PARM_2 + 2)
      000652 85*0C*08         [24] 1808 	mov	(_sd_cmd_PARM_2 + 3),(_sd_acmd_PARM_2 + 3)
      000655 8F 82            [24] 1809 	mov	dpl,r7
                                   1810 ;	sdcard.h:149: return _resp;
                                   1811 ;	sdcard.h:151: }
      000657 02r04rF9         [24] 1812 	ljmp	_sd_cmd
                                   1813 ;------------------------------------------------------------
                                   1814 ;Allocation info for local variables in function 'SDinit'
                                   1815 ;------------------------------------------------------------
                                   1816 ;retries                   Allocated to registers r7 
                                   1817 ;------------------------------------------------------------
                                   1818 ;	sdcard.h:157: uint8_t SDinit()
                                   1819 ;	-----------------------------------------
                                   1820 ;	 function SDinit
                                   1821 ;	-----------------------------------------
      00065A                       1822 _SDinit:
                                   1823 ;	sdcard.h:161: sd_initial_clk(); // 74 minimum clks for initialization
      00065A 12r04rDE         [24] 1824 	lcall	_sd_initial_clk
                                   1825 ;	sdcard.h:163: while(1)
      00065D 7F 00            [12] 1826 	mov	r7,#0x00
      00065F                       1827 00107$:
                                   1828 ;	sdcard.h:165: if(sd_cmd(CMD0,0)==0x01)break; // correct response is 0x01 -> signals card is idling
      00065F E4               [12] 1829 	clr	a
      000660 F5*05            [12] 1830 	mov	_sd_cmd_PARM_2,a
      000662 F5*06            [12] 1831 	mov	(_sd_cmd_PARM_2 + 1),a
      000664 F5*07            [12] 1832 	mov	(_sd_cmd_PARM_2 + 2),a
      000666 F5*08            [12] 1833 	mov	(_sd_cmd_PARM_2 + 3),a
      000668 75 82 00         [24] 1834 	mov	dpl,#0x00
      00066B C0 07            [24] 1835 	push	ar7
      00066D 12r04rF9         [24] 1836 	lcall	_sd_cmd
      000670 AE 82            [24] 1837 	mov	r6,dpl
      000672 D0 07            [24] 1838 	pop	ar7
      000674 BE 01 02         [24] 1839 	cjne	r6,#0x01,00155$
      000677 80 0A            [24] 1840 	sjmp	00108$
      000679                       1841 00155$:
                                   1842 ;	sdcard.h:166: else if(retries++==SD_MAX_RETRIES) return SD_MAX_RETRIES_FAIL;
      000679 8F 06            [24] 1843 	mov	ar6,r7
      00067B 0F               [12] 1844 	inc	r7
      00067C BE 19 E0         [24] 1845 	cjne	r6,#0x19,00107$
      00067F 75 82 FE         [24] 1846 	mov	dpl,#0xfe
      000682 22               [24] 1847 	ret
      000683                       1848 00108$:
                                   1849 ;	sdcard.h:170: if(sd_cmd(CMD8,0x1AA)!=0x01) return SD_CMD_FAIL; // correct response for cmd8 is 0x01
      000683 75*05 AA         [24] 1850 	mov	_sd_cmd_PARM_2,#0xaa
      000686 75*06 01         [24] 1851 	mov	(_sd_cmd_PARM_2 + 1),#0x01
      000689 E4               [12] 1852 	clr	a
      00068A F5*07            [12] 1853 	mov	(_sd_cmd_PARM_2 + 2),a
      00068C F5*08            [12] 1854 	mov	(_sd_cmd_PARM_2 + 3),a
      00068E 75 82 08         [24] 1855 	mov	dpl,#0x08
      000691 12r04rF9         [24] 1856 	lcall	_sd_cmd
      000694 AF 82            [24] 1857 	mov	r7,dpl
      000696 BF 01 02         [24] 1858 	cjne	r7,#0x01,00158$
      000699 80 04            [24] 1859 	sjmp	00128$
      00069B                       1860 00158$:
      00069B 75 82 FF         [24] 1861 	mov	dpl,#0xff
                                   1862 ;	sdcard.h:173: while(1)
      00069E 22               [24] 1863 	ret
      00069F                       1864 00128$:
      00069F 7F 00            [12] 1865 	mov	r7,#0x00
      0006A1                       1866 00117$:
                                   1867 ;	sdcard.h:175: if(sd_acmd(CMD41,0x40000000)==0)break; //correct response
      0006A1 E4               [12] 1868 	clr	a
      0006A2 F5*09            [12] 1869 	mov	_sd_acmd_PARM_2,a
      0006A4 F5*0A            [12] 1870 	mov	(_sd_acmd_PARM_2 + 1),a
      0006A6 F5*0B            [12] 1871 	mov	(_sd_acmd_PARM_2 + 2),a
      0006A8 75*0C 40         [24] 1872 	mov	(_sd_acmd_PARM_2 + 3),#0x40
      0006AB 75 82 29         [24] 1873 	mov	dpl,#0x29
      0006AE C0 07            [24] 1874 	push	ar7
      0006B0 12r06r29         [24] 1875 	lcall	_sd_acmd
      0006B3 E5 82            [12] 1876 	mov	a,dpl
      0006B5 D0 07            [24] 1877 	pop	ar7
      0006B7 60 0A            [24] 1878 	jz	00118$
                                   1879 ;	sdcard.h:176: else if(retries++==SD_MAX_RETRIES) return SD_MAX_RETRIES_FAIL;
      0006B9 8F 06            [24] 1880 	mov	ar6,r7
      0006BB 0F               [12] 1881 	inc	r7
      0006BC BE 19 E2         [24] 1882 	cjne	r6,#0x19,00117$
      0006BF 75 82 FE         [24] 1883 	mov	dpl,#0xfe
      0006C2 22               [24] 1884 	ret
      0006C3                       1885 00118$:
                                   1886 ;	sdcard.h:182: if(sd_cmd(CMD58,0)) return SD_CMD_FAIL;  
      0006C3 E4               [12] 1887 	clr	a
      0006C4 F5*05            [12] 1888 	mov	_sd_cmd_PARM_2,a
      0006C6 F5*06            [12] 1889 	mov	(_sd_cmd_PARM_2 + 1),a
      0006C8 F5*07            [12] 1890 	mov	(_sd_cmd_PARM_2 + 2),a
      0006CA F5*08            [12] 1891 	mov	(_sd_cmd_PARM_2 + 3),a
      0006CC 75 82 3A         [24] 1892 	mov	dpl,#0x3a
      0006CF 12r04rF9         [24] 1893 	lcall	_sd_cmd
      0006D2 E5 82            [12] 1894 	mov	a,dpl
      0006D4 60 04            [24] 1895 	jz	00120$
      0006D6 75 82 FF         [24] 1896 	mov	dpl,#0xff
      0006D9 22               [24] 1897 	ret
      0006DA                       1898 00120$:
                                   1899 ;	sdcard.h:190: return 0; //successful init
      0006DA 75 82 00         [24] 1900 	mov	dpl,#0x00
                                   1901 ;	sdcard.h:191: }
      0006DD 22               [24] 1902 	ret
                                   1903 ;------------------------------------------------------------
                                   1904 ;Allocation info for local variables in function 'SDread'
                                   1905 ;------------------------------------------------------------
                                   1906 ;offset                    Allocated to stack - _bp -4
                                   1907 ;count                     Allocated to stack - _bp -6
                                   1908 ;dst                       Allocated to stack - _bp -9
                                   1909 ;block_addr                Allocated to registers r4 r5 r6 r7 
                                   1910 ;retries                   Allocated to registers r7 
                                   1911 ;response                  Allocated to registers r3 
                                   1912 ;i                         Allocated to registers r4 r5 
                                   1913 ;------------------------------------------------------------
                                   1914 ;	sdcard.h:206: uint8_t SDread(uint32_t block_addr, uint16_t offset, uint16_t count, uint8_t* dst ) __reentrant
                                   1915 ;	-----------------------------------------
                                   1916 ;	 function SDread
                                   1917 ;	-----------------------------------------
      0006DE                       1918 _SDread:
      0006DE C0*00            [24] 1919 	push	_bp
      0006E0 85 81*00         [24] 1920 	mov	_bp,sp
      0006E3 AC 82            [24] 1921 	mov	r4,dpl
      0006E5 AD 83            [24] 1922 	mov	r5,dph
      0006E7 AE F0            [24] 1923 	mov	r6,b
      0006E9 FF               [12] 1924 	mov	r7,a
                                   1925 ;	sdcard.h:221: if (count == 0) return 0; //success
      0006EA E5*00            [12] 1926 	mov	a,_bp
      0006EC 24 FA            [12] 1927 	add	a,#0xfa
      0006EE F8               [12] 1928 	mov	r0,a
      0006EF E6               [12] 1929 	mov	a,@r0
      0006F0 08               [12] 1930 	inc	r0
      0006F1 46               [12] 1931 	orl	a,@r0
      0006F2 70 05            [24] 1932 	jnz	00102$
      0006F4 F5 82            [12] 1933 	mov	dpl,a
      0006F6 02r07rF7         [24] 1934 	ljmp	00131$
      0006F9                       1935 00102$:
                                   1936 ;	sdcard.h:222: if ((count + offset) > SD_BLOCK_SIZE) {
      0006F9 E5*00            [12] 1937 	mov	a,_bp
      0006FB 24 FA            [12] 1938 	add	a,#0xfa
      0006FD F8               [12] 1939 	mov	r0,a
      0006FE E5*00            [12] 1940 	mov	a,_bp
      000700 24 FC            [12] 1941 	add	a,#0xfc
      000702 F9               [12] 1942 	mov	r1,a
      000703 E7               [12] 1943 	mov	a,@r1
      000704 26               [12] 1944 	add	a,@r0
      000705 FA               [12] 1945 	mov	r2,a
      000706 09               [12] 1946 	inc	r1
      000707 E7               [12] 1947 	mov	a,@r1
      000708 08               [12] 1948 	inc	r0
      000709 36               [12] 1949 	addc	a,@r0
      00070A FB               [12] 1950 	mov	r3,a
      00070B C3               [12] 1951 	clr	c
      00070C E4               [12] 1952 	clr	a
      00070D 9A               [12] 1953 	subb	a,r2
      00070E 74 02            [12] 1954 	mov	a,#0x02
      000710 9B               [12] 1955 	subb	a,r3
      000711 50 06            [24] 1956 	jnc	00105$
                                   1957 ;	sdcard.h:223: return 1; //fail
      000713 75 82 01         [24] 1958 	mov	dpl,#0x01
      000716 02r07rF7         [24] 1959 	ljmp	00131$
                                   1960 ;	sdcard.h:231: spi_cs_low();
      000719                       1961 00105$:
      000719 53 90 F7         [24] 1962 	anl	_P1,#0xf7
                                   1963 ;	sdcard.h:236: if(sd_cmd(CMD17,block_addr)) return SD_CMD_FAIL; 
      00071C 8C*05            [24] 1964 	mov	_sd_cmd_PARM_2,r4
      00071E 8D*06            [24] 1965 	mov	(_sd_cmd_PARM_2 + 1),r5
      000720 8E*07            [24] 1966 	mov	(_sd_cmd_PARM_2 + 2),r6
      000722 8F*08            [24] 1967 	mov	(_sd_cmd_PARM_2 + 3),r7
      000724 75 82 11         [24] 1968 	mov	dpl,#0x11
      000727 12r04rF9         [24] 1969 	lcall	_sd_cmd
      00072A E5 82            [12] 1970 	mov	a,dpl
      00072C 60 06            [24] 1971 	jz	00138$
      00072E 75 82 FF         [24] 1972 	mov	dpl,#0xff
      000731 02r07rF7         [24] 1973 	ljmp	00131$
                                   1974 ;	sdcard.h:240: while(1)
      000734                       1975 00138$:
      000734 7F 00            [12] 1976 	mov	r7,#0x00
      000736                       1977 00119$:
                                   1978 ;	sdcard.h:242: response = sd_spi_write(0xff);
      000736 75*00 00         [24] 1979 	mov	_spi_transfer_PARM_2,#0x00
      000739 75 82 FF         [24] 1980 	mov	dpl,#0xff
      00073C C0 07            [24] 1981 	push	ar7
      00073E 12r04r2E         [24] 1982 	lcall	_spi_transfer
      000741 AE 82            [24] 1983 	mov	r6,dpl
      000743 D0 07            [24] 1984 	pop	ar7
                                   1985 ;	sdcard.h:250: if(response==0xff); //pass
      000745 BE FF 02         [24] 1986 	cjne	r6,#0xff,00192$
      000748 80 0B            [24] 1987 	sjmp	00115$
      00074A                       1988 00192$:
                                   1989 ;	sdcard.h:251: else if(response == DATA_START_BLOCK) break; // if the last response is DATA_START_BLOCK=0xFE, then success, else fail
      00074A BE FE 02         [24] 1990 	cjne	r6,#0xfe,00193$
      00074D 80 12            [24] 1991 	sjmp	00143$
      00074F                       1992 00193$:
                                   1993 ;	sdcard.h:252: else return DATA_START_BLOCK_FAIL; // if anything other than 0xff or DATA_START_BLOCK=0xFE
      00074F 75 82 FD         [24] 1994 	mov	dpl,#0xfd
      000752 02r07rF7         [24] 1995 	ljmp	00131$
      000755                       1996 00115$:
                                   1997 ;	sdcard.h:254: if(retries++==255) return SD_MAX_RETRIES_FAIL;
      000755 8F 06            [24] 1998 	mov	ar6,r7
      000757 0F               [12] 1999 	inc	r7
      000758 BE FF DB         [24] 2000 	cjne	r6,#0xff,00119$
      00075B 75 82 FE         [24] 2001 	mov	dpl,#0xfe
      00075E 02r07rF7         [24] 2002 	ljmp	00131$
                                   2003 ;	sdcard.h:260: for(uint16_t i=0;i<512;i++)
      000761                       2004 00143$:
      000761 E5*00            [12] 2005 	mov	a,_bp
      000763 24 FC            [12] 2006 	add	a,#0xfc
      000765 F8               [12] 2007 	mov	r0,a
      000766 E5*00            [12] 2008 	mov	a,_bp
      000768 24 FA            [12] 2009 	add	a,#0xfa
      00076A F9               [12] 2010 	mov	r1,a
      00076B E7               [12] 2011 	mov	a,@r1
      00076C 26               [12] 2012 	add	a,@r0
      00076D FE               [12] 2013 	mov	r6,a
      00076E 09               [12] 2014 	inc	r1
      00076F E7               [12] 2015 	mov	a,@r1
      000770 08               [12] 2016 	inc	r0
      000771 36               [12] 2017 	addc	a,@r0
      000772 FF               [12] 2018 	mov	r7,a
      000773 7C 00            [12] 2019 	mov	r4,#0x00
      000775 7D 00            [12] 2020 	mov	r5,#0x00
      000777                       2021 00129$:
      000777 74 FE            [12] 2022 	mov	a,#0x100 - 0x02
      000779 2D               [12] 2023 	add	a,r5
      00077A 40 63            [24] 2024 	jc	00124$
                                   2025 ;	sdcard.h:262: response = spi_transfer(0xff,0);
      00077C 75*00 00         [24] 2026 	mov	_spi_transfer_PARM_2,#0x00
      00077F 75 82 FF         [24] 2027 	mov	dpl,#0xff
      000782 C0 07            [24] 2028 	push	ar7
      000784 C0 06            [24] 2029 	push	ar6
      000786 C0 05            [24] 2030 	push	ar5
      000788 C0 04            [24] 2031 	push	ar4
      00078A 12r04r2E         [24] 2032 	lcall	_spi_transfer
      00078D AB 82            [24] 2033 	mov	r3,dpl
      00078F D0 04            [24] 2034 	pop	ar4
      000791 D0 05            [24] 2035 	pop	ar5
      000793 D0 06            [24] 2036 	pop	ar6
      000795 D0 07            [24] 2037 	pop	ar7
                                   2038 ;	sdcard.h:270: if(i>=offset && i<offset+count)
      000797 E5*00            [12] 2039 	mov	a,_bp
      000799 24 FC            [12] 2040 	add	a,#0xfc
      00079B F8               [12] 2041 	mov	r0,a
      00079C C3               [12] 2042 	clr	c
      00079D EC               [12] 2043 	mov	a,r4
      00079E 96               [12] 2044 	subb	a,@r0
      00079F ED               [12] 2045 	mov	a,r5
      0007A0 08               [12] 2046 	inc	r0
      0007A1 96               [12] 2047 	subb	a,@r0
      0007A2 40 34            [24] 2048 	jc	00130$
      0007A4 EC               [12] 2049 	mov	a,r4
      0007A5 9E               [12] 2050 	subb	a,r6
      0007A6 ED               [12] 2051 	mov	a,r5
      0007A7 9F               [12] 2052 	subb	a,r7
      0007A8 50 2E            [24] 2053 	jnc	00130$
                                   2054 ;	sdcard.h:272: dst[i-offset] = response;
      0007AA C0 06            [24] 2055 	push	ar6
      0007AC C0 07            [24] 2056 	push	ar7
      0007AE E5*00            [12] 2057 	mov	a,_bp
      0007B0 24 FC            [12] 2058 	add	a,#0xfc
      0007B2 F8               [12] 2059 	mov	r0,a
      0007B3 EC               [12] 2060 	mov	a,r4
      0007B4 C3               [12] 2061 	clr	c
      0007B5 96               [12] 2062 	subb	a,@r0
      0007B6 FA               [12] 2063 	mov	r2,a
      0007B7 ED               [12] 2064 	mov	a,r5
      0007B8 08               [12] 2065 	inc	r0
      0007B9 96               [12] 2066 	subb	a,@r0
      0007BA FF               [12] 2067 	mov	r7,a
      0007BB E5*00            [12] 2068 	mov	a,_bp
      0007BD 24 F7            [12] 2069 	add	a,#0xf7
      0007BF F8               [12] 2070 	mov	r0,a
      0007C0 EA               [12] 2071 	mov	a,r2
      0007C1 26               [12] 2072 	add	a,@r0
      0007C2 FA               [12] 2073 	mov	r2,a
      0007C3 EF               [12] 2074 	mov	a,r7
      0007C4 08               [12] 2075 	inc	r0
      0007C5 36               [12] 2076 	addc	a,@r0
      0007C6 FF               [12] 2077 	mov	r7,a
      0007C7 08               [12] 2078 	inc	r0
      0007C8 86 06            [24] 2079 	mov	ar6,@r0
      0007CA 8A 82            [24] 2080 	mov	dpl,r2
      0007CC 8F 83            [24] 2081 	mov	dph,r7
      0007CE 8E F0            [24] 2082 	mov	b,r6
      0007D0 EB               [12] 2083 	mov	a,r3
      0007D1 12r00r00         [24] 2084 	lcall	__gptrput
                                   2085 ;	sdcard.h:287: return 0; //success
      0007D4 D0 07            [24] 2086 	pop	ar7
      0007D6 D0 06            [24] 2087 	pop	ar6
                                   2088 ;	sdcard.h:272: dst[i-offset] = response;
      0007D8                       2089 00130$:
                                   2090 ;	sdcard.h:260: for(uint16_t i=0;i<512;i++)
      0007D8 0C               [12] 2091 	inc	r4
      0007D9 BC 00 9B         [24] 2092 	cjne	r4,#0x00,00129$
      0007DC 0D               [12] 2093 	inc	r5
      0007DD 80 98            [24] 2094 	sjmp	00129$
      0007DF                       2095 00124$:
                                   2096 ;	sdcard.h:280: sd_spi_write(0xff);
      0007DF 75*00 00         [24] 2097 	mov	_spi_transfer_PARM_2,#0x00
      0007E2 75 82 FF         [24] 2098 	mov	dpl,#0xff
      0007E5 12r04r2E         [24] 2099 	lcall	_spi_transfer
                                   2100 ;	sdcard.h:281: sd_spi_write(0xff);
      0007E8 75*00 00         [24] 2101 	mov	_spi_transfer_PARM_2,#0x00
      0007EB 75 82 FF         [24] 2102 	mov	dpl,#0xff
      0007EE 12r04r2E         [24] 2103 	lcall	_spi_transfer
                                   2104 ;	sdcard.h:284: spi_cs_high(); //leave clock high
      0007F1 43 90 08         [24] 2105 	orl	_P1,#0x08
                                   2106 ;	sdcard.h:287: return 0; //success
      0007F4 75 82 00         [24] 2107 	mov	dpl,#0x00
      0007F7                       2108 00131$:
                                   2109 ;	sdcard.h:289: }
      0007F7 D0*00            [24] 2110 	pop	_bp
      0007F9 22               [24] 2111 	ret
                                   2112 ;------------------------------------------------------------
                                   2113 ;Allocation info for local variables in function 'SDreadBlock'
                                   2114 ;------------------------------------------------------------
                                   2115 ;dst                       Allocated with name '_SDreadBlock_PARM_2'
                                   2116 ;block_addr                Allocated to registers r4 r5 r6 r7 
                                   2117 ;------------------------------------------------------------
                                   2118 ;	sdcard.h:291: uint8_t SDreadBlock(uint32_t block_addr,uint8_t* dst)
                                   2119 ;	-----------------------------------------
                                   2120 ;	 function SDreadBlock
                                   2121 ;	-----------------------------------------
      0007FA                       2122 _SDreadBlock:
      0007FA AC 82            [24] 2123 	mov	r4,dpl
      0007FC AD 83            [24] 2124 	mov	r5,dph
      0007FE AE F0            [24] 2125 	mov	r6,b
      000800 FF               [12] 2126 	mov	r7,a
                                   2127 ;	sdcard.h:293: return SDread(block_addr,0,SD_BLOCK_SIZE,dst);
      000801 C0*0D            [24] 2128 	push	_SDreadBlock_PARM_2
      000803 C0*0E            [24] 2129 	push	(_SDreadBlock_PARM_2 + 1)
      000805 C0*0F            [24] 2130 	push	(_SDreadBlock_PARM_2 + 2)
      000807 E4               [12] 2131 	clr	a
      000808 C0 E0            [24] 2132 	push	acc
      00080A 74 02            [12] 2133 	mov	a,#0x02
      00080C C0 E0            [24] 2134 	push	acc
      00080E E4               [12] 2135 	clr	a
      00080F C0 E0            [24] 2136 	push	acc
      000811 C0 E0            [24] 2137 	push	acc
      000813 8C 82            [24] 2138 	mov	dpl,r4
      000815 8D 83            [24] 2139 	mov	dph,r5
      000817 8E F0            [24] 2140 	mov	b,r6
      000819 EF               [12] 2141 	mov	a,r7
      00081A 12r06rDE         [24] 2142 	lcall	_SDread
      00081D E5 81            [12] 2143 	mov	a,sp
      00081F 24 F9            [12] 2144 	add	a,#0xf9
      000821 F5 81            [12] 2145 	mov	sp,a
                                   2146 ;	sdcard.h:294: }
      000823 22               [24] 2147 	ret
                                   2148 ;------------------------------------------------------------
                                   2149 ;Allocation info for local variables in function 'HELPER_load_littleendian16'
                                   2150 ;------------------------------------------------------------
                                   2151 ;src                       Allocated to registers r5 r6 r7 
                                   2152 ;val                       Allocated to registers r2 r4 
                                   2153 ;------------------------------------------------------------
                                   2154 ;	fat.h:85: uint16_t HELPER_load_littleendian16(uint8_t *src) __reentrant
                                   2155 ;	-----------------------------------------
                                   2156 ;	 function HELPER_load_littleendian16
                                   2157 ;	-----------------------------------------
      000824                       2158 _HELPER_load_littleendian16:
      000824 AD 82            [24] 2159 	mov	r5,dpl
      000826 AE 83            [24] 2160 	mov	r6,dph
      000828 AF F0            [24] 2161 	mov	r7,b
                                   2162 ;	fat.h:89: val = *(src+1);
      00082A 74 01            [12] 2163 	mov	a,#0x01
      00082C 2D               [12] 2164 	add	a,r5
      00082D FA               [12] 2165 	mov	r2,a
      00082E E4               [12] 2166 	clr	a
      00082F 3E               [12] 2167 	addc	a,r6
      000830 FB               [12] 2168 	mov	r3,a
      000831 8F 04            [24] 2169 	mov	ar4,r7
      000833 8A 82            [24] 2170 	mov	dpl,r2
      000835 8B 83            [24] 2171 	mov	dph,r3
      000837 8C F0            [24] 2172 	mov	b,r4
      000839 12r00r00         [24] 2173 	lcall	__gptrget
                                   2174 ;	fat.h:90: val <<= 8;
      00083C FC               [12] 2175 	mov	r4,a
      00083D 7A 00            [12] 2176 	mov	r2,#0x00
                                   2177 ;	fat.h:91: val |= *src;
      00083F 8D 82            [24] 2178 	mov	dpl,r5
      000841 8E 83            [24] 2179 	mov	dph,r6
      000843 8F F0            [24] 2180 	mov	b,r7
      000845 12r00r00         [24] 2181 	lcall	__gptrget
      000848 7F 00            [12] 2182 	mov	r7,#0x00
      00084A 4A               [12] 2183 	orl	a,r2
      00084B F5 82            [12] 2184 	mov	dpl,a
      00084D EF               [12] 2185 	mov	a,r7
      00084E 4C               [12] 2186 	orl	a,r4
      00084F F5 83            [12] 2187 	mov	dph,a
                                   2188 ;	fat.h:93: return val;
                                   2189 ;	fat.h:94: }
      000851 22               [24] 2190 	ret
                                   2191 ;------------------------------------------------------------
                                   2192 ;Allocation info for local variables in function 'HELPER_load_littleendian32'
                                   2193 ;------------------------------------------------------------
                                   2194 ;src                       Allocated to stack - _bp +1
                                   2195 ;val                       Allocated to stack - _bp +8
                                   2196 ;i                         Allocated to stack - _bp +12
                                   2197 ;sloc0                     Allocated to stack - _bp +9
                                   2198 ;sloc1                     Allocated to stack - _bp +4
                                   2199 ;------------------------------------------------------------
                                   2200 ;	fat.h:96: uint32_t HELPER_load_littleendian32(uint8_t *src) __reentrant
                                   2201 ;	-----------------------------------------
                                   2202 ;	 function HELPER_load_littleendian32
                                   2203 ;	-----------------------------------------
      000852                       2204 _HELPER_load_littleendian32:
      000852 C0*00            [24] 2205 	push	_bp
      000854 85 81*00         [24] 2206 	mov	_bp,sp
      000857 C0 82            [24] 2207 	push	dpl
      000859 C0 83            [24] 2208 	push	dph
      00085B C0 F0            [24] 2209 	push	b
      00085D E5 81            [12] 2210 	mov	a,sp
      00085F 24 09            [12] 2211 	add	a,#0x09
      000861 F5 81            [12] 2212 	mov	sp,a
                                   2213 ;	fat.h:98: uint32_t val=0;
                                   2214 ;	fat.h:100: for(uint8_t i=0;i<4;i++)
      000863 E4               [12] 2215 	clr	a
      000864 FA               [12] 2216 	mov	r2,a
      000865 FB               [12] 2217 	mov	r3,a
      000866 FC               [12] 2218 	mov	r4,a
      000867 FF               [12] 2219 	mov	r7,a
      000868 E5*00            [12] 2220 	mov	a,_bp
      00086A 24 0C            [12] 2221 	add	a,#0x0c
      00086C F8               [12] 2222 	mov	r0,a
      00086D 76 00            [12] 2223 	mov	@r0,#0x00
      00086F                       2224 00103$:
      00086F E5*00            [12] 2225 	mov	a,_bp
      000871 24 0C            [12] 2226 	add	a,#0x0c
      000873 F8               [12] 2227 	mov	r0,a
      000874 B6 04 00         [24] 2228 	cjne	@r0,#0x04,00118$
      000877                       2229 00118$:
      000877 50 6F            [24] 2230 	jnc	00101$
                                   2231 ;	fat.h:102: val <<= 8;
      000879 E5*00            [12] 2232 	mov	a,_bp
      00087B 24 08            [12] 2233 	add	a,#0x08
      00087D F8               [12] 2234 	mov	r0,a
      00087E 08               [12] 2235 	inc	r0
      00087F 08               [12] 2236 	inc	r0
      000880 08               [12] 2237 	inc	r0
      000881 A6 04            [24] 2238 	mov	@r0,ar4
      000883 18               [12] 2239 	dec	r0
      000884 A6 03            [24] 2240 	mov	@r0,ar3
      000886 18               [12] 2241 	dec	r0
      000887 A6 02            [24] 2242 	mov	@r0,ar2
      000889 18               [12] 2243 	dec	r0
      00088A 76 00            [12] 2244 	mov	@r0,#0x00
                                   2245 ;	fat.h:103: val |= src[3-i];
      00088C E5*00            [12] 2246 	mov	a,_bp
      00088E 24 0C            [12] 2247 	add	a,#0x0c
      000890 F8               [12] 2248 	mov	r0,a
      000891 86 05            [24] 2249 	mov	ar5,@r0
      000893 7E 00            [12] 2250 	mov	r6,#0x00
      000895 74 03            [12] 2251 	mov	a,#0x03
      000897 C3               [12] 2252 	clr	c
      000898 9D               [12] 2253 	subb	a,r5
      000899 FD               [12] 2254 	mov	r5,a
      00089A E4               [12] 2255 	clr	a
      00089B 9E               [12] 2256 	subb	a,r6
      00089C FE               [12] 2257 	mov	r6,a
      00089D A8*00            [24] 2258 	mov	r0,_bp
      00089F 08               [12] 2259 	inc	r0
      0008A0 ED               [12] 2260 	mov	a,r5
      0008A1 26               [12] 2261 	add	a,@r0
      0008A2 FF               [12] 2262 	mov	r7,a
      0008A3 EE               [12] 2263 	mov	a,r6
      0008A4 08               [12] 2264 	inc	r0
      0008A5 36               [12] 2265 	addc	a,@r0
      0008A6 FE               [12] 2266 	mov	r6,a
      0008A7 08               [12] 2267 	inc	r0
      0008A8 86 05            [24] 2268 	mov	ar5,@r0
      0008AA 8F 82            [24] 2269 	mov	dpl,r7
      0008AC 8E 83            [24] 2270 	mov	dph,r6
      0008AE 8D F0            [24] 2271 	mov	b,r5
      0008B0 12r00r00         [24] 2272 	lcall	__gptrget
      0008B3 FE               [12] 2273 	mov	r6,a
      0008B4 E5*00            [12] 2274 	mov	a,_bp
      0008B6 24 04            [12] 2275 	add	a,#0x04
      0008B8 F8               [12] 2276 	mov	r0,a
      0008B9 A6 06            [24] 2277 	mov	@r0,ar6
      0008BB 08               [12] 2278 	inc	r0
      0008BC 76 00            [12] 2279 	mov	@r0,#0x00
      0008BE 08               [12] 2280 	inc	r0
      0008BF 76 00            [12] 2281 	mov	@r0,#0x00
      0008C1 08               [12] 2282 	inc	r0
      0008C2 76 00            [12] 2283 	mov	@r0,#0x00
      0008C4 E5*00            [12] 2284 	mov	a,_bp
      0008C6 24 08            [12] 2285 	add	a,#0x08
      0008C8 F8               [12] 2286 	mov	r0,a
      0008C9 E5*00            [12] 2287 	mov	a,_bp
      0008CB 24 04            [12] 2288 	add	a,#0x04
      0008CD F9               [12] 2289 	mov	r1,a
      0008CE E7               [12] 2290 	mov	a,@r1
      0008CF 46               [12] 2291 	orl	a,@r0
      0008D0 FA               [12] 2292 	mov	r2,a
      0008D1 09               [12] 2293 	inc	r1
      0008D2 E7               [12] 2294 	mov	a,@r1
      0008D3 08               [12] 2295 	inc	r0
      0008D4 46               [12] 2296 	orl	a,@r0
      0008D5 FB               [12] 2297 	mov	r3,a
      0008D6 09               [12] 2298 	inc	r1
      0008D7 E7               [12] 2299 	mov	a,@r1
      0008D8 08               [12] 2300 	inc	r0
      0008D9 46               [12] 2301 	orl	a,@r0
      0008DA FC               [12] 2302 	mov	r4,a
      0008DB 09               [12] 2303 	inc	r1
      0008DC E7               [12] 2304 	mov	a,@r1
      0008DD 08               [12] 2305 	inc	r0
      0008DE 46               [12] 2306 	orl	a,@r0
      0008DF FF               [12] 2307 	mov	r7,a
                                   2308 ;	fat.h:100: for(uint8_t i=0;i<4;i++)
      0008E0 E5*00            [12] 2309 	mov	a,_bp
      0008E2 24 0C            [12] 2310 	add	a,#0x0c
      0008E4 F8               [12] 2311 	mov	r0,a
      0008E5 06               [12] 2312 	inc	@r0
      0008E6 80 87            [24] 2313 	sjmp	00103$
      0008E8                       2314 00101$:
                                   2315 ;	fat.h:106: return val;
      0008E8 8A 82            [24] 2316 	mov	dpl,r2
      0008EA 8B 83            [24] 2317 	mov	dph,r3
      0008EC 8C F0            [24] 2318 	mov	b,r4
      0008EE EF               [12] 2319 	mov	a,r7
                                   2320 ;	fat.h:107: }
      0008EF 85*00 81         [24] 2321 	mov	sp,_bp
      0008F2 D0*00            [24] 2322 	pop	_bp
      0008F4 22               [24] 2323 	ret
                                   2324 ;------------------------------------------------------------
                                   2325 ;Allocation info for local variables in function 'HELPER_strcmp'
                                   2326 ;------------------------------------------------------------
                                   2327 ;s2                        Allocated with name '_HELPER_strcmp_PARM_2'
                                   2328 ;s1                        Allocated to registers r5 r6 r7 
                                   2329 ;i                         Allocated to registers r4 
                                   2330 ;------------------------------------------------------------
                                   2331 ;	fat.h:109: uint8_t HELPER_strcmp(char *s1,char* s2)
                                   2332 ;	-----------------------------------------
                                   2333 ;	 function HELPER_strcmp
                                   2334 ;	-----------------------------------------
      0008F5                       2335 _HELPER_strcmp:
      0008F5 AD 82            [24] 2336 	mov	r5,dpl
      0008F7 AE 83            [24] 2337 	mov	r6,dph
      0008F9 AF F0            [24] 2338 	mov	r7,b
                                   2339 ;	fat.h:112: while(1)
      0008FB 7C 00            [12] 2340 	mov	r4,#0x00
      0008FD                       2341 00107$:
                                   2342 ;	fat.h:114: if(s1[i]==s2[i]);
      0008FD EC               [12] 2343 	mov	a,r4
      0008FE 2D               [12] 2344 	add	a,r5
      0008FF F9               [12] 2345 	mov	r1,a
      000900 E4               [12] 2346 	clr	a
      000901 3E               [12] 2347 	addc	a,r6
      000902 FA               [12] 2348 	mov	r2,a
      000903 8F 03            [24] 2349 	mov	ar3,r7
      000905 89 82            [24] 2350 	mov	dpl,r1
      000907 8A 83            [24] 2351 	mov	dph,r2
      000909 8B F0            [24] 2352 	mov	b,r3
      00090B 12r00r00         [24] 2353 	lcall	__gptrget
      00090E FB               [12] 2354 	mov	r3,a
      00090F EC               [12] 2355 	mov	a,r4
      000910 25*00            [12] 2356 	add	a,_HELPER_strcmp_PARM_2
      000912 F8               [12] 2357 	mov	r0,a
      000913 E4               [12] 2358 	clr	a
      000914 35*01            [12] 2359 	addc	a,(_HELPER_strcmp_PARM_2 + 1)
      000916 F9               [12] 2360 	mov	r1,a
      000917 AA*02            [24] 2361 	mov	r2,(_HELPER_strcmp_PARM_2 + 2)
      000919 88 82            [24] 2362 	mov	dpl,r0
      00091B 89 83            [24] 2363 	mov	dph,r1
      00091D 8A F0            [24] 2364 	mov	b,r2
      00091F 12r00r00         [24] 2365 	lcall	__gptrget
      000922 F8               [12] 2366 	mov	r0,a
      000923 EB               [12] 2367 	mov	a,r3
      000924 B5 00 02         [24] 2368 	cjne	a,ar0,00123$
      000927 80 04            [24] 2369 	sjmp	00103$
      000929                       2370 00123$:
                                   2371 ;	fat.h:115: else return 1;
      000929 75 82 01         [24] 2372 	mov	dpl,#0x01
      00092C 22               [24] 2373 	ret
      00092D                       2374 00103$:
                                   2375 ;	fat.h:117: if(s1[i]==0) return 0;
      00092D EB               [12] 2376 	mov	a,r3
      00092E 70 03            [24] 2377 	jnz	00105$
      000930 F5 82            [12] 2378 	mov	dpl,a
      000932 22               [24] 2379 	ret
      000933                       2380 00105$:
                                   2381 ;	fat.h:118: i++;
      000933 0C               [12] 2382 	inc	r4
                                   2383 ;	fat.h:120: }
      000934 80 C7            [24] 2384 	sjmp	00107$
                                   2385 ;------------------------------------------------------------
                                   2386 ;Allocation info for local variables in function 'HELPER_strncmp'
                                   2387 ;------------------------------------------------------------
                                   2388 ;s2                        Allocated with name '_HELPER_strncmp_PARM_2'
                                   2389 ;n                         Allocated with name '_HELPER_strncmp_PARM_3'
                                   2390 ;s1                        Allocated to registers r5 r6 r7 
                                   2391 ;i                         Allocated to registers r4 
                                   2392 ;------------------------------------------------------------
                                   2393 ;	fat.h:122: uint8_t HELPER_strncmp(char *s1,char* s2,uint8_t n)
                                   2394 ;	-----------------------------------------
                                   2395 ;	 function HELPER_strncmp
                                   2396 ;	-----------------------------------------
      000936                       2397 _HELPER_strncmp:
      000936 AD 82            [24] 2398 	mov	r5,dpl
      000938 AE 83            [24] 2399 	mov	r6,dph
      00093A AF F0            [24] 2400 	mov	r7,b
                                   2401 ;	fat.h:125: while(1)
      00093C 7C 00            [12] 2402 	mov	r4,#0x00
      00093E                       2403 00109$:
                                   2404 ;	fat.h:127: if(i==n) return 0; //done - successful
      00093E EC               [12] 2405 	mov	a,r4
      00093F B5*03 04         [24] 2406 	cjne	a,_HELPER_strncmp_PARM_3,00102$
      000942 75 82 00         [24] 2407 	mov	dpl,#0x00
      000945 22               [24] 2408 	ret
      000946                       2409 00102$:
                                   2410 ;	fat.h:129: if(s1[i]==s2[i]);
      000946 EC               [12] 2411 	mov	a,r4
      000947 2D               [12] 2412 	add	a,r5
      000948 F9               [12] 2413 	mov	r1,a
      000949 E4               [12] 2414 	clr	a
      00094A 3E               [12] 2415 	addc	a,r6
      00094B FA               [12] 2416 	mov	r2,a
      00094C 8F 03            [24] 2417 	mov	ar3,r7
      00094E 89 82            [24] 2418 	mov	dpl,r1
      000950 8A 83            [24] 2419 	mov	dph,r2
      000952 8B F0            [24] 2420 	mov	b,r3
      000954 12r00r00         [24] 2421 	lcall	__gptrget
      000957 FB               [12] 2422 	mov	r3,a
      000958 EC               [12] 2423 	mov	a,r4
      000959 25*00            [12] 2424 	add	a,_HELPER_strncmp_PARM_2
      00095B F8               [12] 2425 	mov	r0,a
      00095C E4               [12] 2426 	clr	a
      00095D 35*01            [12] 2427 	addc	a,(_HELPER_strncmp_PARM_2 + 1)
      00095F F9               [12] 2428 	mov	r1,a
      000960 AA*02            [24] 2429 	mov	r2,(_HELPER_strncmp_PARM_2 + 2)
      000962 88 82            [24] 2430 	mov	dpl,r0
      000964 89 83            [24] 2431 	mov	dph,r1
      000966 8A F0            [24] 2432 	mov	b,r2
      000968 12r00r00         [24] 2433 	lcall	__gptrget
      00096B F8               [12] 2434 	mov	r0,a
      00096C EB               [12] 2435 	mov	a,r3
      00096D B5 00 02         [24] 2436 	cjne	a,ar0,00131$
      000970 80 04            [24] 2437 	sjmp	00105$
      000972                       2438 00131$:
                                   2439 ;	fat.h:130: else return 1;
      000972 75 82 01         [24] 2440 	mov	dpl,#0x01
      000975 22               [24] 2441 	ret
      000976                       2442 00105$:
                                   2443 ;	fat.h:132: if(s1[i]==0) return 0; //if string length < n, return success as well as we donot want to compare more
      000976 EB               [12] 2444 	mov	a,r3
      000977 70 03            [24] 2445 	jnz	00107$
      000979 F5 82            [12] 2446 	mov	dpl,a
      00097B 22               [24] 2447 	ret
      00097C                       2448 00107$:
                                   2449 ;	fat.h:133: i++;
      00097C 0C               [12] 2450 	inc	r4
                                   2451 ;	fat.h:135: }
      00097D 80 BF            [24] 2452 	sjmp	00109$
                                   2453 ;------------------------------------------------------------
                                   2454 ;Allocation info for local variables in function 'HELPER_strlen'
                                   2455 ;------------------------------------------------------------
                                   2456 ;s                         Allocated to registers r5 r6 r7 
                                   2457 ;i                         Allocated to registers r4 
                                   2458 ;------------------------------------------------------------
                                   2459 ;	fat.h:137: uint8_t HELPER_strlen(char *s)
                                   2460 ;	-----------------------------------------
                                   2461 ;	 function HELPER_strlen
                                   2462 ;	-----------------------------------------
      00097F                       2463 _HELPER_strlen:
      00097F AD 82            [24] 2464 	mov	r5,dpl
      000981 AE 83            [24] 2465 	mov	r6,dph
      000983 AF F0            [24] 2466 	mov	r7,b
                                   2467 ;	fat.h:139: for(uint8_t i=0;i<255;i++)
      000985 7C 00            [12] 2468 	mov	r4,#0x00
      000987 7B 00            [12] 2469 	mov	r3,#0x00
      000989                       2470 00105$:
      000989 BB FF 00         [24] 2471 	cjne	r3,#0xff,00121$
      00098C                       2472 00121$:
      00098C 50 1B            [24] 2473 	jnc	00103$
                                   2474 ;	fat.h:141: if(s[i]==0) return i;
      00098E EB               [12] 2475 	mov	a,r3
      00098F 2D               [12] 2476 	add	a,r5
      000990 F8               [12] 2477 	mov	r0,a
      000991 E4               [12] 2478 	clr	a
      000992 3E               [12] 2479 	addc	a,r6
      000993 F9               [12] 2480 	mov	r1,a
      000994 8F 02            [24] 2481 	mov	ar2,r7
      000996 88 82            [24] 2482 	mov	dpl,r0
      000998 89 83            [24] 2483 	mov	dph,r1
      00099A 8A F0            [24] 2484 	mov	b,r2
      00099C 12r00r00         [24] 2485 	lcall	__gptrget
      00099F 70 03            [24] 2486 	jnz	00106$
      0009A1 8C 82            [24] 2487 	mov	dpl,r4
      0009A3 22               [24] 2488 	ret
      0009A4                       2489 00106$:
                                   2490 ;	fat.h:139: for(uint8_t i=0;i<255;i++)
      0009A4 0B               [12] 2491 	inc	r3
      0009A5 8B 04            [24] 2492 	mov	ar4,r3
      0009A7 80 E0            [24] 2493 	sjmp	00105$
      0009A9                       2494 00103$:
                                   2495 ;	fat.h:144: return 255;
      0009A9 75 82 FF         [24] 2496 	mov	dpl,#0xff
                                   2497 ;	fat.h:145: }
      0009AC 22               [24] 2498 	ret
                                   2499 ;------------------------------------------------------------
                                   2500 ;Allocation info for local variables in function 'HELPER_rootentry_type'
                                   2501 ;------------------------------------------------------------
                                   2502 ;re                        Allocated to registers r5 r6 r7 
                                   2503 ;------------------------------------------------------------
                                   2504 ;	fat.h:147: uint8_t HELPER_rootentry_type(ROOTENTRY *re)
                                   2505 ;	-----------------------------------------
                                   2506 ;	 function HELPER_rootentry_type
                                   2507 ;	-----------------------------------------
      0009AD                       2508 _HELPER_rootentry_type:
      0009AD AD 82            [24] 2509 	mov	r5,dpl
      0009AF AE 83            [24] 2510 	mov	r6,dph
      0009B1 AF F0            [24] 2511 	mov	r7,b
                                   2512 ;	fat.h:149: if(re->attributes & 1<<FILETYPE_HIDDEN) return FILETYPE_HIDDEN; //directory entry
      0009B3 74 0B            [12] 2513 	mov	a,#0x0b
      0009B5 2D               [12] 2514 	add	a,r5
      0009B6 FA               [12] 2515 	mov	r2,a
      0009B7 E4               [12] 2516 	clr	a
      0009B8 3E               [12] 2517 	addc	a,r6
      0009B9 FB               [12] 2518 	mov	r3,a
      0009BA 8F 04            [24] 2519 	mov	ar4,r7
      0009BC 8A 82            [24] 2520 	mov	dpl,r2
      0009BE 8B 83            [24] 2521 	mov	dph,r3
      0009C0 8C F0            [24] 2522 	mov	b,r4
      0009C2 12r00r00         [24] 2523 	lcall	__gptrget
      0009C5 FC               [12] 2524 	mov	r4,a
      0009C6 30 E1 04         [24] 2525 	jnb	acc.1,00102$
      0009C9 75 82 01         [24] 2526 	mov	dpl,#0x01
      0009CC 22               [24] 2527 	ret
      0009CD                       2528 00102$:
                                   2529 ;	fat.h:150: if(re->attributes & 1<<FILETYPE_SYSTEM) return FILETYPE_SYSTEM; //directory entry
      0009CD EC               [12] 2530 	mov	a,r4
      0009CE 30 E2 04         [24] 2531 	jnb	acc.2,00104$
      0009D1 75 82 02         [24] 2532 	mov	dpl,#0x02
      0009D4 22               [24] 2533 	ret
      0009D5                       2534 00104$:
                                   2535 ;	fat.h:151: if(re->attributes & 1<<FILETYPE_VOLUME) return FILETYPE_VOLUME; //directory entry
      0009D5 EC               [12] 2536 	mov	a,r4
      0009D6 30 E3 04         [24] 2537 	jnb	acc.3,00106$
      0009D9 75 82 03         [24] 2538 	mov	dpl,#0x03
      0009DC 22               [24] 2539 	ret
      0009DD                       2540 00106$:
                                   2541 ;	fat.h:153: if(re->startCluster==0) return FILETYPE_NOFILE; //no file
      0009DD 74 0C            [12] 2542 	mov	a,#0x0c
      0009DF 2D               [12] 2543 	add	a,r5
      0009E0 FA               [12] 2544 	mov	r2,a
      0009E1 E4               [12] 2545 	clr	a
      0009E2 3E               [12] 2546 	addc	a,r6
      0009E3 FB               [12] 2547 	mov	r3,a
      0009E4 8F 04            [24] 2548 	mov	ar4,r7
      0009E6 8A 82            [24] 2549 	mov	dpl,r2
      0009E8 8B 83            [24] 2550 	mov	dph,r3
      0009EA 8C F0            [24] 2551 	mov	b,r4
      0009EC 12r00r00         [24] 2552 	lcall	__gptrget
      0009EF FA               [12] 2553 	mov	r2,a
      0009F0 A3               [24] 2554 	inc	dptr
      0009F1 12r00r00         [24] 2555 	lcall	__gptrget
      0009F4 4A               [12] 2556 	orl	a,r2
      0009F5 70 04            [24] 2557 	jnz	00111$
      0009F7 75 82 FF         [24] 2558 	mov	dpl,#0xff
      0009FA 22               [24] 2559 	ret
      0009FB                       2560 00111$:
                                   2561 ;	fat.h:154: else if(re->size==0) return FILETYPE_EMPTYFILE; //empty file
      0009FB 74 0E            [12] 2562 	mov	a,#0x0e
      0009FD 2D               [12] 2563 	add	a,r5
      0009FE FD               [12] 2564 	mov	r5,a
      0009FF E4               [12] 2565 	clr	a
      000A00 3E               [12] 2566 	addc	a,r6
      000A01 FE               [12] 2567 	mov	r6,a
      000A02 8D 82            [24] 2568 	mov	dpl,r5
      000A04 8E 83            [24] 2569 	mov	dph,r6
      000A06 8F F0            [24] 2570 	mov	b,r7
      000A08 12r00r00         [24] 2571 	lcall	__gptrget
      000A0B FD               [12] 2572 	mov	r5,a
      000A0C A3               [24] 2573 	inc	dptr
      000A0D 12r00r00         [24] 2574 	lcall	__gptrget
      000A10 FE               [12] 2575 	mov	r6,a
      000A11 A3               [24] 2576 	inc	dptr
      000A12 12r00r00         [24] 2577 	lcall	__gptrget
      000A15 FF               [12] 2578 	mov	r7,a
      000A16 A3               [24] 2579 	inc	dptr
      000A17 12r00r00         [24] 2580 	lcall	__gptrget
      000A1A FC               [12] 2581 	mov	r4,a
      000A1B ED               [12] 2582 	mov	a,r5
      000A1C 4E               [12] 2583 	orl	a,r6
      000A1D 4F               [12] 2584 	orl	a,r7
      000A1E 4C               [12] 2585 	orl	a,r4
      000A1F 70 04            [24] 2586 	jnz	00108$
      000A21 75 82 FE         [24] 2587 	mov	dpl,#0xfe
      000A24 22               [24] 2588 	ret
      000A25                       2589 00108$:
                                   2590 ;	fat.h:155: else return 0; // valid non-empty file
      000A25 75 82 00         [24] 2591 	mov	dpl,#0x00
                                   2592 ;	fat.h:157: }
      000A28 22               [24] 2593 	ret
                                   2594 ;------------------------------------------------------------
                                   2595 ;Allocation info for local variables in function 'HELPER_to_uppercase'
                                   2596 ;------------------------------------------------------------
                                   2597 ;s                         Allocated to registers r5 r6 r7 
                                   2598 ;i                         Allocated to registers r4 
                                   2599 ;------------------------------------------------------------
                                   2600 ;	fat.h:162: void HELPER_to_uppercase(unsigned char *s)
                                   2601 ;	-----------------------------------------
                                   2602 ;	 function HELPER_to_uppercase
                                   2603 ;	-----------------------------------------
      000A29                       2604 _HELPER_to_uppercase:
      000A29 AD 82            [24] 2605 	mov	r5,dpl
      000A2B AE 83            [24] 2606 	mov	r6,dph
      000A2D AF F0            [24] 2607 	mov	r7,b
                                   2608 ;	fat.h:164: for(uint8_t i=0;i<255;i++)
      000A2F 7C 00            [12] 2609 	mov	r4,#0x00
      000A31                       2610 00108$:
      000A31 BC FF 00         [24] 2611 	cjne	r4,#0xff,00132$
      000A34                       2612 00132$:
      000A34 50 2F            [24] 2613 	jnc	00110$
                                   2614 ;	fat.h:166: if(s[i]==0) return; //done
      000A36 EC               [12] 2615 	mov	a,r4
      000A37 2D               [12] 2616 	add	a,r5
      000A38 F9               [12] 2617 	mov	r1,a
      000A39 E4               [12] 2618 	clr	a
      000A3A 3E               [12] 2619 	addc	a,r6
      000A3B FA               [12] 2620 	mov	r2,a
      000A3C 8F 03            [24] 2621 	mov	ar3,r7
      000A3E 89 82            [24] 2622 	mov	dpl,r1
      000A40 8A 83            [24] 2623 	mov	dph,r2
      000A42 8B F0            [24] 2624 	mov	b,r3
      000A44 12r00r00         [24] 2625 	lcall	__gptrget
      000A47 F8               [12] 2626 	mov	r0,a
      000A48 70 01            [24] 2627 	jnz	00102$
      000A4A 22               [24] 2628 	ret
      000A4B                       2629 00102$:
                                   2630 ;	fat.h:167: if('a'<=s[i] && s[i]<='z') s[i] = s[i] - 32;
      000A4B B8 61 00         [24] 2631 	cjne	r0,#0x61,00135$
      000A4E                       2632 00135$:
      000A4E 40 12            [24] 2633 	jc	00109$
      000A50 E8               [12] 2634 	mov	a,r0
      000A51 24 85            [12] 2635 	add	a,#0xff - 0x7a
      000A53 40 0D            [24] 2636 	jc	00109$
      000A55 E8               [12] 2637 	mov	a,r0
      000A56 24 E0            [12] 2638 	add	a,#0xe0
      000A58 F8               [12] 2639 	mov	r0,a
      000A59 89 82            [24] 2640 	mov	dpl,r1
      000A5B 8A 83            [24] 2641 	mov	dph,r2
      000A5D 8B F0            [24] 2642 	mov	b,r3
      000A5F 12r00r00         [24] 2643 	lcall	__gptrput
      000A62                       2644 00109$:
                                   2645 ;	fat.h:164: for(uint8_t i=0;i<255;i++)
      000A62 0C               [12] 2646 	inc	r4
      000A63 80 CC            [24] 2647 	sjmp	00108$
      000A65                       2648 00110$:
                                   2649 ;	fat.h:169: }
      000A65 22               [24] 2650 	ret
                                   2651 ;------------------------------------------------------------
                                   2652 ;Allocation info for local variables in function 'HELPER_filename_to_8dot3filename'
                                   2653 ;------------------------------------------------------------
                                   2654 ;fname83                   Allocated with name '_HELPER_filename_to_8dot3filename_PARM_2'
                                   2655 ;fname                     Allocated with name '_HELPER_filename_to_8dot3filename_fname_65536_120'
                                   2656 ;index                     Allocated to registers r4 
                                   2657 ;i                         Allocated to registers r4 
                                   2658 ;i                         Allocated with name '_HELPER_filename_to_8dot3filename_i_131072_126'
                                   2659 ;------------------------------------------------------------
                                   2660 ;	fat.h:172: uint8_t HELPER_filename_to_8dot3filename( char *fname,  char *fname83)
                                   2661 ;	-----------------------------------------
                                   2662 ;	 function HELPER_filename_to_8dot3filename
                                   2663 ;	-----------------------------------------
      000A66                       2664 _HELPER_filename_to_8dot3filename:
                                   2665 ;	fat.h:177: HELPER_to_uppercase(fname);
      000A66 85 82*13         [24] 2666 	mov	_HELPER_filename_to_8dot3filename_fname_65536_120,dpl
      000A69 85 83*14         [24] 2667 	mov	(_HELPER_filename_to_8dot3filename_fname_65536_120 + 1),dph
      000A6C 85 F0*15         [24] 2668 	mov	(_HELPER_filename_to_8dot3filename_fname_65536_120 + 2),b
      000A6F 12r0Ar29         [24] 2669 	lcall	_HELPER_to_uppercase
                                   2670 ;	fat.h:185: for(uint8_t i=0;i<11;i++) fname83[i]=' '; //default fill by empty space
      000A72 7C 00            [12] 2671 	mov	r4,#0x00
      000A74                       2672 00120$:
      000A74 BC 0B 00         [24] 2673 	cjne	r4,#0x0b,00178$
      000A77                       2674 00178$:
      000A77 50 18            [24] 2675 	jnc	00101$
      000A79 EC               [12] 2676 	mov	a,r4
      000A7A 25*10            [12] 2677 	add	a,_HELPER_filename_to_8dot3filename_PARM_2
      000A7C F9               [12] 2678 	mov	r1,a
      000A7D E4               [12] 2679 	clr	a
      000A7E 35*11            [12] 2680 	addc	a,(_HELPER_filename_to_8dot3filename_PARM_2 + 1)
      000A80 FA               [12] 2681 	mov	r2,a
      000A81 AB*12            [24] 2682 	mov	r3,(_HELPER_filename_to_8dot3filename_PARM_2 + 2)
      000A83 89 82            [24] 2683 	mov	dpl,r1
      000A85 8A 83            [24] 2684 	mov	dph,r2
      000A87 8B F0            [24] 2685 	mov	b,r3
      000A89 74 20            [12] 2686 	mov	a,#0x20
      000A8B 12r00r00         [24] 2687 	lcall	__gptrput
      000A8E 0C               [12] 2688 	inc	r4
      000A8F 80 E3            [24] 2689 	sjmp	00120$
      000A91                       2690 00101$:
                                   2691 ;	fat.h:186: fname83[11]=0; //set last character as 0;
      000A91 74 0B            [12] 2692 	mov	a,#0x0b
      000A93 25*10            [12] 2693 	add	a,_HELPER_filename_to_8dot3filename_PARM_2
      000A95 FA               [12] 2694 	mov	r2,a
      000A96 E4               [12] 2695 	clr	a
      000A97 35*11            [12] 2696 	addc	a,(_HELPER_filename_to_8dot3filename_PARM_2 + 1)
      000A99 FB               [12] 2697 	mov	r3,a
      000A9A AC*12            [24] 2698 	mov	r4,(_HELPER_filename_to_8dot3filename_PARM_2 + 2)
      000A9C 8A 82            [24] 2699 	mov	dpl,r2
      000A9E 8B 83            [24] 2700 	mov	dph,r3
      000AA0 8C F0            [24] 2701 	mov	b,r4
      000AA2 E4               [12] 2702 	clr	a
      000AA3 12r00r00         [24] 2703 	lcall	__gptrput
                                   2704 ;	fat.h:189: for(index=0;index<9;index++)
      000AA6 7C 00            [12] 2705 	mov	r4,#0x00
      000AA8 7B 00            [12] 2706 	mov	r3,#0x00
      000AAA                       2707 00122$:
                                   2708 ;	fat.h:192: if(index==8 && fname[index]!='.') 
      000AAA BB 08 1D         [24] 2709 	cjne	r3,#0x08,00103$
      000AAD EB               [12] 2710 	mov	a,r3
      000AAE 25*13            [12] 2711 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_120
      000AB0 F8               [12] 2712 	mov	r0,a
      000AB1 E4               [12] 2713 	clr	a
      000AB2 35*14            [12] 2714 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 1)
      000AB4 F9               [12] 2715 	mov	r1,a
      000AB5 AA*15            [24] 2716 	mov	r2,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 2)
      000AB7 88 82            [24] 2717 	mov	dpl,r0
      000AB9 89 83            [24] 2718 	mov	dph,r1
      000ABB 8A F0            [24] 2719 	mov	b,r2
      000ABD 12r00r00         [24] 2720 	lcall	__gptrget
      000AC0 F8               [12] 2721 	mov	r0,a
      000AC1 B8 2E 02         [24] 2722 	cjne	r0,#0x2e,00182$
      000AC4 80 04            [24] 2723 	sjmp	00103$
      000AC6                       2724 00182$:
                                   2725 ;	fat.h:197: return 1; //error - invalid filename as dot not found till 9th charcter
      000AC6 75 82 01         [24] 2726 	mov	dpl,#0x01
      000AC9 22               [24] 2727 	ret
      000ACA                       2728 00103$:
                                   2729 ;	fat.h:200: if(fname[index]==0) return 0; // success - we reached the end of the filename string before the dot character - filename has no extension
      000ACA EB               [12] 2730 	mov	a,r3
      000ACB 25*13            [12] 2731 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_120
      000ACD F8               [12] 2732 	mov	r0,a
      000ACE E4               [12] 2733 	clr	a
      000ACF 35*14            [12] 2734 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 1)
      000AD1 F9               [12] 2735 	mov	r1,a
      000AD2 AA*15            [24] 2736 	mov	r2,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 2)
      000AD4 88 82            [24] 2737 	mov	dpl,r0
      000AD6 89 83            [24] 2738 	mov	dph,r1
      000AD8 8A F0            [24] 2739 	mov	b,r2
      000ADA 12r00r00         [24] 2740 	lcall	__gptrget
      000ADD FA               [12] 2741 	mov	r2,a
      000ADE 70 03            [24] 2742 	jnz	00109$
      000AE0 F5 82            [12] 2743 	mov	dpl,a
      000AE2 22               [24] 2744 	ret
      000AE3                       2745 00109$:
                                   2746 ;	fat.h:201: else if(fname[index]=='.') break; //found the dot, break the for loop
      000AE3 BA 2E 02         [24] 2747 	cjne	r2,#0x2e,00184$
      000AE6 80 1C            [24] 2748 	sjmp	00140$
      000AE8                       2749 00184$:
                                   2750 ;	fat.h:202: else fname83[index]=fname[index];
      000AE8 EB               [12] 2751 	mov	a,r3
      000AE9 25*10            [12] 2752 	add	a,_HELPER_filename_to_8dot3filename_PARM_2
      000AEB F8               [12] 2753 	mov	r0,a
      000AEC E4               [12] 2754 	clr	a
      000AED 35*11            [12] 2755 	addc	a,(_HELPER_filename_to_8dot3filename_PARM_2 + 1)
      000AEF F9               [12] 2756 	mov	r1,a
      000AF0 AF*12            [24] 2757 	mov	r7,(_HELPER_filename_to_8dot3filename_PARM_2 + 2)
      000AF2 88 82            [24] 2758 	mov	dpl,r0
      000AF4 89 83            [24] 2759 	mov	dph,r1
      000AF6 8F F0            [24] 2760 	mov	b,r7
      000AF8 EA               [12] 2761 	mov	a,r2
      000AF9 12r00r00         [24] 2762 	lcall	__gptrput
                                   2763 ;	fat.h:189: for(index=0;index<9;index++)
      000AFC 0B               [12] 2764 	inc	r3
      000AFD 8B 04            [24] 2765 	mov	ar4,r3
      000AFF BB 09 00         [24] 2766 	cjne	r3,#0x09,00185$
      000B02                       2767 00185$:
      000B02 40 A6            [24] 2768 	jc	00122$
                                   2769 ;	fat.h:205: for(uint8_t i=0;i<4;i++)
      000B04                       2770 00140$:
      000B04 75*16 00         [24] 2771 	mov	_HELPER_filename_to_8dot3filename_i_131072_126,#0x00
      000B07                       2772 00125$:
      000B07 74 FC            [12] 2773 	mov	a,#0x100 - 0x04
      000B09 25*16            [12] 2774 	add	a,_HELPER_filename_to_8dot3filename_i_131072_126
      000B0B 50 03            [24] 2775 	jnc	00187$
      000B0D 02r0BrAA         [24] 2776 	ljmp	00118$
      000B10                       2777 00187$:
                                   2778 ;	fat.h:207: if(i==3 && fname[index+i+1]!=0) 
      000B10 74 03            [12] 2779 	mov	a,#0x03
      000B12 B5*16 2C         [24] 2780 	cjne	a,_HELPER_filename_to_8dot3filename_i_131072_126,00113$
      000B15 8C 05            [24] 2781 	mov	ar5,r4
      000B17 7E 00            [12] 2782 	mov	r6,#0x00
      000B19 AA*16            [24] 2783 	mov	r2,_HELPER_filename_to_8dot3filename_i_131072_126
      000B1B 7B 00            [12] 2784 	mov	r3,#0x00
      000B1D EA               [12] 2785 	mov	a,r2
      000B1E 2D               [12] 2786 	add	a,r5
      000B1F FD               [12] 2787 	mov	r5,a
      000B20 EB               [12] 2788 	mov	a,r3
      000B21 3E               [12] 2789 	addc	a,r6
      000B22 FE               [12] 2790 	mov	r6,a
      000B23 0D               [12] 2791 	inc	r5
      000B24 BD 00 01         [24] 2792 	cjne	r5,#0x00,00190$
      000B27 0E               [12] 2793 	inc	r6
      000B28                       2794 00190$:
      000B28 ED               [12] 2795 	mov	a,r5
      000B29 25*13            [12] 2796 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_120
      000B2B FD               [12] 2797 	mov	r5,a
      000B2C EE               [12] 2798 	mov	a,r6
      000B2D 35*14            [12] 2799 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 1)
      000B2F FE               [12] 2800 	mov	r6,a
      000B30 AB*15            [24] 2801 	mov	r3,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 2)
      000B32 8D 82            [24] 2802 	mov	dpl,r5
      000B34 8E 83            [24] 2803 	mov	dph,r6
      000B36 8B F0            [24] 2804 	mov	b,r3
      000B38 12r00r00         [24] 2805 	lcall	__gptrget
      000B3B 60 04            [24] 2806 	jz	00113$
                                   2807 ;	fat.h:212: return 2; // error - extension has more than 3 characters
      000B3D 75 82 02         [24] 2808 	mov	dpl,#0x02
      000B40 22               [24] 2809 	ret
      000B41                       2810 00113$:
                                   2811 ;	fat.h:216: if(fname[index+i+1]==0) 
      000B41 8C 05            [24] 2812 	mov	ar5,r4
      000B43 7E 00            [12] 2813 	mov	r6,#0x00
      000B45 AA*16            [24] 2814 	mov	r2,_HELPER_filename_to_8dot3filename_i_131072_126
      000B47 7B 00            [12] 2815 	mov	r3,#0x00
      000B49 EA               [12] 2816 	mov	a,r2
      000B4A 2D               [12] 2817 	add	a,r5
      000B4B F8               [12] 2818 	mov	r0,a
      000B4C EB               [12] 2819 	mov	a,r3
      000B4D 3E               [12] 2820 	addc	a,r6
      000B4E F9               [12] 2821 	mov	r1,a
      000B4F 08               [12] 2822 	inc	r0
      000B50 B8 00 01         [24] 2823 	cjne	r0,#0x00,00192$
      000B53 09               [12] 2824 	inc	r1
      000B54                       2825 00192$:
      000B54 E8               [12] 2826 	mov	a,r0
      000B55 25*13            [12] 2827 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_120
      000B57 F8               [12] 2828 	mov	r0,a
      000B58 E9               [12] 2829 	mov	a,r1
      000B59 35*14            [12] 2830 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 1)
      000B5B F9               [12] 2831 	mov	r1,a
      000B5C AF*15            [24] 2832 	mov	r7,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 2)
      000B5E 88 82            [24] 2833 	mov	dpl,r0
      000B60 89 83            [24] 2834 	mov	dph,r1
      000B62 8F F0            [24] 2835 	mov	b,r7
      000B64 12r00r00         [24] 2836 	lcall	__gptrget
                                   2837 ;	fat.h:225: return 0; 
      000B67 70 03            [24] 2838 	jnz	00116$
      000B69 F5 82            [12] 2839 	mov	dpl,a
      000B6B 22               [24] 2840 	ret
      000B6C                       2841 00116$:
                                   2842 ;	fat.h:227: else fname83[8+i]=fname[index+i+1]; // in a valid fname, there is just an extra dot in fname than in fname83
      000B6C 74 08            [12] 2843 	mov	a,#0x08
      000B6E 2A               [12] 2844 	add	a,r2
      000B6F F9               [12] 2845 	mov	r1,a
      000B70 E4               [12] 2846 	clr	a
      000B71 3B               [12] 2847 	addc	a,r3
      000B72 FF               [12] 2848 	mov	r7,a
      000B73 E9               [12] 2849 	mov	a,r1
      000B74 25*10            [12] 2850 	add	a,_HELPER_filename_to_8dot3filename_PARM_2
      000B76 F9               [12] 2851 	mov	r1,a
      000B77 EF               [12] 2852 	mov	a,r7
      000B78 35*11            [12] 2853 	addc	a,(_HELPER_filename_to_8dot3filename_PARM_2 + 1)
      000B7A F8               [12] 2854 	mov	r0,a
      000B7B AF*12            [24] 2855 	mov	r7,(_HELPER_filename_to_8dot3filename_PARM_2 + 2)
      000B7D EA               [12] 2856 	mov	a,r2
      000B7E 2D               [12] 2857 	add	a,r5
      000B7F FD               [12] 2858 	mov	r5,a
      000B80 EB               [12] 2859 	mov	a,r3
      000B81 3E               [12] 2860 	addc	a,r6
      000B82 FE               [12] 2861 	mov	r6,a
      000B83 0D               [12] 2862 	inc	r5
      000B84 BD 00 01         [24] 2863 	cjne	r5,#0x00,00194$
      000B87 0E               [12] 2864 	inc	r6
      000B88                       2865 00194$:
      000B88 ED               [12] 2866 	mov	a,r5
      000B89 25*13            [12] 2867 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_120
      000B8B FD               [12] 2868 	mov	r5,a
      000B8C EE               [12] 2869 	mov	a,r6
      000B8D 35*14            [12] 2870 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 1)
      000B8F FE               [12] 2871 	mov	r6,a
      000B90 AB*15            [24] 2872 	mov	r3,(_HELPER_filename_to_8dot3filename_fname_65536_120 + 2)
      000B92 8D 82            [24] 2873 	mov	dpl,r5
      000B94 8E 83            [24] 2874 	mov	dph,r6
      000B96 8B F0            [24] 2875 	mov	b,r3
      000B98 12r00r00         [24] 2876 	lcall	__gptrget
      000B9B FD               [12] 2877 	mov	r5,a
      000B9C 89 82            [24] 2878 	mov	dpl,r1
      000B9E 88 83            [24] 2879 	mov	dph,r0
      000BA0 8F F0            [24] 2880 	mov	b,r7
      000BA2 12r00r00         [24] 2881 	lcall	__gptrput
                                   2882 ;	fat.h:205: for(uint8_t i=0;i<4;i++)
      000BA5 05*16            [12] 2883 	inc	_HELPER_filename_to_8dot3filename_i_131072_126
      000BA7 02r0Br07         [24] 2884 	ljmp	00125$
      000BAA                       2885 00118$:
                                   2886 ;	fat.h:230: return 3;// if reached here, then it is an error
      000BAA 75 82 03         [24] 2887 	mov	dpl,#0x03
                                   2888 ;	fat.h:231: }
      000BAD 22               [24] 2889 	ret
                                   2890 ;------------------------------------------------------------
                                   2891 ;Allocation info for local variables in function 'MBR_CHECK__SIGNATURE'
                                   2892 ;------------------------------------------------------------
                                   2893 ;signature                 Allocated to stack - _bp +1
                                   2894 ;------------------------------------------------------------
                                   2895 ;	fat.h:245: uint8_t MBR_CHECK__SIGNATURE() __reentrant
                                   2896 ;	-----------------------------------------
                                   2897 ;	 function MBR_CHECK__SIGNATURE
                                   2898 ;	-----------------------------------------
      000BAE                       2899 _MBR_CHECK__SIGNATURE:
      000BAE C0*00            [24] 2900 	push	_bp
      000BB0 85 81*00         [24] 2901 	mov	_bp,sp
      000BB3 05 81            [12] 2902 	inc	sp
      000BB5 05 81            [12] 2903 	inc	sp
                                   2904 ;	fat.h:248: SDread(0,510,2,signature);
      000BB7 A9*00            [24] 2905 	mov	r1,_bp
      000BB9 09               [12] 2906 	inc	r1
      000BBA 89 05            [24] 2907 	mov	ar5,r1
      000BBC 7E 00            [12] 2908 	mov	r6,#0x00
      000BBE 7F 40            [12] 2909 	mov	r7,#0x40
      000BC0 C0 01            [24] 2910 	push	ar1
      000BC2 C0 05            [24] 2911 	push	ar5
      000BC4 C0 06            [24] 2912 	push	ar6
      000BC6 C0 07            [24] 2913 	push	ar7
      000BC8 74 02            [12] 2914 	mov	a,#0x02
      000BCA C0 E0            [24] 2915 	push	acc
      000BCC E4               [12] 2916 	clr	a
      000BCD C0 E0            [24] 2917 	push	acc
      000BCF 74 FE            [12] 2918 	mov	a,#0xfe
      000BD1 C0 E0            [24] 2919 	push	acc
      000BD3 F4               [12] 2920 	cpl	a
      000BD4 C0 E0            [24] 2921 	push	acc
      000BD6 90 00 00         [24] 2922 	mov	dptr,#(0x00&0x00ff)
      000BD9 E4               [12] 2923 	clr	a
      000BDA F5 F0            [12] 2924 	mov	b,a
      000BDC 12r06rDE         [24] 2925 	lcall	_SDread
      000BDF E5 81            [12] 2926 	mov	a,sp
      000BE1 24 F9            [12] 2927 	add	a,#0xf9
      000BE3 F5 81            [12] 2928 	mov	sp,a
      000BE5 D0 01            [24] 2929 	pop	ar1
                                   2930 ;	fat.h:257: if(signature[0]==0x55 && signature[1]==0xAA) return 0;
      000BE7 87 07            [24] 2931 	mov	ar7,@r1
      000BE9 BF 55 0B         [24] 2932 	cjne	r7,#0x55,00102$
      000BEC 09               [12] 2933 	inc	r1
      000BED 87 07            [24] 2934 	mov	ar7,@r1
      000BEF BF AA 05         [24] 2935 	cjne	r7,#0xaa,00102$
      000BF2 75 82 00         [24] 2936 	mov	dpl,#0x00
      000BF5 80 03            [24] 2937 	sjmp	00105$
      000BF7                       2938 00102$:
                                   2939 ;	fat.h:258: else return 1;
      000BF7 75 82 01         [24] 2940 	mov	dpl,#0x01
      000BFA                       2941 00105$:
                                   2942 ;	fat.h:259: }
      000BFA 85*00 81         [24] 2943 	mov	sp,_bp
      000BFD D0*00            [24] 2944 	pop	_bp
      000BFF 22               [24] 2945 	ret
                                   2946 ;------------------------------------------------------------
                                   2947 ;Allocation info for local variables in function 'MBR_LOAD_PARTITION_TABLE_ENTRY'
                                   2948 ;------------------------------------------------------------
                                   2949 ;partition_number          Allocated to registers r7 
                                   2950 ;temp                      Allocated with name '_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_132'
                                   2951 ;offset                    Allocated to registers r5 r6 
                                   2952 ;------------------------------------------------------------
                                   2953 ;	fat.h:261: uint8_t MBR_LOAD_PARTITION_TABLE_ENTRY(uint8_t partition_number)
                                   2954 ;	-----------------------------------------
                                   2955 ;	 function MBR_LOAD_PARTITION_TABLE_ENTRY
                                   2956 ;	-----------------------------------------
      000C00                       2957 _MBR_LOAD_PARTITION_TABLE_ENTRY:
      000C00 AF 82            [24] 2958 	mov	r7,dpl
                                   2959 ;	fat.h:264: __idata uint16_t offset= 446 + partition_number*16; // get to the nth partition entry out of 0,1,2,3
      000C02 8F 05            [24] 2960 	mov	ar5,r7
      000C04 E4               [12] 2961 	clr	a
      000C05 CD               [12] 2962 	xch	a,r5
      000C06 C4               [12] 2963 	swap	a
      000C07 CD               [12] 2964 	xch	a,r5
      000C08 6D               [12] 2965 	xrl	a,r5
      000C09 CD               [12] 2966 	xch	a,r5
      000C0A 54 F0            [12] 2967 	anl	a,#0xf0
      000C0C CD               [12] 2968 	xch	a,r5
      000C0D 6D               [12] 2969 	xrl	a,r5
      000C0E FE               [12] 2970 	mov	r6,a
      000C0F 74 BE            [12] 2971 	mov	a,#0xbe
      000C11 2D               [12] 2972 	add	a,r5
      000C12 FD               [12] 2973 	mov	r5,a
      000C13 74 01            [12] 2974 	mov	a,#0x01
      000C15 3E               [12] 2975 	addc	a,r6
      000C16 FE               [12] 2976 	mov	r6,a
                                   2977 ;	fat.h:266: if(partition_number>4) 
      000C17 EF               [12] 2978 	mov	a,r7
      000C18 24 FB            [12] 2979 	add	a,#0xff - 0x04
      000C1A 50 04            [24] 2980 	jnc	00102$
                                   2981 ;	fat.h:273: return 1; //error
      000C1C 75 82 01         [24] 2982 	mov	dpl,#0x01
      000C1F 22               [24] 2983 	ret
      000C20                       2984 00102$:
                                   2985 ;	fat.h:276: SDread(0,offset,16,temp);
      000C20 74r41            [12] 2986 	mov	a,#_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_132
      000C22 C0 E0            [24] 2987 	push	acc
      000C24 74s00            [12] 2988 	mov	a,#(_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_132 >> 8)
      000C26 C0 E0            [24] 2989 	push	acc
      000C28 74 40            [12] 2990 	mov	a,#0x40
      000C2A C0 E0            [24] 2991 	push	acc
      000C2C 74 10            [12] 2992 	mov	a,#0x10
      000C2E C0 E0            [24] 2993 	push	acc
      000C30 E4               [12] 2994 	clr	a
      000C31 C0 E0            [24] 2995 	push	acc
      000C33 C0 05            [24] 2996 	push	ar5
      000C35 C0 06            [24] 2997 	push	ar6
      000C37 90 00 00         [24] 2998 	mov	dptr,#(0x00&0x00ff)
      000C3A E4               [12] 2999 	clr	a
      000C3B F5 F0            [12] 3000 	mov	b,a
      000C3D 12r06rDE         [24] 3001 	lcall	_SDread
      000C40 E5 81            [12] 3002 	mov	a,sp
      000C42 24 F9            [12] 3003 	add	a,#0xf9
      000C44 F5 81            [12] 3004 	mov	sp,a
                                   3005 ;	fat.h:278: __global_partitionTableEntry.type = temp[4]; // type offset is 4
      000C46 78r45            [12] 3006 	mov	r0,#(_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_132 + 0x0004)
      000C48 86 07            [24] 3007 	mov	ar7,@r0
      000C4A 78r00            [12] 3008 	mov	r0,#___global_partitionTableEntry
      000C4C A6 07            [24] 3009 	mov	@r0,ar7
                                   3010 ;	fat.h:279: __global_partitionTableEntry.start=HELPER_load_littleendian32(&temp[8]); //partition start LBA offset is 8
      000C4E 90r00r49         [24] 3011 	mov	dptr,#(_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_132 + 0x0008)
      000C51 75 F0 40         [24] 3012 	mov	b,#0x40
      000C54 12r08r52         [24] 3013 	lcall	_HELPER_load_littleendian32
      000C57 AC 82            [24] 3014 	mov	r4,dpl
      000C59 AD 83            [24] 3015 	mov	r5,dph
      000C5B AE F0            [24] 3016 	mov	r6,b
      000C5D FF               [12] 3017 	mov	r7,a
      000C5E 78r01            [12] 3018 	mov	r0,#(___global_partitionTableEntry + 0x0001)
      000C60 A6 04            [24] 3019 	mov	@r0,ar4
      000C62 08               [12] 3020 	inc	r0
      000C63 A6 05            [24] 3021 	mov	@r0,ar5
      000C65 08               [12] 3022 	inc	r0
      000C66 A6 06            [24] 3023 	mov	@r0,ar6
      000C68 08               [12] 3024 	inc	r0
      000C69 A6 07            [24] 3025 	mov	@r0,ar7
                                   3026 ;	fat.h:280: __global_partitionTableEntry.size=HELPER_load_littleendian32(&temp[12]); //partiiton size offset is 12
      000C6B 90r00r4D         [24] 3027 	mov	dptr,#(_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_132 + 0x000c)
      000C6E 75 F0 40         [24] 3028 	mov	b,#0x40
      000C71 12r08r52         [24] 3029 	lcall	_HELPER_load_littleendian32
      000C74 AC 82            [24] 3030 	mov	r4,dpl
      000C76 AD 83            [24] 3031 	mov	r5,dph
      000C78 AE F0            [24] 3032 	mov	r6,b
      000C7A FF               [12] 3033 	mov	r7,a
      000C7B 78r05            [12] 3034 	mov	r0,#(___global_partitionTableEntry + 0x0005)
      000C7D A6 04            [24] 3035 	mov	@r0,ar4
      000C7F 08               [12] 3036 	inc	r0
      000C80 A6 05            [24] 3037 	mov	@r0,ar5
      000C82 08               [12] 3038 	inc	r0
      000C83 A6 06            [24] 3039 	mov	@r0,ar6
      000C85 08               [12] 3040 	inc	r0
      000C86 A6 07            [24] 3041 	mov	@r0,ar7
                                   3042 ;	fat.h:282: return 0;
      000C88 75 82 00         [24] 3043 	mov	dpl,#0x00
                                   3044 ;	fat.h:284: }
      000C8B 22               [24] 3045 	ret
                                   3046 ;------------------------------------------------------------
                                   3047 ;Allocation info for local variables in function 'MBR_DETECT_FAT16'
                                   3048 ;------------------------------------------------------------
                                   3049 ;result                    Allocated to registers r7 
                                   3050 ;i                         Allocated to registers r6 
                                   3051 ;------------------------------------------------------------
                                   3052 ;	fat.h:286: uint8_t MBR_DETECT_FAT16()
                                   3053 ;	-----------------------------------------
                                   3054 ;	 function MBR_DETECT_FAT16
                                   3055 ;	-----------------------------------------
      000C8C                       3056 _MBR_DETECT_FAT16:
                                   3057 ;	fat.h:291: uint8_t result=0;
      000C8C 7F 00            [12] 3058 	mov	r7,#0x00
                                   3059 ;	fat.h:293: for(uint8_t i=0;i<4;i++) 
      000C8E 7E 00            [12] 3060 	mov	r6,#0x00
      000C90                       3061 00105$:
      000C90 BE 04 00         [24] 3062 	cjne	r6,#0x04,00122$
      000C93                       3063 00122$:
      000C93 50 2B            [24] 3064 	jnc	00103$
                                   3065 ;	fat.h:295: MBR_LOAD_PARTITION_TABLE_ENTRY(i);
      000C95 8E 82            [24] 3066 	mov	dpl,r6
      000C97 C0 07            [24] 3067 	push	ar7
      000C99 C0 06            [24] 3068 	push	ar6
      000C9B 12r0Cr00         [24] 3069 	lcall	_MBR_LOAD_PARTITION_TABLE_ENTRY
      000C9E D0 06            [24] 3070 	pop	ar6
      000CA0 D0 07            [24] 3071 	pop	ar7
                                   3072 ;	fat.h:296: if(__global_partitionTableEntry.type==FAT16_PARTITION_TYPE_ID) result |= (1<<i); //set corresponding bit
      000CA2 78r00            [12] 3073 	mov	r0,#___global_partitionTableEntry
      000CA4 86 05            [24] 3074 	mov	ar5,@r0
      000CA6 BD 06 14         [24] 3075 	cjne	r5,#0x06,00106$
      000CA9 8E 05            [24] 3076 	mov	ar5,r6
      000CAB 8D F0            [24] 3077 	mov	b,r5
      000CAD 05 F0            [12] 3078 	inc	b
      000CAF 74 01            [12] 3079 	mov	a,#0x01
      000CB1 80 02            [24] 3080 	sjmp	00128$
      000CB3                       3081 00126$:
      000CB3 25 E0            [12] 3082 	add	a,acc
      000CB5                       3083 00128$:
      000CB5 D5 F0 FB         [24] 3084 	djnz	b,00126$
      000CB8 FD               [12] 3085 	mov	r5,a
      000CB9 8F 04            [24] 3086 	mov	ar4,r7
      000CBB 4C               [12] 3087 	orl	a,r4
      000CBC FF               [12] 3088 	mov	r7,a
      000CBD                       3089 00106$:
                                   3090 ;	fat.h:293: for(uint8_t i=0;i<4;i++) 
      000CBD 0E               [12] 3091 	inc	r6
      000CBE 80 D0            [24] 3092 	sjmp	00105$
      000CC0                       3093 00103$:
                                   3094 ;	fat.h:305: return result;
      000CC0 8F 82            [24] 3095 	mov	dpl,r7
                                   3096 ;	fat.h:306: }
      000CC2 22               [24] 3097 	ret
                                   3098 ;------------------------------------------------------------
                                   3099 ;Allocation info for local variables in function 'VBR_MOUNT_VBR'
                                   3100 ;------------------------------------------------------------
                                   3101 ;partition_number          Allocated to registers r7 
                                   3102 ;sloc0                     Allocated with name '_VBR_MOUNT_VBR_sloc0_1_0'
                                   3103 ;temp                      Allocated with name '_VBR_MOUNT_VBR_temp_65536_138'
                                   3104 ;------------------------------------------------------------
                                   3105 ;	fat.h:332: uint8_t VBR_MOUNT_VBR(uint8_t partition_number)
                                   3106 ;	-----------------------------------------
                                   3107 ;	 function VBR_MOUNT_VBR
                                   3108 ;	-----------------------------------------
      000CC3                       3109 _VBR_MOUNT_VBR:
      000CC3 AF 82            [24] 3110 	mov	r7,dpl
                                   3111 ;	fat.h:338: if(__global_nthPartitionVBRmounted == partition_number ) 
      000CC5 78r28            [12] 3112 	mov	r0,#___global_nthPartitionVBRmounted
      000CC7 E6               [12] 3113 	mov	a,@r0
      000CC8 B5 07 04         [24] 3114 	cjne	a,ar7,00102$
                                   3115 ;	fat.h:346: return 0; //return if already loaded, else continue;
      000CCB 75 82 00         [24] 3116 	mov	dpl,#0x00
      000CCE 22               [24] 3117 	ret
      000CCF                       3118 00102$:
                                   3119 ;	fat.h:357: __global_nthPartitionVBRmounted=partition_number; //set global variable
      000CCF 78r28            [12] 3120 	mov	r0,#___global_nthPartitionVBRmounted
      000CD1 A6 07            [24] 3121 	mov	@r0,ar7
                                   3122 ;	fat.h:360: if(MBR_LOAD_PARTITION_TABLE_ENTRY(partition_number))  //if error, 0 is success
      000CD3 8F 82            [24] 3123 	mov	dpl,r7
      000CD5 12r0Cr00         [24] 3124 	lcall	_MBR_LOAD_PARTITION_TABLE_ENTRY
      000CD8 E5 82            [12] 3125 	mov	a,dpl
      000CDA 60 04            [24] 3126 	jz	00104$
                                   3127 ;	fat.h:362: return 1; //return error
      000CDC 75 82 01         [24] 3128 	mov	dpl,#0x01
      000CDF 22               [24] 3129 	ret
      000CE0                       3130 00104$:
                                   3131 ;	fat.h:366: SDread(__global_partitionTableEntry.start,0,16,temp);
      000CE0 78r01            [12] 3132 	mov	r0,#(___global_partitionTableEntry + 0x0001)
      000CE2 86 04            [24] 3133 	mov	ar4,@r0
      000CE4 08               [12] 3134 	inc	r0
      000CE5 86 05            [24] 3135 	mov	ar5,@r0
      000CE7 08               [12] 3136 	inc	r0
      000CE8 86 06            [24] 3137 	mov	ar6,@r0
      000CEA 08               [12] 3138 	inc	r0
      000CEB 86 07            [24] 3139 	mov	ar7,@r0
      000CED 74r51            [12] 3140 	mov	a,#_VBR_MOUNT_VBR_temp_65536_138
      000CEF C0 E0            [24] 3141 	push	acc
      000CF1 74s00            [12] 3142 	mov	a,#(_VBR_MOUNT_VBR_temp_65536_138 >> 8)
      000CF3 C0 E0            [24] 3143 	push	acc
      000CF5 74 40            [12] 3144 	mov	a,#0x40
      000CF7 C0 E0            [24] 3145 	push	acc
      000CF9 74 10            [12] 3146 	mov	a,#0x10
      000CFB C0 E0            [24] 3147 	push	acc
      000CFD E4               [12] 3148 	clr	a
      000CFE C0 E0            [24] 3149 	push	acc
      000D00 C0 E0            [24] 3150 	push	acc
      000D02 C0 E0            [24] 3151 	push	acc
      000D04 8C 82            [24] 3152 	mov	dpl,r4
      000D06 8D 83            [24] 3153 	mov	dph,r5
      000D08 8E F0            [24] 3154 	mov	b,r6
      000D0A EF               [12] 3155 	mov	a,r7
      000D0B 12r06rDE         [24] 3156 	lcall	_SDread
      000D0E E5 81            [12] 3157 	mov	a,sp
      000D10 24 F9            [12] 3158 	add	a,#0xf9
      000D12 F5 81            [12] 3159 	mov	sp,a
                                   3160 ;	fat.h:375: __global_vbr.volumeStartSector = __global_partitionTableEntry.start;
      000D14 78r01            [12] 3161 	mov	r0,#(___global_partitionTableEntry + 0x0001)
      000D16 86 04            [24] 3162 	mov	ar4,@r0
      000D18 08               [12] 3163 	inc	r0
      000D19 86 05            [24] 3164 	mov	ar5,@r0
      000D1B 08               [12] 3165 	inc	r0
      000D1C 86 06            [24] 3166 	mov	ar6,@r0
      000D1E 08               [12] 3167 	inc	r0
      000D1F 86 07            [24] 3168 	mov	ar7,@r0
      000D21 78r09            [12] 3169 	mov	r0,#___global_vbr
      000D23 A6 04            [24] 3170 	mov	@r0,ar4
      000D25 08               [12] 3171 	inc	r0
      000D26 A6 05            [24] 3172 	mov	@r0,ar5
      000D28 08               [12] 3173 	inc	r0
      000D29 A6 06            [24] 3174 	mov	@r0,ar6
      000D2B 08               [12] 3175 	inc	r0
      000D2C A6 07            [24] 3176 	mov	@r0,ar7
                                   3177 ;	fat.h:377: __global_vbr.bps = HELPER_load_littleendian16(&temp[0x0b]); // bps starts at offset 0x0b
      000D2E 90r00r5C         [24] 3178 	mov	dptr,#(_VBR_MOUNT_VBR_temp_65536_138 + 0x000b)
      000D31 75 F0 40         [24] 3179 	mov	b,#0x40
      000D34 12r08r24         [24] 3180 	lcall	_HELPER_load_littleendian16
      000D37 E5 82            [12] 3181 	mov	a,dpl
      000D39 85 83 F0         [24] 3182 	mov	b,dph
      000D3C 78r0F            [12] 3183 	mov	r0,#(___global_vbr + 0x0006)
      000D3E F6               [12] 3184 	mov	@r0,a
      000D3F 08               [12] 3185 	inc	r0
      000D40 A6 F0            [24] 3186 	mov	@r0,b
                                   3187 ;	fat.h:378: __global_vbr.spc = temp[0x0d]; //spc offset 0x0d
      000D42 78r5E            [12] 3188 	mov	r0,#(_VBR_MOUNT_VBR_temp_65536_138 + 0x000d)
      000D44 86 07            [24] 3189 	mov	ar7,@r0
      000D46 78r11            [12] 3190 	mov	r0,#(___global_vbr + 0x0008)
      000D48 A6 07            [24] 3191 	mov	@r0,ar7
                                   3192 ;	fat.h:379: __global_vbr.reservedSectors = HELPER_load_littleendian16(&temp[0x0e]);
      000D4A 90r00r5F         [24] 3193 	mov	dptr,#(_VBR_MOUNT_VBR_temp_65536_138 + 0x000e)
      000D4D 75 F0 40         [24] 3194 	mov	b,#0x40
      000D50 12r08r24         [24] 3195 	lcall	_HELPER_load_littleendian16
      000D53 E5 82            [12] 3196 	mov	a,dpl
      000D55 85 83 F0         [24] 3197 	mov	b,dph
      000D58 78r0D            [12] 3198 	mov	r0,#(___global_vbr + 0x0004)
      000D5A F6               [12] 3199 	mov	@r0,a
      000D5B 08               [12] 3200 	inc	r0
      000D5C A6 F0            [24] 3201 	mov	@r0,b
                                   3202 ;	fat.h:383: SDread(__global_partitionTableEntry.start,16,16,temp);
      000D5E 78r01            [12] 3203 	mov	r0,#(___global_partitionTableEntry + 0x0001)
      000D60 86 04            [24] 3204 	mov	ar4,@r0
      000D62 08               [12] 3205 	inc	r0
      000D63 86 05            [24] 3206 	mov	ar5,@r0
      000D65 08               [12] 3207 	inc	r0
      000D66 86 06            [24] 3208 	mov	ar6,@r0
      000D68 08               [12] 3209 	inc	r0
      000D69 86 07            [24] 3210 	mov	ar7,@r0
      000D6B 74r51            [12] 3211 	mov	a,#_VBR_MOUNT_VBR_temp_65536_138
      000D6D C0 E0            [24] 3212 	push	acc
      000D6F 74s00            [12] 3213 	mov	a,#(_VBR_MOUNT_VBR_temp_65536_138 >> 8)
      000D71 C0 E0            [24] 3214 	push	acc
      000D73 74 40            [12] 3215 	mov	a,#0x40
      000D75 C0 E0            [24] 3216 	push	acc
      000D77 74 10            [12] 3217 	mov	a,#0x10
      000D79 C0 E0            [24] 3218 	push	acc
      000D7B E4               [12] 3219 	clr	a
      000D7C C0 E0            [24] 3220 	push	acc
      000D7E 74 10            [12] 3221 	mov	a,#0x10
      000D80 C0 E0            [24] 3222 	push	acc
      000D82 E4               [12] 3223 	clr	a
      000D83 C0 E0            [24] 3224 	push	acc
      000D85 8C 82            [24] 3225 	mov	dpl,r4
      000D87 8D 83            [24] 3226 	mov	dph,r5
      000D89 8E F0            [24] 3227 	mov	b,r6
      000D8B EF               [12] 3228 	mov	a,r7
      000D8C 12r06rDE         [24] 3229 	lcall	_SDread
      000D8F E5 81            [12] 3230 	mov	a,sp
      000D91 24 F9            [12] 3231 	add	a,#0xf9
      000D93 F5 81            [12] 3232 	mov	sp,a
                                   3233 ;	fat.h:392: __global_vbr.nfat = HELPER_load_littleendian16(&temp[0x10-16]); //offset of nfat is 0x01, but we subtract 16 as we have read from 16 offset in SDread
      000D95 90r00r51         [24] 3234 	mov	dptr,#_VBR_MOUNT_VBR_temp_65536_138
      000D98 75 F0 40         [24] 3235 	mov	b,#0x40
      000D9B 12r08r24         [24] 3236 	lcall	_HELPER_load_littleendian16
      000D9E E5 82            [12] 3237 	mov	a,dpl
      000DA0 85 83 F0         [24] 3238 	mov	b,dph
      000DA3 78r12            [12] 3239 	mov	r0,#(___global_vbr + 0x0009)
      000DA5 F6               [12] 3240 	mov	@r0,a
      000DA6 08               [12] 3241 	inc	r0
      000DA7 A6 F0            [24] 3242 	mov	@r0,b
                                   3243 ;	fat.h:393: __global_vbr.nroote = HELPER_load_littleendian16(&temp[0x11-16]); //offset of number_root_entrie is 0x11
      000DA9 90r00r52         [24] 3244 	mov	dptr,#(_VBR_MOUNT_VBR_temp_65536_138 + 0x0001)
      000DAC 75 F0 40         [24] 3245 	mov	b,#0x40
      000DAF 12r08r24         [24] 3246 	lcall	_HELPER_load_littleendian16
      000DB2 E5 82            [12] 3247 	mov	a,dpl
      000DB4 85 83 F0         [24] 3248 	mov	b,dph
      000DB7 78r16            [12] 3249 	mov	r0,#(___global_vbr + 0x000d)
      000DB9 F6               [12] 3250 	mov	@r0,a
      000DBA 08               [12] 3251 	inc	r0
      000DBB A6 F0            [24] 3252 	mov	@r0,b
                                   3253 ;	fat.h:394: __global_vbr.spf = HELPER_load_littleendian16(&temp[0x16-16]); //offset of sectors_per_fat is 0x16
      000DBD 90r00r57         [24] 3254 	mov	dptr,#(_VBR_MOUNT_VBR_temp_65536_138 + 0x0006)
      000DC0 75 F0 40         [24] 3255 	mov	b,#0x40
      000DC3 12r08r24         [24] 3256 	lcall	_HELPER_load_littleendian16
      000DC6 AE 82            [24] 3257 	mov	r6,dpl
      000DC8 AF 83            [24] 3258 	mov	r7,dph
      000DCA 78r14            [12] 3259 	mov	r0,#(___global_vbr + 0x000b)
      000DCC A6 06            [24] 3260 	mov	@r0,ar6
      000DCE 08               [12] 3261 	inc	r0
      000DCF A6 07            [24] 3262 	mov	@r0,ar7
                                   3263 ;	fat.h:403: __global_vbr.bpc =  (uint32_t)__global_vbr.bps * (uint32_t)__global_vbr.spc; 
      000DD1 78r0F            [12] 3264 	mov	r0,#(___global_vbr + 0x0006)
      000DD3 86 04            [24] 3265 	mov	ar4,@r0
      000DD5 08               [12] 3266 	inc	r0
      000DD6 86 05            [24] 3267 	mov	ar5,@r0
      000DD8 8C*17            [24] 3268 	mov	_VBR_MOUNT_VBR_sloc0_1_0,r4
      000DDA 8D*18            [24] 3269 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 1),r5
      000DDC 75*19 00         [24] 3270 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 2),#0x00
      000DDF 75*1A 00         [24] 3271 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 3),#0x00
      000DE2 78r11            [12] 3272 	mov	r0,#(___global_vbr + 0x0008)
      000DE4 86 05            [24] 3273 	mov	ar5,@r0
      000DE6 8D*00            [24] 3274 	mov	__mullong_PARM_2,r5
      000DE8 75*01 00         [24] 3275 	mov	(__mullong_PARM_2 + 1),#0x00
      000DEB 75*02 00         [24] 3276 	mov	(__mullong_PARM_2 + 2),#0x00
      000DEE 75*03 00         [24] 3277 	mov	(__mullong_PARM_2 + 3),#0x00
      000DF1 85*17 82         [24] 3278 	mov	dpl,_VBR_MOUNT_VBR_sloc0_1_0
      000DF4 85*18 83         [24] 3279 	mov	dph,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000DF7 85*19 F0         [24] 3280 	mov	b,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000DFA E5*1A            [12] 3281 	mov	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
      000DFC C0 07            [24] 3282 	push	ar7
      000DFE C0 06            [24] 3283 	push	ar6
      000E00 12r00r00         [24] 3284 	lcall	__mullong
      000E03 AA 82            [24] 3285 	mov	r2,dpl
      000E05 AB 83            [24] 3286 	mov	r3,dph
      000E07 AC F0            [24] 3287 	mov	r4,b
      000E09 FD               [12] 3288 	mov	r5,a
      000E0A D0 06            [24] 3289 	pop	ar6
      000E0C D0 07            [24] 3290 	pop	ar7
      000E0E 78r18            [12] 3291 	mov	r0,#(___global_vbr + 0x000f)
      000E10 A6 02            [24] 3292 	mov	@r0,ar2
      000E12 08               [12] 3293 	inc	r0
      000E13 A6 03            [24] 3294 	mov	@r0,ar3
      000E15 08               [12] 3295 	inc	r0
      000E16 A6 04            [24] 3296 	mov	@r0,ar4
      000E18 08               [12] 3297 	inc	r0
      000E19 A6 05            [24] 3298 	mov	@r0,ar5
                                   3299 ;	fat.h:406: __global_vbr.addr_fat_start = __global_vbr.volumeStartSector + __global_vbr.reservedSectors;
      000E1B 78r09            [12] 3300 	mov	r0,#___global_vbr
      000E1D 86*17            [24] 3301 	mov	_VBR_MOUNT_VBR_sloc0_1_0,@r0
      000E1F 08               [12] 3302 	inc	r0
      000E20 86*18            [24] 3303 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 1),@r0
      000E22 08               [12] 3304 	inc	r0
      000E23 86*19            [24] 3305 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 2),@r0
      000E25 08               [12] 3306 	inc	r0
      000E26 86*1A            [24] 3307 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 3),@r0
      000E28 78r0D            [12] 3308 	mov	r0,#(___global_vbr + 0x0004)
      000E2A 86 04            [24] 3309 	mov	ar4,@r0
      000E2C 08               [12] 3310 	inc	r0
      000E2D 86 05            [24] 3311 	mov	ar5,@r0
      000E2F E4               [12] 3312 	clr	a
      000E30 FB               [12] 3313 	mov	r3,a
      000E31 FA               [12] 3314 	mov	r2,a
      000E32 EC               [12] 3315 	mov	a,r4
      000E33 25*17            [12] 3316 	add	a,_VBR_MOUNT_VBR_sloc0_1_0
      000E35 F5*17            [12] 3317 	mov	_VBR_MOUNT_VBR_sloc0_1_0,a
      000E37 ED               [12] 3318 	mov	a,r5
      000E38 35*18            [12] 3319 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000E3A F5*18            [12] 3320 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 1),a
      000E3C EB               [12] 3321 	mov	a,r3
      000E3D 35*19            [12] 3322 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000E3F F5*19            [12] 3323 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 2),a
      000E41 EA               [12] 3324 	mov	a,r2
      000E42 35*1A            [12] 3325 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
      000E44 F5*1A            [12] 3326 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 3),a
      000E46 78r1C            [12] 3327 	mov	r0,#(___global_vbr + 0x0013)
      000E48 A6*17            [24] 3328 	mov	@r0,_VBR_MOUNT_VBR_sloc0_1_0
      000E4A 08               [12] 3329 	inc	r0
      000E4B A6*18            [24] 3330 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000E4D 08               [12] 3331 	inc	r0
      000E4E A6*19            [24] 3332 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000E50 08               [12] 3333 	inc	r0
      000E51 A6*1A            [24] 3334 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
                                   3335 ;	fat.h:407: __global_vbr.addr_roote_start = __global_vbr.addr_fat_start + __global_vbr.nfat * __global_vbr.spf;
      000E53 78r12            [12] 3336 	mov	r0,#(___global_vbr + 0x0009)
      000E55 86 82            [24] 3337 	mov	dpl,@r0
      000E57 08               [12] 3338 	inc	r0
      000E58 86 83            [24] 3339 	mov	dph,@r0
      000E5A 8E*00            [24] 3340 	mov	__mulint_PARM_2,r6
      000E5C 8F*01            [24] 3341 	mov	(__mulint_PARM_2 + 1),r7
      000E5E 12r00r00         [24] 3342 	lcall	__mulint
      000E61 AE 82            [24] 3343 	mov	r6,dpl
      000E63 AF 83            [24] 3344 	mov	r7,dph
      000E65 8E 04            [24] 3345 	mov	ar4,r6
      000E67 8F 05            [24] 3346 	mov	ar5,r7
      000E69 E4               [12] 3347 	clr	a
      000E6A FE               [12] 3348 	mov	r6,a
      000E6B FF               [12] 3349 	mov	r7,a
      000E6C EC               [12] 3350 	mov	a,r4
      000E6D 25*17            [12] 3351 	add	a,_VBR_MOUNT_VBR_sloc0_1_0
      000E6F F5*17            [12] 3352 	mov	_VBR_MOUNT_VBR_sloc0_1_0,a
      000E71 ED               [12] 3353 	mov	a,r5
      000E72 35*18            [12] 3354 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000E74 F5*18            [12] 3355 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 1),a
      000E76 EE               [12] 3356 	mov	a,r6
      000E77 35*19            [12] 3357 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000E79 F5*19            [12] 3358 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 2),a
      000E7B EF               [12] 3359 	mov	a,r7
      000E7C 35*1A            [12] 3360 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
      000E7E F5*1A            [12] 3361 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 3),a
      000E80 78r20            [12] 3362 	mov	r0,#(___global_vbr + 0x0017)
      000E82 A6*17            [24] 3363 	mov	@r0,_VBR_MOUNT_VBR_sloc0_1_0
      000E84 08               [12] 3364 	inc	r0
      000E85 A6*18            [24] 3365 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000E87 08               [12] 3366 	inc	r0
      000E88 A6*19            [24] 3367 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000E8A 08               [12] 3368 	inc	r0
      000E8B A6*1A            [24] 3369 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
                                   3370 ;	fat.h:408: __global_vbr.addr_data_start = __global_vbr.addr_roote_start + (__global_vbr.nroote*32)/__global_vbr.bps;
      000E8D 78r16            [12] 3371 	mov	r0,#(___global_vbr + 0x000d)
      000E8F 86 02            [24] 3372 	mov	ar2,@r0
      000E91 08               [12] 3373 	inc	r0
      000E92 86 03            [24] 3374 	mov	ar3,@r0
      000E94 8A 82            [24] 3375 	mov	dpl,r2
      000E96 EB               [12] 3376 	mov	a,r3
      000E97 C4               [12] 3377 	swap	a
      000E98 23               [12] 3378 	rl	a
      000E99 54 E0            [12] 3379 	anl	a,#0xe0
      000E9B C5 82            [12] 3380 	xch	a,dpl
      000E9D C4               [12] 3381 	swap	a
      000E9E 23               [12] 3382 	rl	a
      000E9F C5 82            [12] 3383 	xch	a,dpl
      000EA1 65 82            [12] 3384 	xrl	a,dpl
      000EA3 C5 82            [12] 3385 	xch	a,dpl
      000EA5 54 E0            [12] 3386 	anl	a,#0xe0
      000EA7 C5 82            [12] 3387 	xch	a,dpl
      000EA9 65 82            [12] 3388 	xrl	a,dpl
      000EAB F5 83            [12] 3389 	mov	dph,a
      000EAD 78r0F            [12] 3390 	mov	r0,#(___global_vbr + 0x0006)
      000EAF 86*00            [24] 3391 	mov	__divuint_PARM_2,@r0
      000EB1 08               [12] 3392 	inc	r0
      000EB2 86*01            [24] 3393 	mov	(__divuint_PARM_2 + 1),@r0
      000EB4 12r00r00         [24] 3394 	lcall	__divuint
      000EB7 AA 82            [24] 3395 	mov	r2,dpl
      000EB9 AB 83            [24] 3396 	mov	r3,dph
      000EBB E4               [12] 3397 	clr	a
      000EBC FE               [12] 3398 	mov	r6,a
      000EBD FF               [12] 3399 	mov	r7,a
      000EBE EA               [12] 3400 	mov	a,r2
      000EBF 25*17            [12] 3401 	add	a,_VBR_MOUNT_VBR_sloc0_1_0
      000EC1 FA               [12] 3402 	mov	r2,a
      000EC2 EB               [12] 3403 	mov	a,r3
      000EC3 35*18            [12] 3404 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000EC5 FB               [12] 3405 	mov	r3,a
      000EC6 EE               [12] 3406 	mov	a,r6
      000EC7 35*19            [12] 3407 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000EC9 FE               [12] 3408 	mov	r6,a
      000ECA EF               [12] 3409 	mov	a,r7
      000ECB 35*1A            [12] 3410 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
      000ECD FF               [12] 3411 	mov	r7,a
      000ECE 78r24            [12] 3412 	mov	r0,#(___global_vbr + 0x001b)
      000ED0 A6 02            [24] 3413 	mov	@r0,ar2
      000ED2 08               [12] 3414 	inc	r0
      000ED3 A6 03            [24] 3415 	mov	@r0,ar3
      000ED5 08               [12] 3416 	inc	r0
      000ED6 A6 06            [24] 3417 	mov	@r0,ar6
      000ED8 08               [12] 3418 	inc	r0
      000ED9 A6 07            [24] 3419 	mov	@r0,ar7
                                   3420 ;	fat.h:416: return 0;
      000EDB 75 82 00         [24] 3421 	mov	dpl,#0x00
                                   3422 ;	fat.h:418: }
      000EDE 22               [24] 3423 	ret
                                   3424 ;------------------------------------------------------------
                                   3425 ;Allocation info for local variables in function 'VBR_FAT16_CHECK_COMPATIBILITY'
                                   3426 ;------------------------------------------------------------
                                   3427 ;partition_number          Allocated to registers r7 
                                   3428 ;------------------------------------------------------------
                                   3429 ;	fat.h:420: uint8_t VBR_FAT16_CHECK_COMPATIBILITY(uint8_t partition_number)
                                   3430 ;	-----------------------------------------
                                   3431 ;	 function VBR_FAT16_CHECK_COMPATIBILITY
                                   3432 ;	-----------------------------------------
      000EDF                       3433 _VBR_FAT16_CHECK_COMPATIBILITY:
                                   3434 ;	fat.h:426: if(VBR_MOUNT_VBR(partition_number))
      000EDF 12r0CrC3         [24] 3435 	lcall	_VBR_MOUNT_VBR
      000EE2 E5 82            [12] 3436 	mov	a,dpl
      000EE4 60 04            [24] 3437 	jz	00102$
                                   3438 ;	fat.h:428: return 1; //error
      000EE6 75 82 01         [24] 3439 	mov	dpl,#0x01
      000EE9 22               [24] 3440 	ret
      000EEA                       3441 00102$:
                                   3442 ;	fat.h:431: if(__global_vbr.bps!=SD_BLOCK_SIZE) 
      000EEA 78r0F            [12] 3443 	mov	r0,#(___global_vbr + 0x0006)
      000EEC 86 06            [24] 3444 	mov	ar6,@r0
      000EEE 08               [12] 3445 	inc	r0
      000EEF 86 07            [24] 3446 	mov	ar7,@r0
      000EF1 BE 00 05         [24] 3447 	cjne	r6,#0x00,00116$
      000EF4 BF 02 02         [24] 3448 	cjne	r7,#0x02,00116$
      000EF7 80 04            [24] 3449 	sjmp	00104$
      000EF9                       3450 00116$:
                                   3451 ;	fat.h:436: return 2; //error - not supported fat16
      000EF9 75 82 02         [24] 3452 	mov	dpl,#0x02
      000EFC 22               [24] 3453 	ret
      000EFD                       3454 00104$:
                                   3455 ;	fat.h:439: return 0;
      000EFD 75 82 00         [24] 3456 	mov	dpl,#0x00
                                   3457 ;	fat.h:440: }
      000F00 22               [24] 3458 	ret
                                   3459 ;------------------------------------------------------------
                                   3460 ;Allocation info for local variables in function 'FAT16_ROOTENTRY_DUMP'
                                   3461 ;------------------------------------------------------------
                                   3462 ;i                         Allocated to registers r7 
                                   3463 ;i                         Allocated to registers r7 
                                   3464 ;------------------------------------------------------------
                                   3465 ;	fat.h:443: void FAT16_ROOTENTRY_DUMP()
                                   3466 ;	-----------------------------------------
                                   3467 ;	 function FAT16_ROOTENTRY_DUMP
                                   3468 ;	-----------------------------------------
      000F01                       3469 _FAT16_ROOTENTRY_DUMP:
                                   3470 ;	fat.h:445: UartPrint("\nROOT_ENTRY_INDEX:");
      000F01 90r00r0F         [24] 3471 	mov	dptr,#___str_1
      000F04 75 F0 80         [24] 3472 	mov	b,#0x80
      000F07 12r01r1B         [24] 3473 	lcall	_UartPrint
                                   3474 ;	fat.h:446: UartPrintNumber(__global_rootEntry.entry_index);
      000F0A 78r3B            [12] 3475 	mov	r0,#(___global_rootEntry + 0x0012)
      000F0C 86 06            [24] 3476 	mov	ar6,@r0
      000F0E 08               [12] 3477 	inc	r0
      000F0F 86 07            [24] 3478 	mov	ar7,@r0
      000F11 7D 00            [12] 3479 	mov	r5,#0x00
      000F13 7C 00            [12] 3480 	mov	r4,#0x00
      000F15 8E 82            [24] 3481 	mov	dpl,r6
      000F17 8F 83            [24] 3482 	mov	dph,r7
      000F19 8D F0            [24] 3483 	mov	b,r5
      000F1B EC               [12] 3484 	mov	a,r4
      000F1C 12r02r61         [24] 3485 	lcall	_UartPrintNumber
                                   3486 ;	fat.h:447: UartPrint("\nFILE: ");
      000F1F 90r00r22         [24] 3487 	mov	dptr,#___str_2
      000F22 75 F0 80         [24] 3488 	mov	b,#0x80
      000F25 12r01r1B         [24] 3489 	lcall	_UartPrint
                                   3490 ;	fat.h:448: for(uint8_t i=0;i<8;i++)UartWrite(__global_rootEntry.name[i]);
      000F28 7F 00            [12] 3491 	mov	r7,#0x00
      000F2A                       3492 00104$:
      000F2A BF 08 00         [24] 3493 	cjne	r7,#0x08,00129$
      000F2D                       3494 00129$:
      000F2D 50 10            [24] 3495 	jnc	00101$
      000F2F EF               [12] 3496 	mov	a,r7
      000F30 24r29            [12] 3497 	add	a,#___global_rootEntry
      000F32 F9               [12] 3498 	mov	r1,a
      000F33 87 82            [24] 3499 	mov	dpl,@r1
      000F35 C0 07            [24] 3500 	push	ar7
      000F37 12r00r95         [24] 3501 	lcall	_UartWrite
      000F3A D0 07            [24] 3502 	pop	ar7
      000F3C 0F               [12] 3503 	inc	r7
      000F3D 80 EB            [24] 3504 	sjmp	00104$
      000F3F                       3505 00101$:
                                   3506 ;	fat.h:449: for(uint8_t i=0;i<3;i++)UartWrite(__global_rootEntry.extension[i]);
      000F3F 7F 00            [12] 3507 	mov	r7,#0x00
      000F41                       3508 00107$:
      000F41 BF 03 00         [24] 3509 	cjne	r7,#0x03,00131$
      000F44                       3510 00131$:
      000F44 50 10            [24] 3511 	jnc	00102$
      000F46 EF               [12] 3512 	mov	a,r7
      000F47 24r31            [12] 3513 	add	a,#(___global_rootEntry + 0x0008)
      000F49 F9               [12] 3514 	mov	r1,a
      000F4A 87 82            [24] 3515 	mov	dpl,@r1
      000F4C C0 07            [24] 3516 	push	ar7
      000F4E 12r00r95         [24] 3517 	lcall	_UartWrite
      000F51 D0 07            [24] 3518 	pop	ar7
      000F53 0F               [12] 3519 	inc	r7
      000F54 80 EB            [24] 3520 	sjmp	00107$
      000F56                       3521 00102$:
                                   3522 ;	fat.h:450: UartPrint("\nSTART: ");
      000F56 90r00r2A         [24] 3523 	mov	dptr,#___str_3
      000F59 75 F0 80         [24] 3524 	mov	b,#0x80
      000F5C 12r01r1B         [24] 3525 	lcall	_UartPrint
                                   3526 ;	fat.h:451: UartPrintNumber(__global_rootEntry.startCluster);
      000F5F 78r35            [12] 3527 	mov	r0,#(___global_rootEntry + 0x000c)
      000F61 86 06            [24] 3528 	mov	ar6,@r0
      000F63 08               [12] 3529 	inc	r0
      000F64 86 07            [24] 3530 	mov	ar7,@r0
      000F66 7D 00            [12] 3531 	mov	r5,#0x00
      000F68 7C 00            [12] 3532 	mov	r4,#0x00
      000F6A 8E 82            [24] 3533 	mov	dpl,r6
      000F6C 8F 83            [24] 3534 	mov	dph,r7
      000F6E 8D F0            [24] 3535 	mov	b,r5
      000F70 EC               [12] 3536 	mov	a,r4
      000F71 12r02r61         [24] 3537 	lcall	_UartPrintNumber
                                   3538 ;	fat.h:452: UartPrint("\nSIZE: ");
      000F74 90r00r33         [24] 3539 	mov	dptr,#___str_4
      000F77 75 F0 80         [24] 3540 	mov	b,#0x80
      000F7A 12r01r1B         [24] 3541 	lcall	_UartPrint
                                   3542 ;	fat.h:453: UartPrintNumber(__global_rootEntry.size);			
      000F7D 78r37            [12] 3543 	mov	r0,#(___global_rootEntry + 0x000e)
      000F7F 86 04            [24] 3544 	mov	ar4,@r0
      000F81 08               [12] 3545 	inc	r0
      000F82 86 05            [24] 3546 	mov	ar5,@r0
      000F84 08               [12] 3547 	inc	r0
      000F85 86 06            [24] 3548 	mov	ar6,@r0
      000F87 08               [12] 3549 	inc	r0
      000F88 86 07            [24] 3550 	mov	ar7,@r0
      000F8A 8C 82            [24] 3551 	mov	dpl,r4
      000F8C 8D 83            [24] 3552 	mov	dph,r5
      000F8E 8E F0            [24] 3553 	mov	b,r6
      000F90 EF               [12] 3554 	mov	a,r7
      000F91 12r02r61         [24] 3555 	lcall	_UartPrintNumber
                                   3556 ;	fat.h:454: UartPrint("\nATTR: 0x");
      000F94 90r00r3B         [24] 3557 	mov	dptr,#___str_5
      000F97 75 F0 80         [24] 3558 	mov	b,#0x80
      000F9A 12r01r1B         [24] 3559 	lcall	_UartPrint
                                   3560 ;	fat.h:455: UartWriteNumber(__global_rootEntry.attributes,HEX);			
      000F9D 78r34            [12] 3561 	mov	r0,#(___global_rootEntry + 0x000b)
      000F9F 86 82            [24] 3562 	mov	dpl,@r0
      000FA1 E4               [12] 3563 	clr	a
      000FA2 C0 E0            [24] 3564 	push	acc
      000FA4 12r01r4D         [24] 3565 	lcall	_UartWriteNumber
      000FA7 15 81            [12] 3566 	dec	sp
                                   3567 ;	fat.h:456: UartWrite('\n\n');
      000FA9 75 82 0A         [24] 3568 	mov	dpl,#0x0a
                                   3569 ;	fat.h:457: }
      000FAC 02r00r95         [24] 3570 	ljmp	_UartWrite
                                   3571 ;------------------------------------------------------------
                                   3572 ;Allocation info for local variables in function 'FAT16_LOAD_ROOTENTRY'
                                   3573 ;------------------------------------------------------------
                                   3574 ;roote_number              Allocated with name '_FAT16_LOAD_ROOTENTRY_roote_number_65536_149'
                                   3575 ;i                         Allocated to registers r7 
                                   3576 ;i                         Allocated to registers r7 
                                   3577 ;sloc0                     Allocated with name '_FAT16_LOAD_ROOTENTRY_sloc0_1_0'
                                   3578 ;sloc1                     Allocated with name '_FAT16_LOAD_ROOTENTRY_sloc1_1_0'
                                   3579 ;temp                      Allocated with name '_FAT16_LOAD_ROOTENTRY_temp_65536_150'
                                   3580 ;sector_of_given_roote     Allocated to registers r2 r3 r4 r5 
                                   3581 ;offset_in_this_sector     Allocated to registers r6 r7 
                                   3582 ;------------------------------------------------------------
                                   3583 ;	fat.h:467: uint8_t FAT16_LOAD_ROOTENTRY(uint16_t roote_number)
                                   3584 ;	-----------------------------------------
                                   3585 ;	 function FAT16_LOAD_ROOTENTRY
                                   3586 ;	-----------------------------------------
      000FAF                       3587 _FAT16_LOAD_ROOTENTRY:
      000FAF 85 82*1B         [24] 3588 	mov	_FAT16_LOAD_ROOTENTRY_roote_number_65536_149,dpl
      000FB2 85 83*1C         [24] 3589 	mov	(_FAT16_LOAD_ROOTENTRY_roote_number_65536_149 + 1),dph
                                   3590 ;	fat.h:476: if(roote_number < __global_vbr.nroote);//pass
      000FB5 78r16            [12] 3591 	mov	r0,#(___global_vbr + 0x000d)
      000FB7 86 04            [24] 3592 	mov	ar4,@r0
      000FB9 08               [12] 3593 	inc	r0
      000FBA 86 05            [24] 3594 	mov	ar5,@r0
      000FBC C3               [12] 3595 	clr	c
      000FBD E5*1B            [12] 3596 	mov	a,_FAT16_LOAD_ROOTENTRY_roote_number_65536_149
      000FBF 9C               [12] 3597 	subb	a,r4
      000FC0 E5*1C            [12] 3598 	mov	a,(_FAT16_LOAD_ROOTENTRY_roote_number_65536_149 + 1)
      000FC2 9D               [12] 3599 	subb	a,r5
      000FC3 40 04            [24] 3600 	jc	00103$
                                   3601 ;	fat.h:477: else return 1; // error as roote_number is more than number of root entries present in rootentry table 
      000FC5 75 82 01         [24] 3602 	mov	dpl,#0x01
      000FC8 22               [24] 3603 	ret
      000FC9                       3604 00103$:
                                   3605 ;	fat.h:479: VBR_MOUNT_VBR(__global_nthPartitionVBRmounted);
      000FC9 78r28            [12] 3606 	mov	r0,#___global_nthPartitionVBRmounted
      000FCB 86 82            [24] 3607 	mov	dpl,@r0
      000FCD 12r0CrC3         [24] 3608 	lcall	_VBR_MOUNT_VBR
                                   3609 ;	fat.h:482: sector_of_given_roote = __global_vbr.addr_roote_start + (roote_number*32)/__global_vbr.bps;
      000FD0 78r20            [12] 3610 	mov	r0,#(___global_vbr + 0x0017)
      000FD2 86*1D            [24] 3611 	mov	_FAT16_LOAD_ROOTENTRY_sloc0_1_0,@r0
      000FD4 08               [12] 3612 	inc	r0
      000FD5 86*1E            [24] 3613 	mov	(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 1),@r0
      000FD7 08               [12] 3614 	inc	r0
      000FD8 86*1F            [24] 3615 	mov	(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 2),@r0
      000FDA 08               [12] 3616 	inc	r0
      000FDB 86*20            [24] 3617 	mov	(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 3),@r0
      000FDD AE*1B            [24] 3618 	mov	r6,_FAT16_LOAD_ROOTENTRY_roote_number_65536_149
      000FDF E5*1C            [12] 3619 	mov	a,(_FAT16_LOAD_ROOTENTRY_roote_number_65536_149 + 1)
      000FE1 C4               [12] 3620 	swap	a
      000FE2 23               [12] 3621 	rl	a
      000FE3 54 E0            [12] 3622 	anl	a,#0xe0
      000FE5 CE               [12] 3623 	xch	a,r6
      000FE6 C4               [12] 3624 	swap	a
      000FE7 23               [12] 3625 	rl	a
      000FE8 CE               [12] 3626 	xch	a,r6
      000FE9 6E               [12] 3627 	xrl	a,r6
      000FEA CE               [12] 3628 	xch	a,r6
      000FEB 54 E0            [12] 3629 	anl	a,#0xe0
      000FED CE               [12] 3630 	xch	a,r6
      000FEE 6E               [12] 3631 	xrl	a,r6
      000FEF FF               [12] 3632 	mov	r7,a
      000FF0 78r0F            [12] 3633 	mov	r0,#(___global_vbr + 0x0006)
      000FF2 86*21            [24] 3634 	mov	_FAT16_LOAD_ROOTENTRY_sloc1_1_0,@r0
      000FF4 08               [12] 3635 	inc	r0
      000FF5 86*22            [24] 3636 	mov	(_FAT16_LOAD_ROOTENTRY_sloc1_1_0 + 1),@r0
      000FF7 85*21*00         [24] 3637 	mov	__divuint_PARM_2,_FAT16_LOAD_ROOTENTRY_sloc1_1_0
      000FFA 85*22*01         [24] 3638 	mov	(__divuint_PARM_2 + 1),(_FAT16_LOAD_ROOTENTRY_sloc1_1_0 + 1)
      000FFD 8E 82            [24] 3639 	mov	dpl,r6
      000FFF 8F 83            [24] 3640 	mov	dph,r7
      001001 C0 07            [24] 3641 	push	ar7
      001003 C0 06            [24] 3642 	push	ar6
      001005 12r00r00         [24] 3643 	lcall	__divuint
      001008 AA 82            [24] 3644 	mov	r2,dpl
      00100A AB 83            [24] 3645 	mov	r3,dph
      00100C D0 06            [24] 3646 	pop	ar6
      00100E D0 07            [24] 3647 	pop	ar7
      001010 E4               [12] 3648 	clr	a
      001011 FC               [12] 3649 	mov	r4,a
      001012 FD               [12] 3650 	mov	r5,a
      001013 EA               [12] 3651 	mov	a,r2
      001014 25*1D            [12] 3652 	add	a,_FAT16_LOAD_ROOTENTRY_sloc0_1_0
      001016 FA               [12] 3653 	mov	r2,a
      001017 EB               [12] 3654 	mov	a,r3
      001018 35*1E            [12] 3655 	addc	a,(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 1)
      00101A FB               [12] 3656 	mov	r3,a
      00101B EC               [12] 3657 	mov	a,r4
      00101C 35*1F            [12] 3658 	addc	a,(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 2)
      00101E FC               [12] 3659 	mov	r4,a
      00101F ED               [12] 3660 	mov	a,r5
      001020 35*20            [12] 3661 	addc	a,(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 3)
      001022 FD               [12] 3662 	mov	r5,a
                                   3663 ;	fat.h:483: offset_in_this_sector = (roote_number*32)%__global_vbr.bps;
      001023 85*21*00         [24] 3664 	mov	__moduint_PARM_2,_FAT16_LOAD_ROOTENTRY_sloc1_1_0
      001026 85*22*01         [24] 3665 	mov	(__moduint_PARM_2 + 1),(_FAT16_LOAD_ROOTENTRY_sloc1_1_0 + 1)
      001029 8E 82            [24] 3666 	mov	dpl,r6
      00102B 8F 83            [24] 3667 	mov	dph,r7
      00102D C0 05            [24] 3668 	push	ar5
      00102F C0 04            [24] 3669 	push	ar4
      001031 C0 03            [24] 3670 	push	ar3
      001033 C0 02            [24] 3671 	push	ar2
      001035 12r00r00         [24] 3672 	lcall	__moduint
      001038 AE 82            [24] 3673 	mov	r6,dpl
      00103A AF 83            [24] 3674 	mov	r7,dph
      00103C D0 02            [24] 3675 	pop	ar2
      00103E D0 03            [24] 3676 	pop	ar3
      001040 D0 04            [24] 3677 	pop	ar4
      001042 D0 05            [24] 3678 	pop	ar5
                                   3679 ;	fat.h:485: SDread(sector_of_given_roote,offset_in_this_sector,32,temp);
      001044 74r61            [12] 3680 	mov	a,#_FAT16_LOAD_ROOTENTRY_temp_65536_150
      001046 C0 E0            [24] 3681 	push	acc
      001048 74s00            [12] 3682 	mov	a,#(_FAT16_LOAD_ROOTENTRY_temp_65536_150 >> 8)
      00104A C0 E0            [24] 3683 	push	acc
      00104C 74 40            [12] 3684 	mov	a,#0x40
      00104E C0 E0            [24] 3685 	push	acc
      001050 03               [12] 3686 	rr	a
      001051 C0 E0            [24] 3687 	push	acc
      001053 E4               [12] 3688 	clr	a
      001054 C0 E0            [24] 3689 	push	acc
      001056 C0 06            [24] 3690 	push	ar6
      001058 C0 07            [24] 3691 	push	ar7
      00105A 8A 82            [24] 3692 	mov	dpl,r2
      00105C 8B 83            [24] 3693 	mov	dph,r3
      00105E 8C F0            [24] 3694 	mov	b,r4
      001060 ED               [12] 3695 	mov	a,r5
      001061 12r06rDE         [24] 3696 	lcall	_SDread
      001064 E5 81            [12] 3697 	mov	a,sp
      001066 24 F9            [12] 3698 	add	a,#0xf9
      001068 F5 81            [12] 3699 	mov	sp,a
                                   3700 ;	fat.h:487: __global_rootEntry.entry_index = roote_number; //save the index of the root_entry
      00106A 78r3B            [12] 3701 	mov	r0,#(___global_rootEntry + 0x0012)
      00106C A6*1B            [24] 3702 	mov	@r0,_FAT16_LOAD_ROOTENTRY_roote_number_65536_149
      00106E 08               [12] 3703 	inc	r0
      00106F A6*1C            [24] 3704 	mov	@r0,(_FAT16_LOAD_ROOTENTRY_roote_number_65536_149 + 1)
                                   3705 ;	fat.h:488: __global_rootEntry.bytes_read = 0; //no bytes has been read so far by FAT16_FILE_READ as we have just loaded the rootentry
      001071 78r3D            [12] 3706 	mov	r0,#(___global_rootEntry + 0x0014)
      001073 76 00            [12] 3707 	mov	@r0,#0x00
      001075 08               [12] 3708 	inc	r0
      001076 76 00            [12] 3709 	mov	@r0,#0x00
      001078 08               [12] 3710 	inc	r0
      001079 76 00            [12] 3711 	mov	@r0,#0x00
      00107B 08               [12] 3712 	inc	r0
      00107C 76 00            [12] 3713 	mov	@r0,#0x00
                                   3714 ;	fat.h:490: for(uint8_t i=0;i<8;i++) __global_rootEntry.name[i] = temp[i];
      00107E 7F 00            [12] 3715 	mov	r7,#0x00
      001080                       3716 00107$:
      001080 BF 08 00         [24] 3717 	cjne	r7,#0x08,00137$
      001083                       3718 00137$:
      001083 50 0F            [24] 3719 	jnc	00104$
      001085 EF               [12] 3720 	mov	a,r7
      001086 24r29            [12] 3721 	add	a,#___global_rootEntry
      001088 F9               [12] 3722 	mov	r1,a
      001089 EF               [12] 3723 	mov	a,r7
      00108A 24r61            [12] 3724 	add	a,#_FAT16_LOAD_ROOTENTRY_temp_65536_150
      00108C F8               [12] 3725 	mov	r0,a
      00108D 86 06            [24] 3726 	mov	ar6,@r0
      00108F A7 06            [24] 3727 	mov	@r1,ar6
      001091 0F               [12] 3728 	inc	r7
      001092 80 EC            [24] 3729 	sjmp	00107$
      001094                       3730 00104$:
                                   3731 ;	fat.h:491: for(uint8_t i=8;i<11;i++) __global_rootEntry.extension[i-8] = temp[i];
      001094 7F 08            [12] 3732 	mov	r7,#0x08
      001096                       3733 00110$:
      001096 BF 0B 00         [24] 3734 	cjne	r7,#0x0b,00139$
      001099                       3735 00139$:
      001099 50 13            [24] 3736 	jnc	00105$
      00109B 8F 06            [24] 3737 	mov	ar6,r7
      00109D EE               [12] 3738 	mov	a,r6
      00109E 24 F8            [12] 3739 	add	a,#0xf8
      0010A0 24r31            [12] 3740 	add	a,#(___global_rootEntry + 0x0008)
      0010A2 F9               [12] 3741 	mov	r1,a
      0010A3 EF               [12] 3742 	mov	a,r7
      0010A4 24r61            [12] 3743 	add	a,#_FAT16_LOAD_ROOTENTRY_temp_65536_150
      0010A6 F8               [12] 3744 	mov	r0,a
      0010A7 86 06            [24] 3745 	mov	ar6,@r0
      0010A9 A7 06            [24] 3746 	mov	@r1,ar6
      0010AB 0F               [12] 3747 	inc	r7
      0010AC 80 E8            [24] 3748 	sjmp	00110$
      0010AE                       3749 00105$:
                                   3750 ;	fat.h:493: __global_rootEntry.attributes = temp[0x0b];
      0010AE 78r6C            [12] 3751 	mov	r0,#(_FAT16_LOAD_ROOTENTRY_temp_65536_150 + 0x000b)
      0010B0 86 07            [24] 3752 	mov	ar7,@r0
      0010B2 78r34            [12] 3753 	mov	r0,#(___global_rootEntry + 0x000b)
      0010B4 A6 07            [24] 3754 	mov	@r0,ar7
                                   3755 ;	fat.h:494: __global_rootEntry.startCluster = HELPER_load_littleendian16(&temp[0x1a]);
      0010B6 90r00r7B         [24] 3756 	mov	dptr,#(_FAT16_LOAD_ROOTENTRY_temp_65536_150 + 0x001a)
      0010B9 75 F0 40         [24] 3757 	mov	b,#0x40
      0010BC 12r08r24         [24] 3758 	lcall	_HELPER_load_littleendian16
      0010BF E5 82            [12] 3759 	mov	a,dpl
      0010C1 85 83 F0         [24] 3760 	mov	b,dph
      0010C4 78r35            [12] 3761 	mov	r0,#(___global_rootEntry + 0x000c)
      0010C6 F6               [12] 3762 	mov	@r0,a
      0010C7 08               [12] 3763 	inc	r0
      0010C8 A6 F0            [24] 3764 	mov	@r0,b
                                   3765 ;	fat.h:495: __global_rootEntry.size = HELPER_load_littleendian32(&temp[0x1c]);
      0010CA 90r00r7D         [24] 3766 	mov	dptr,#(_FAT16_LOAD_ROOTENTRY_temp_65536_150 + 0x001c)
      0010CD 75 F0 40         [24] 3767 	mov	b,#0x40
      0010D0 12r08r52         [24] 3768 	lcall	_HELPER_load_littleendian32
      0010D3 AC 82            [24] 3769 	mov	r4,dpl
      0010D5 AD 83            [24] 3770 	mov	r5,dph
      0010D7 AE F0            [24] 3771 	mov	r6,b
      0010D9 FF               [12] 3772 	mov	r7,a
      0010DA 78r37            [12] 3773 	mov	r0,#(___global_rootEntry + 0x000e)
      0010DC A6 04            [24] 3774 	mov	@r0,ar4
      0010DE 08               [12] 3775 	inc	r0
      0010DF A6 05            [24] 3776 	mov	@r0,ar5
      0010E1 08               [12] 3777 	inc	r0
      0010E2 A6 06            [24] 3778 	mov	@r0,ar6
      0010E4 08               [12] 3779 	inc	r0
      0010E5 A6 07            [24] 3780 	mov	@r0,ar7
                                   3781 ;	fat.h:497: return 0;
      0010E7 75 82 00         [24] 3782 	mov	dpl,#0x00
                                   3783 ;	fat.h:498: }
      0010EA 22               [24] 3784 	ret
                                   3785 ;------------------------------------------------------------
                                   3786 ;Allocation info for local variables in function 'FAT16_IS_ROOTENTRY_VALID_FILE'
                                   3787 ;------------------------------------------------------------
                                   3788 ;	fat.h:499: uint8_t FAT16_IS_ROOTENTRY_VALID_FILE()
                                   3789 ;	-----------------------------------------
                                   3790 ;	 function FAT16_IS_ROOTENTRY_VALID_FILE
                                   3791 ;	-----------------------------------------
      0010EB                       3792 _FAT16_IS_ROOTENTRY_VALID_FILE:
                                   3793 ;	fat.h:502: if(__global_rootEntry.name[0]==FAT16_ROOTENTRY_AVAILABLE)
      0010EB 78r29            [12] 3794 	mov	r0,#___global_rootEntry
      0010ED E6               [12] 3795 	mov	a,@r0
      0010EE FF               [12] 3796 	mov	r7,a
      0010EF 70 04            [24] 3797 	jnz	00112$
                                   3798 ;	fat.h:507: return 255; //no more entries, stop scanning
      0010F1 75 82 FF         [24] 3799 	mov	dpl,#0xff
      0010F4 22               [24] 3800 	ret
      0010F5                       3801 00112$:
                                   3802 ;	fat.h:509: else if(__global_rootEntry.name[0]==FAT16_ROOTENTRY_DELETED)
      0010F5 BF E5 04         [24] 3803 	cjne	r7,#0xe5,00109$
                                   3804 ;	fat.h:515: return FAT16_ROOTENTRY_DELETED; //deleted and available
      0010F8 75 82 E5         [24] 3805 	mov	dpl,#0xe5
      0010FB 22               [24] 3806 	ret
      0010FC                       3807 00109$:
                                   3808 ;	fat.h:517: else if(__global_rootEntry.name[0]==FAT16_ROOTENTRY_DOT)
      0010FC BF 2E 04         [24] 3809 	cjne	r7,#0x2e,00106$
                                   3810 ;	fat.h:522: return FAT16_ROOTENTRY_DOT; //this is the entry to self
      0010FF 75 82 2E         [24] 3811 	mov	dpl,#0x2e
      001102 22               [24] 3812 	ret
      001103                       3813 00106$:
                                   3814 ;	fat.h:527: HELPER_rootentry_type(&__global_rootEntry)==FILETYPE_HIDDEN ||
      001103 90r00r29         [24] 3815 	mov	dptr,#___global_rootEntry
      001106 75 F0 40         [24] 3816 	mov	b,#0x40
      001109 12r09rAD         [24] 3817 	lcall	_HELPER_rootentry_type
      00110C AF 82            [24] 3818 	mov	r7,dpl
      00110E BF 01 02         [24] 3819 	cjne	r7,#0x01,00141$
      001111 80 1E            [24] 3820 	sjmp	00101$
      001113                       3821 00141$:
                                   3822 ;	fat.h:528: HELPER_rootentry_type(&__global_rootEntry)==FILETYPE_SYSTEM ||
      001113 90r00r29         [24] 3823 	mov	dptr,#___global_rootEntry
      001116 75 F0 40         [24] 3824 	mov	b,#0x40
      001119 12r09rAD         [24] 3825 	lcall	_HELPER_rootentry_type
      00111C AF 82            [24] 3826 	mov	r7,dpl
      00111E BF 02 02         [24] 3827 	cjne	r7,#0x02,00142$
      001121 80 0E            [24] 3828 	sjmp	00101$
      001123                       3829 00142$:
                                   3830 ;	fat.h:529: HELPER_rootentry_type(&__global_rootEntry)==FILETYPE_VOLUME
      001123 90r00r29         [24] 3831 	mov	dptr,#___global_rootEntry
      001126 75 F0 40         [24] 3832 	mov	b,#0x40
      001129 12r09rAD         [24] 3833 	lcall	_HELPER_rootentry_type
      00112C AF 82            [24] 3834 	mov	r7,dpl
      00112E BF 03 04         [24] 3835 	cjne	r7,#0x03,00110$
      001131                       3836 00101$:
                                   3837 ;	fat.h:536: return 254;
      001131 75 82 FE         [24] 3838 	mov	dpl,#0xfe
      001134 22               [24] 3839 	ret
      001135                       3840 00110$:
                                   3841 ;	fat.h:539: return 0;
      001135 75 82 00         [24] 3842 	mov	dpl,#0x00
                                   3843 ;	fat.h:540: }
      001138 22               [24] 3844 	ret
                                   3845 ;------------------------------------------------------------
                                   3846 ;Allocation info for local variables in function 'FAT16_ROOTENTRY_READ'
                                   3847 ;------------------------------------------------------------
                                   3848 ;roote_index               Allocated to registers r6 r7 
                                   3849 ;file_validity             Allocated to registers r7 
                                   3850 ;------------------------------------------------------------
                                   3851 ;	fat.h:543: uint8_t FAT16_ROOTENTRY_READ(uint16_t roote_index)
                                   3852 ;	-----------------------------------------
                                   3853 ;	 function FAT16_ROOTENTRY_READ
                                   3854 ;	-----------------------------------------
      001139                       3855 _FAT16_ROOTENTRY_READ:
                                   3856 ;	fat.h:553: if(FAT16_LOAD_ROOTENTRY(roote_index)) // if returns 1, then we have reached the end of the rootentry table
      001139 12r0FrAF         [24] 3857 	lcall	_FAT16_LOAD_ROOTENTRY
      00113C E5 82            [12] 3858 	mov	a,dpl
      00113E 60 04            [24] 3859 	jz	00102$
                                   3860 ;	fat.h:555: return 0xff; //end of scan
      001140 75 82 FF         [24] 3861 	mov	dpl,#0xff
      001143 22               [24] 3862 	ret
      001144                       3863 00102$:
                                   3864 ;	fat.h:559: file_validity=FAT16_IS_ROOTENTRY_VALID_FILE(); //check validity
      001144 12r10rEB         [24] 3865 	lcall	_FAT16_IS_ROOTENTRY_VALID_FILE
      001147 AF 82            [24] 3866 	mov	r7,dpl
                                   3867 ;	fat.h:561: if(file_validity==255)return 0xff; //end of scan
      001149 BF FF 04         [24] 3868 	cjne	r7,#0xff,00106$
      00114C 75 82 FF         [24] 3869 	mov	dpl,#0xff
      00114F 22               [24] 3870 	ret
      001150                       3871 00106$:
                                   3872 ;	fat.h:562: else if(file_validity==0)
      001150 EF               [12] 3873 	mov	a,r7
                                   3874 ;	fat.h:568: return 0;
      001151 70 03            [24] 3875 	jnz	00107$
      001153 F5 82            [12] 3876 	mov	dpl,a
      001155 22               [24] 3877 	ret
      001156                       3878 00107$:
                                   3879 ;	fat.h:571: return 1; //invalid file if context reaches here
      001156 75 82 01         [24] 3880 	mov	dpl,#0x01
                                   3881 ;	fat.h:574: }
      001159 22               [24] 3882 	ret
                                   3883 ;------------------------------------------------------------
                                   3884 ;Allocation info for local variables in function 'FAT16_ROOTENTRY_SCAN_RESET'
                                   3885 ;------------------------------------------------------------
                                   3886 ;	fat.h:576: void FAT16_ROOTENTRY_SCAN_RESET()
                                   3887 ;	-----------------------------------------
                                   3888 ;	 function FAT16_ROOTENTRY_SCAN_RESET
                                   3889 ;	-----------------------------------------
      00115A                       3890 _FAT16_ROOTENTRY_SCAN_RESET:
                                   3891 ;	fat.h:578: __global_rootEntry.entry_index=0xffff; // in FAT16, maximum number of root entries can never reach 0xffff.
      00115A 78r3B            [12] 3892 	mov	r0,#(___global_rootEntry + 0x0012)
      00115C 76 FF            [12] 3893 	mov	@r0,#0xff
      00115E 08               [12] 3894 	inc	r0
      00115F 76 FF            [12] 3895 	mov	@r0,#0xff
                                   3896 ;	fat.h:584: __global_rootEntry.attributes |= 1<<FILETYPE_SYSTEM;
      001161 78r34            [12] 3897 	mov	r0,#(___global_rootEntry + 0x000b)
      001163 86 07            [24] 3898 	mov	ar7,@r0
      001165 74 04            [12] 3899 	mov	a,#0x04
      001167 4F               [12] 3900 	orl	a,r7
      001168 78r34            [12] 3901 	mov	r0,#(___global_rootEntry + 0x000b)
      00116A F6               [12] 3902 	mov	@r0,a
                                   3903 ;	fat.h:585: }
      00116B 22               [24] 3904 	ret
                                   3905 ;------------------------------------------------------------
                                   3906 ;Allocation info for local variables in function 'FAT16_ROOTENTRY_SCAN'
                                   3907 ;------------------------------------------------------------
                                   3908 ;validity                  Allocated to registers r7 
                                   3909 ;------------------------------------------------------------
                                   3910 ;	fat.h:587: uint8_t FAT16_ROOTENTRY_SCAN() __reentrant
                                   3911 ;	-----------------------------------------
                                   3912 ;	 function FAT16_ROOTENTRY_SCAN
                                   3913 ;	-----------------------------------------
      00116C                       3914 _FAT16_ROOTENTRY_SCAN:
                                   3915 ;	fat.h:592: while(1)
      00116C                       3916 00110$:
                                   3917 ;	fat.h:600: validity=FAT16_ROOTENTRY_READ(__global_rootEntry.entry_index+1); //read the next entry
      00116C 78r3B            [12] 3918 	mov	r0,#(___global_rootEntry + 0x0012)
      00116E 86 06            [24] 3919 	mov	ar6,@r0
      001170 08               [12] 3920 	inc	r0
      001171 86 07            [24] 3921 	mov	ar7,@r0
      001173 8E 82            [24] 3922 	mov	dpl,r6
      001175 8F 83            [24] 3923 	mov	dph,r7
      001177 A3               [24] 3924 	inc	dptr
      001178 12r11r39         [24] 3925 	lcall	_FAT16_ROOTENTRY_READ
      00117B AF 82            [24] 3926 	mov	r7,dpl
                                   3927 ;	fat.h:602: if ( validity == 255 )
      00117D BF FF 04         [24] 3928 	cjne	r7,#0xff,00107$
                                   3929 ;	fat.h:608: return 255; //end scan
      001180 75 82 FF         [24] 3930 	mov	dpl,#0xff
      001183 22               [24] 3931 	ret
      001184                       3932 00107$:
                                   3933 ;	fat.h:610: else if (validity == 1) 
      001184 BF 01 02         [24] 3934 	cjne	r7,#0x01,00132$
      001187 80 E3            [24] 3935 	sjmp	00110$
      001189                       3936 00132$:
                                   3937 ;	fat.h:618: else if(validity == 0)
      001189 EF               [12] 3938 	mov	a,r7
                                   3939 ;	fat.h:625: return 0; // found a valid file,break out of the loop
      00118A 70 E0            [24] 3940 	jnz	00110$
      00118C F5 82            [12] 3941 	mov	dpl,a
                                   3942 ;	fat.h:632: }
      00118E 22               [24] 3943 	ret
                                   3944 ;------------------------------------------------------------
                                   3945 ;Allocation info for local variables in function 'FAT16_FILE_OPEN'
                                   3946 ;------------------------------------------------------------
                                   3947 ;filename                  Allocated to registers r5 r6 r7 
                                   3948 ;filename83                Allocated to stack - _bp +1
                                   3949 ;------------------------------------------------------------
                                   3950 ;	fat.h:634: uint8_t FAT16_FILE_OPEN(char *filename) __reentrant
                                   3951 ;	-----------------------------------------
                                   3952 ;	 function FAT16_FILE_OPEN
                                   3953 ;	-----------------------------------------
      00118F                       3954 _FAT16_FILE_OPEN:
      00118F C0*00            [24] 3955 	push	_bp
      001191 E5 81            [12] 3956 	mov	a,sp
      001193 F5*00            [12] 3957 	mov	_bp,a
      001195 24 0C            [12] 3958 	add	a,#0x0c
      001197 F5 81            [12] 3959 	mov	sp,a
      001199 AD 82            [24] 3960 	mov	r5,dpl
      00119B AE 83            [24] 3961 	mov	r6,dph
      00119D AF F0            [24] 3962 	mov	r7,b
                                   3963 ;	fat.h:640: if(HELPER_filename_to_8dot3filename(filename,filename83)) 
      00119F AC*00            [24] 3964 	mov	r4,_bp
      0011A1 0C               [12] 3965 	inc	r4
      0011A2 8C*10            [24] 3966 	mov	_HELPER_filename_to_8dot3filename_PARM_2,r4
      0011A4 75*11 00         [24] 3967 	mov	(_HELPER_filename_to_8dot3filename_PARM_2 + 1),#0x00
      0011A7 75*12 40         [24] 3968 	mov	(_HELPER_filename_to_8dot3filename_PARM_2 + 2),#0x40
      0011AA 8D 82            [24] 3969 	mov	dpl,r5
      0011AC 8E 83            [24] 3970 	mov	dph,r6
      0011AE 8F F0            [24] 3971 	mov	b,r7
      0011B0 C0 04            [24] 3972 	push	ar4
      0011B2 12r0Ar66         [24] 3973 	lcall	_HELPER_filename_to_8dot3filename
      0011B5 E5 82            [12] 3974 	mov	a,dpl
      0011B7 D0 04            [24] 3975 	pop	ar4
      0011B9 60 05            [24] 3976 	jz	00102$
                                   3977 ;	fat.h:645: return 1; //invalid filename
      0011BB 75 82 01         [24] 3978 	mov	dpl,#0x01
      0011BE 80 61            [24] 3979 	sjmp	00109$
      0011C0                       3980 00102$:
                                   3981 ;	fat.h:648: FAT16_ROOTENTRY_SCAN_RESET();
      0011C0 C0 04            [24] 3982 	push	ar4
      0011C2 12r11r5A         [24] 3983 	lcall	_FAT16_ROOTENTRY_SCAN_RESET
      0011C5 D0 04            [24] 3984 	pop	ar4
                                   3985 ;	fat.h:649: while(FAT16_ROOTENTRY_SCAN()==0)
      0011C7 8C 07            [24] 3986 	mov	ar7,r4
      0011C9 74 08            [12] 3987 	mov	a,#0x08
      0011CB 2C               [12] 3988 	add	a,r4
      0011CC FE               [12] 3989 	mov	r6,a
      0011CD                       3990 00106$:
      0011CD C0 07            [24] 3991 	push	ar7
      0011CF C0 06            [24] 3992 	push	ar6
      0011D1 12r11r6C         [24] 3993 	lcall	_FAT16_ROOTENTRY_SCAN
      0011D4 E5 82            [12] 3994 	mov	a,dpl
      0011D6 D0 06            [24] 3995 	pop	ar6
      0011D8 D0 07            [24] 3996 	pop	ar7
                                   3997 ;	fat.h:651: if( HELPER_strncmp(__global_rootEntry.name,filename83,8)==0 && 
      0011DA 70 42            [24] 3998 	jnz	00108$
      0011DC 8F*00            [24] 3999 	mov	_HELPER_strncmp_PARM_2,r7
      0011DE F5*01            [12] 4000 	mov	(_HELPER_strncmp_PARM_2 + 1),a
      0011E0 75*02 40         [24] 4001 	mov	(_HELPER_strncmp_PARM_2 + 2),#0x40
      0011E3 75*03 08         [24] 4002 	mov	_HELPER_strncmp_PARM_3,#0x08
      0011E6 90r00r29         [24] 4003 	mov	dptr,#___global_rootEntry
      0011E9 75 F0 40         [24] 4004 	mov	b,#0x40
      0011EC C0 07            [24] 4005 	push	ar7
      0011EE C0 06            [24] 4006 	push	ar6
      0011F0 12r09r36         [24] 4007 	lcall	_HELPER_strncmp
      0011F3 E5 82            [12] 4008 	mov	a,dpl
      0011F5 D0 06            [24] 4009 	pop	ar6
      0011F7 D0 07            [24] 4010 	pop	ar7
                                   4011 ;	fat.h:652: HELPER_strncmp(__global_rootEntry.extension,&filename83[8],3)==0 )
      0011F9 70 D2            [24] 4012 	jnz	00106$
      0011FB 8E*00            [24] 4013 	mov	_HELPER_strncmp_PARM_2,r6
      0011FD F5*01            [12] 4014 	mov	(_HELPER_strncmp_PARM_2 + 1),a
      0011FF 75*02 40         [24] 4015 	mov	(_HELPER_strncmp_PARM_2 + 2),#0x40
      001202 75*03 03         [24] 4016 	mov	_HELPER_strncmp_PARM_3,#0x03
      001205 90r00r31         [24] 4017 	mov	dptr,#(___global_rootEntry + 0x0008)
      001208 75 F0 40         [24] 4018 	mov	b,#0x40
      00120B C0 07            [24] 4019 	push	ar7
      00120D C0 06            [24] 4020 	push	ar6
      00120F 12r09r36         [24] 4021 	lcall	_HELPER_strncmp
      001212 E5 82            [12] 4022 	mov	a,dpl
      001214 D0 06            [24] 4023 	pop	ar6
      001216 D0 07            [24] 4024 	pop	ar7
                                   4025 ;	fat.h:658: return 0; //file found
      001218 70 B3            [24] 4026 	jnz	00106$
      00121A F5 82            [12] 4027 	mov	dpl,a
      00121C 80 03            [24] 4028 	sjmp	00109$
      00121E                       4029 00108$:
                                   4030 ;	fat.h:665: return 2; // file not found
      00121E 75 82 02         [24] 4031 	mov	dpl,#0x02
      001221                       4032 00109$:
                                   4033 ;	fat.h:667: }
      001221 85*00 81         [24] 4034 	mov	sp,_bp
      001224 D0*00            [24] 4035 	pop	_bp
      001226 22               [24] 4036 	ret
                                   4037 ;------------------------------------------------------------
                                   4038 ;Allocation info for local variables in function 'FAT16_GET_NEXT_CLUSTER'
                                   4039 ;------------------------------------------------------------
                                   4040 ;current_cluster           Allocated to registers r6 r7 
                                   4041 ;temp                      Allocated to stack - _bp +8
                                   4042 ;sloc0                     Allocated to stack - _bp +1
                                   4043 ;sloc1                     Allocated to stack - _bp +8
                                   4044 ;sloc2                     Allocated to stack - _bp +10
                                   4045 ;sloc3                     Allocated to stack - _bp +4
                                   4046 ;------------------------------------------------------------
                                   4047 ;	fat.h:670: uint16_t FAT16_GET_NEXT_CLUSTER(uint16_t current_cluster) __reentrant
                                   4048 ;	-----------------------------------------
                                   4049 ;	 function FAT16_GET_NEXT_CLUSTER
                                   4050 ;	-----------------------------------------
      001227                       4051 _FAT16_GET_NEXT_CLUSTER:
      001227 C0*00            [24] 4052 	push	_bp
      001229 E5 81            [12] 4053 	mov	a,sp
      00122B F5*00            [12] 4054 	mov	_bp,a
      00122D 24 09            [12] 4055 	add	a,#0x09
      00122F F5 81            [12] 4056 	mov	sp,a
      001231 AE 82            [24] 4057 	mov	r6,dpl
      001233 AF 83            [24] 4058 	mov	r7,dph
                                   4059 ;	fat.h:679: SDread(__global_vbr.addr_fat_start + (current_cluster*2)/__global_vbr.bps, (current_cluster*2) % __global_vbr.bps, 2, temp);
      001235 E5*00            [12] 4060 	mov	a,_bp
      001237 24 08            [12] 4061 	add	a,#0x08
      001239 F9               [12] 4062 	mov	r1,a
      00123A A8*00            [24] 4063 	mov	r0,_bp
      00123C 08               [12] 4064 	inc	r0
      00123D A6 01            [24] 4065 	mov	@r0,ar1
      00123F 08               [12] 4066 	inc	r0
      001240 76 00            [12] 4067 	mov	@r0,#0x00
      001242 08               [12] 4068 	inc	r0
      001243 76 40            [12] 4069 	mov	@r0,#0x40
      001245 EE               [12] 4070 	mov	a,r6
      001246 2E               [12] 4071 	add	a,r6
      001247 FE               [12] 4072 	mov	r6,a
      001248 EF               [12] 4073 	mov	a,r7
      001249 33               [12] 4074 	rlc	a
      00124A FF               [12] 4075 	mov	r7,a
      00124B 78r0F            [12] 4076 	mov	r0,#(___global_vbr + 0x0006)
      00124D 86 05            [24] 4077 	mov	ar5,@r0
      00124F 08               [12] 4078 	inc	r0
      001250 86 04            [24] 4079 	mov	ar4,@r0
      001252 8D*00            [24] 4080 	mov	__moduint_PARM_2,r5
      001254 8C*01            [24] 4081 	mov	(__moduint_PARM_2 + 1),r4
      001256 8E 82            [24] 4082 	mov	dpl,r6
      001258 8F 83            [24] 4083 	mov	dph,r7
      00125A C0 07            [24] 4084 	push	ar7
      00125C C0 06            [24] 4085 	push	ar6
      00125E C0 05            [24] 4086 	push	ar5
      001260 C0 04            [24] 4087 	push	ar4
      001262 C0 01            [24] 4088 	push	ar1
      001264 12r00r00         [24] 4089 	lcall	__moduint
      001267 AB 82            [24] 4090 	mov	r3,dpl
      001269 AA 83            [24] 4091 	mov	r2,dph
      00126B D0 01            [24] 4092 	pop	ar1
      00126D D0 04            [24] 4093 	pop	ar4
      00126F D0 05            [24] 4094 	pop	ar5
      001271 D0 06            [24] 4095 	pop	ar6
      001273 D0 07            [24] 4096 	pop	ar7
      001275 E5*00            [12] 4097 	mov	a,_bp
      001277 24 04            [12] 4098 	add	a,#0x04
      001279 F8               [12] 4099 	mov	r0,a
      00127A C0 01            [24] 4100 	push	ar1
      00127C 79r1C            [12] 4101 	mov	r1,#(___global_vbr + 0x0013)
      00127E E7               [12] 4102 	mov	a,@r1
      00127F F6               [12] 4103 	mov	@r0,a
      001280 09               [12] 4104 	inc	r1
      001281 E7               [12] 4105 	mov	a,@r1
      001282 08               [12] 4106 	inc	r0
      001283 F6               [12] 4107 	mov	@r0,a
      001284 09               [12] 4108 	inc	r1
      001285 E7               [12] 4109 	mov	a,@r1
      001286 08               [12] 4110 	inc	r0
      001287 F6               [12] 4111 	mov	@r0,a
      001288 09               [12] 4112 	inc	r1
      001289 E7               [12] 4113 	mov	a,@r1
      00128A 08               [12] 4114 	inc	r0
      00128B F6               [12] 4115 	mov	@r0,a
      00128C D0 01            [24] 4116 	pop	ar1
      00128E 8D*00            [24] 4117 	mov	__divuint_PARM_2,r5
      001290 8C*01            [24] 4118 	mov	(__divuint_PARM_2 + 1),r4
      001292 8E 82            [24] 4119 	mov	dpl,r6
      001294 8F 83            [24] 4120 	mov	dph,r7
      001296 C0 03            [24] 4121 	push	ar3
      001298 C0 02            [24] 4122 	push	ar2
      00129A C0 01            [24] 4123 	push	ar1
      00129C 12r00r00         [24] 4124 	lcall	__divuint
      00129F AE 82            [24] 4125 	mov	r6,dpl
      0012A1 AF 83            [24] 4126 	mov	r7,dph
      0012A3 D0 01            [24] 4127 	pop	ar1
      0012A5 D0 02            [24] 4128 	pop	ar2
      0012A7 D0 03            [24] 4129 	pop	ar3
      0012A9 8E 04            [24] 4130 	mov	ar4,r6
      0012AB 8F 05            [24] 4131 	mov	ar5,r7
      0012AD E4               [12] 4132 	clr	a
      0012AE FE               [12] 4133 	mov	r6,a
      0012AF FF               [12] 4134 	mov	r7,a
      0012B0 E5*00            [12] 4135 	mov	a,_bp
      0012B2 24 04            [12] 4136 	add	a,#0x04
      0012B4 F8               [12] 4137 	mov	r0,a
      0012B5 EC               [12] 4138 	mov	a,r4
      0012B6 26               [12] 4139 	add	a,@r0
      0012B7 FC               [12] 4140 	mov	r4,a
      0012B8 ED               [12] 4141 	mov	a,r5
      0012B9 08               [12] 4142 	inc	r0
      0012BA 36               [12] 4143 	addc	a,@r0
      0012BB FD               [12] 4144 	mov	r5,a
      0012BC EE               [12] 4145 	mov	a,r6
      0012BD 08               [12] 4146 	inc	r0
      0012BE 36               [12] 4147 	addc	a,@r0
      0012BF FE               [12] 4148 	mov	r6,a
      0012C0 EF               [12] 4149 	mov	a,r7
      0012C1 08               [12] 4150 	inc	r0
      0012C2 36               [12] 4151 	addc	a,@r0
      0012C3 FF               [12] 4152 	mov	r7,a
      0012C4 C0 01            [24] 4153 	push	ar1
      0012C6 A8*00            [24] 4154 	mov	r0,_bp
      0012C8 08               [12] 4155 	inc	r0
      0012C9 E6               [12] 4156 	mov	a,@r0
      0012CA C0 E0            [24] 4157 	push	acc
      0012CC 08               [12] 4158 	inc	r0
      0012CD E6               [12] 4159 	mov	a,@r0
      0012CE C0 E0            [24] 4160 	push	acc
      0012D0 08               [12] 4161 	inc	r0
      0012D1 E6               [12] 4162 	mov	a,@r0
      0012D2 C0 E0            [24] 4163 	push	acc
      0012D4 74 02            [12] 4164 	mov	a,#0x02
      0012D6 C0 E0            [24] 4165 	push	acc
      0012D8 E4               [12] 4166 	clr	a
      0012D9 C0 E0            [24] 4167 	push	acc
      0012DB C0 03            [24] 4168 	push	ar3
      0012DD C0 02            [24] 4169 	push	ar2
      0012DF 8C 82            [24] 4170 	mov	dpl,r4
      0012E1 8D 83            [24] 4171 	mov	dph,r5
      0012E3 8E F0            [24] 4172 	mov	b,r6
      0012E5 EF               [12] 4173 	mov	a,r7
      0012E6 12r06rDE         [24] 4174 	lcall	_SDread
      0012E9 E5 81            [12] 4175 	mov	a,sp
      0012EB 24 F9            [12] 4176 	add	a,#0xf9
      0012ED F5 81            [12] 4177 	mov	sp,a
      0012EF D0 01            [24] 4178 	pop	ar1
                                   4179 ;	fat.h:680: return (uint16_t)temp[1] << 8 | temp[0]; 
      0012F1 E9               [12] 4180 	mov	a,r1
      0012F2 04               [12] 4181 	inc	a
      0012F3 F8               [12] 4182 	mov	r0,a
      0012F4 86 07            [24] 4183 	mov	ar7,@r0
      0012F6 8F 06            [24] 4184 	mov	ar6,r7
      0012F8 7F 00            [12] 4185 	mov	r7,#0x00
      0012FA 87 05            [24] 4186 	mov	ar5,@r1
      0012FC 7C 00            [12] 4187 	mov	r4,#0x00
      0012FE ED               [12] 4188 	mov	a,r5
      0012FF 4F               [12] 4189 	orl	a,r7
      001300 F5 82            [12] 4190 	mov	dpl,a
      001302 EC               [12] 4191 	mov	a,r4
      001303 4E               [12] 4192 	orl	a,r6
      001304 F5 83            [12] 4193 	mov	dph,a
                                   4194 ;	fat.h:686: }
      001306 85*00 81         [24] 4195 	mov	sp,_bp
      001309 D0*00            [24] 4196 	pop	_bp
      00130B 22               [24] 4197 	ret
                                   4198 ;------------------------------------------------------------
                                   4199 ;Allocation info for local variables in function 'FAT16_FILE_READ'
                                   4200 ;------------------------------------------------------------
                                   4201 ;dst                       Allocated to stack - _bp -5
                                   4202 ;nbytes                    Allocated to stack - _bp +1
                                   4203 ;current_cluster           Allocated to registers r7 r6 
                                   4204 ;bytes_read_in_current_cluster Allocated to stack - _bp +10
                                   4205 ;bytes_read_in_current_sector Allocated to stack - _bp +12
                                   4206 ;current_sector            Allocated to stack - _bp +14
                                   4207 ;sloc0                     Allocated to stack - _bp +2
                                   4208 ;sloc1                     Allocated to stack - _bp +6
                                   4209 ;------------------------------------------------------------
                                   4210 ;	fat.h:707: uint8_t FAT16_FILE_READ(uint8_t nbytes, uint8_t *dst) __reentrant
                                   4211 ;	-----------------------------------------
                                   4212 ;	 function FAT16_FILE_READ
                                   4213 ;	-----------------------------------------
      00130C                       4214 _FAT16_FILE_READ:
      00130C C0*00            [24] 4215 	push	_bp
      00130E 85 81*00         [24] 4216 	mov	_bp,sp
      001311 C0 82            [24] 4217 	push	dpl
      001313 E5 81            [12] 4218 	mov	a,sp
      001315 24 10            [12] 4219 	add	a,#0x10
      001317 F5 81            [12] 4220 	mov	sp,a
                                   4221 ;	fat.h:716: if(nbytes==0)
      001319 A8*00            [24] 4222 	mov	r0,_bp
      00131B 08               [12] 4223 	inc	r0
      00131C E6               [12] 4224 	mov	a,@r0
                                   4225 ;	fat.h:718: return 0; //read 0 bytes
      00131D 70 05            [24] 4226 	jnz	00102$
      00131F F5 82            [12] 4227 	mov	dpl,a
      001321 02r15r6F         [24] 4228 	ljmp	00113$
      001324                       4229 00102$:
                                   4230 ;	fat.h:721: if(nbytes & (nbytes-1))
      001324 A8*00            [24] 4231 	mov	r0,_bp
      001326 08               [12] 4232 	inc	r0
      001327 86 05            [24] 4233 	mov	ar5,@r0
      001329 7E 00            [12] 4234 	mov	r6,#0x00
      00132B ED               [12] 4235 	mov	a,r5
      00132C 24 FF            [12] 4236 	add	a,#0xff
      00132E FB               [12] 4237 	mov	r3,a
      00132F EE               [12] 4238 	mov	a,r6
      001330 34 FF            [12] 4239 	addc	a,#0xff
      001332 FC               [12] 4240 	mov	r4,a
      001333 EB               [12] 4241 	mov	a,r3
      001334 52 05            [12] 4242 	anl	ar5,a
      001336 EC               [12] 4243 	mov	a,r4
      001337 52 06            [12] 4244 	anl	ar6,a
      001339 ED               [12] 4245 	mov	a,r5
      00133A 4E               [12] 4246 	orl	a,r6
      00133B 60 06            [24] 4247 	jz	00104$
                                   4248 ;	fat.h:726: return 255; //error
      00133D 75 82 FF         [24] 4249 	mov	dpl,#0xff
      001340 02r15r6F         [24] 4250 	ljmp	00113$
      001343                       4251 00104$:
                                   4252 ;	fat.h:729: if(__global_rootEntry.bytes_read == __global_rootEntry.size)
      001343 A8*00            [24] 4253 	mov	r0,_bp
      001345 08               [12] 4254 	inc	r0
      001346 08               [12] 4255 	inc	r0
      001347 79r3D            [12] 4256 	mov	r1,#(___global_rootEntry + 0x0014)
      001349 E7               [12] 4257 	mov	a,@r1
      00134A F6               [12] 4258 	mov	@r0,a
      00134B 09               [12] 4259 	inc	r1
      00134C E7               [12] 4260 	mov	a,@r1
      00134D 08               [12] 4261 	inc	r0
      00134E F6               [12] 4262 	mov	@r0,a
      00134F 09               [12] 4263 	inc	r1
      001350 E7               [12] 4264 	mov	a,@r1
      001351 08               [12] 4265 	inc	r0
      001352 F6               [12] 4266 	mov	@r0,a
      001353 09               [12] 4267 	inc	r1
      001354 E7               [12] 4268 	mov	a,@r1
      001355 08               [12] 4269 	inc	r0
      001356 F6               [12] 4270 	mov	@r0,a
      001357 78r37            [12] 4271 	mov	r0,#(___global_rootEntry + 0x000e)
      001359 86 02            [24] 4272 	mov	ar2,@r0
      00135B 08               [12] 4273 	inc	r0
      00135C 86 05            [24] 4274 	mov	ar5,@r0
      00135E 08               [12] 4275 	inc	r0
      00135F 86 06            [24] 4276 	mov	ar6,@r0
      001361 08               [12] 4277 	inc	r0
      001362 86 07            [24] 4278 	mov	ar7,@r0
      001364 A8*00            [24] 4279 	mov	r0,_bp
      001366 08               [12] 4280 	inc	r0
      001367 08               [12] 4281 	inc	r0
      001368 E6               [12] 4282 	mov	a,@r0
      001369 B5 02 11         [24] 4283 	cjne	a,ar2,00141$
      00136C 08               [12] 4284 	inc	r0
      00136D E6               [12] 4285 	mov	a,@r0
      00136E B5 05 0C         [24] 4286 	cjne	a,ar5,00141$
      001371 08               [12] 4287 	inc	r0
      001372 E6               [12] 4288 	mov	a,@r0
      001373 B5 06 07         [24] 4289 	cjne	a,ar6,00141$
      001376 08               [12] 4290 	inc	r0
      001377 E6               [12] 4291 	mov	a,@r0
      001378 B5 07 02         [24] 4292 	cjne	a,ar7,00141$
      00137B 80 02            [24] 4293 	sjmp	00142$
      00137D                       4294 00141$:
      00137D 80 06            [24] 4295 	sjmp	00111$
      00137F                       4296 00142$:
                                   4297 ;	fat.h:731: return 0; //end of file - return number of bytes read
      00137F 75 82 00         [24] 4298 	mov	dpl,#0x00
      001382 02r15r6F         [24] 4299 	ljmp	00113$
      001385                       4300 00111$:
                                   4301 ;	fat.h:736: bytes_read_in_current_cluster = __global_rootEntry.bytes_read % __global_vbr.bpc;
      001385 78r18            [12] 4302 	mov	r0,#(___global_vbr + 0x000f)
      001387 86*00            [24] 4303 	mov	__modulong_PARM_2,@r0
      001389 08               [12] 4304 	inc	r0
      00138A 86*01            [24] 4305 	mov	(__modulong_PARM_2 + 1),@r0
      00138C 08               [12] 4306 	inc	r0
      00138D 86*02            [24] 4307 	mov	(__modulong_PARM_2 + 2),@r0
      00138F 08               [12] 4308 	inc	r0
      001390 86*03            [24] 4309 	mov	(__modulong_PARM_2 + 3),@r0
      001392 A8*00            [24] 4310 	mov	r0,_bp
      001394 08               [12] 4311 	inc	r0
      001395 08               [12] 4312 	inc	r0
      001396 86 82            [24] 4313 	mov	dpl,@r0
      001398 08               [12] 4314 	inc	r0
      001399 86 83            [24] 4315 	mov	dph,@r0
      00139B 08               [12] 4316 	inc	r0
      00139C 86 F0            [24] 4317 	mov	b,@r0
      00139E 08               [12] 4318 	inc	r0
      00139F E6               [12] 4319 	mov	a,@r0
      0013A0 12r00r00         [24] 4320 	lcall	__modulong
      0013A3 AB 82            [24] 4321 	mov	r3,dpl
      0013A5 AC 83            [24] 4322 	mov	r4,dph
      0013A7 E5*00            [12] 4323 	mov	a,_bp
      0013A9 24 0A            [12] 4324 	add	a,#0x0a
      0013AB F8               [12] 4325 	mov	r0,a
      0013AC A6 03            [24] 4326 	mov	@r0,ar3
      0013AE 08               [12] 4327 	inc	r0
      0013AF A6 04            [24] 4328 	mov	@r0,ar4
                                   4329 ;	fat.h:780: if(__global_rootEntry.bytes_read!=0 && bytes_read_in_current_cluster==0)
      0013B1 A8*00            [24] 4330 	mov	r0,_bp
      0013B3 08               [12] 4331 	inc	r0
      0013B4 08               [12] 4332 	inc	r0
      0013B5 E6               [12] 4333 	mov	a,@r0
      0013B6 08               [12] 4334 	inc	r0
      0013B7 46               [12] 4335 	orl	a,@r0
      0013B8 08               [12] 4336 	inc	r0
      0013B9 46               [12] 4337 	orl	a,@r0
      0013BA 08               [12] 4338 	inc	r0
      0013BB 46               [12] 4339 	orl	a,@r0
      0013BC 60 1F            [24] 4340 	jz	00106$
      0013BE E5*00            [12] 4341 	mov	a,_bp
      0013C0 24 0A            [12] 4342 	add	a,#0x0a
      0013C2 F8               [12] 4343 	mov	r0,a
      0013C3 E6               [12] 4344 	mov	a,@r0
      0013C4 08               [12] 4345 	inc	r0
      0013C5 46               [12] 4346 	orl	a,@r0
      0013C6 70 15            [24] 4347 	jnz	00106$
                                   4348 ;	fat.h:782: __global_rootEntry.startCluster = FAT16_GET_NEXT_CLUSTER(__global_rootEntry.startCluster);
      0013C8 78r35            [12] 4349 	mov	r0,#(___global_rootEntry + 0x000c)
      0013CA 86 82            [24] 4350 	mov	dpl,@r0
      0013CC 08               [12] 4351 	inc	r0
      0013CD 86 83            [24] 4352 	mov	dph,@r0
      0013CF 12r12r27         [24] 4353 	lcall	_FAT16_GET_NEXT_CLUSTER
      0013D2 E5 82            [12] 4354 	mov	a,dpl
      0013D4 85 83 F0         [24] 4355 	mov	b,dph
      0013D7 78r35            [12] 4356 	mov	r0,#(___global_rootEntry + 0x000c)
      0013D9 F6               [12] 4357 	mov	@r0,a
      0013DA 08               [12] 4358 	inc	r0
      0013DB A6 F0            [24] 4359 	mov	@r0,b
      0013DD                       4360 00106$:
                                   4361 ;	fat.h:786: current_cluster = __global_rootEntry.startCluster;
      0013DD 78r35            [12] 4362 	mov	r0,#(___global_rootEntry + 0x000c)
      0013DF 86 07            [24] 4363 	mov	ar7,@r0
      0013E1 08               [12] 4364 	inc	r0
      0013E2 86 06            [24] 4365 	mov	ar6,@r0
                                   4366 ;	fat.h:791: current_sector =    __global_vbr.addr_data_start 						//start of data
      0013E4 A8*00            [24] 4367 	mov	r0,_bp
      0013E6 08               [12] 4368 	inc	r0
      0013E7 08               [12] 4369 	inc	r0
      0013E8 79r24            [12] 4370 	mov	r1,#(___global_vbr + 0x001b)
      0013EA E7               [12] 4371 	mov	a,@r1
      0013EB F6               [12] 4372 	mov	@r0,a
      0013EC 09               [12] 4373 	inc	r1
      0013ED E7               [12] 4374 	mov	a,@r1
      0013EE 08               [12] 4375 	inc	r0
      0013EF F6               [12] 4376 	mov	@r0,a
      0013F0 09               [12] 4377 	inc	r1
      0013F1 E7               [12] 4378 	mov	a,@r1
      0013F2 08               [12] 4379 	inc	r0
      0013F3 F6               [12] 4380 	mov	@r0,a
      0013F4 09               [12] 4381 	inc	r1
      0013F5 E7               [12] 4382 	mov	a,@r1
      0013F6 08               [12] 4383 	inc	r0
      0013F7 F6               [12] 4384 	mov	@r0,a
                                   4385 ;	fat.h:792: + (current_cluster-2) * __global_vbr.spc 				//skip to the start of current cluster
      0013F8 EF               [12] 4386 	mov	a,r7
      0013F9 24 FE            [12] 4387 	add	a,#0xfe
      0013FB F5 82            [12] 4388 	mov	dpl,a
      0013FD EE               [12] 4389 	mov	a,r6
      0013FE 34 FF            [12] 4390 	addc	a,#0xff
      001400 F5 83            [12] 4391 	mov	dph,a
      001402 78r11            [12] 4392 	mov	r0,#(___global_vbr + 0x0008)
      001404 86 03            [24] 4393 	mov	ar3,@r0
      001406 8B*00            [24] 4394 	mov	__mulint_PARM_2,r3
      001408 75*01 00         [24] 4395 	mov	(__mulint_PARM_2 + 1),#0x00
      00140B 12r00r00         [24] 4396 	lcall	__mulint
      00140E AB 82            [24] 4397 	mov	r3,dpl
      001410 AF 83            [24] 4398 	mov	r7,dph
      001412 8F 05            [24] 4399 	mov	ar5,r7
      001414 7E 00            [12] 4400 	mov	r6,#0x00
      001416 7F 00            [12] 4401 	mov	r7,#0x00
      001418 A8*00            [24] 4402 	mov	r0,_bp
      00141A 08               [12] 4403 	inc	r0
      00141B 08               [12] 4404 	inc	r0
      00141C EB               [12] 4405 	mov	a,r3
      00141D 26               [12] 4406 	add	a,@r0
      00141E F6               [12] 4407 	mov	@r0,a
      00141F ED               [12] 4408 	mov	a,r5
      001420 08               [12] 4409 	inc	r0
      001421 36               [12] 4410 	addc	a,@r0
      001422 F6               [12] 4411 	mov	@r0,a
      001423 EE               [12] 4412 	mov	a,r6
      001424 08               [12] 4413 	inc	r0
      001425 36               [12] 4414 	addc	a,@r0
      001426 F6               [12] 4415 	mov	@r0,a
      001427 EF               [12] 4416 	mov	a,r7
      001428 08               [12] 4417 	inc	r0
      001429 36               [12] 4418 	addc	a,@r0
      00142A F6               [12] 4419 	mov	@r0,a
                                   4420 ;	fat.h:793: + bytes_read_in_current_cluster/__global_vbr.bps;	//skip sectors already read in current cluster
      00142B 78r0F            [12] 4421 	mov	r0,#(___global_vbr + 0x0006)
      00142D 86 02            [24] 4422 	mov	ar2,@r0
      00142F 08               [12] 4423 	inc	r0
      001430 86 04            [24] 4424 	mov	ar4,@r0
      001432 8A*00            [24] 4425 	mov	__divuint_PARM_2,r2
      001434 8C*01            [24] 4426 	mov	(__divuint_PARM_2 + 1),r4
      001436 E5*00            [12] 4427 	mov	a,_bp
      001438 24 0A            [12] 4428 	add	a,#0x0a
      00143A F8               [12] 4429 	mov	r0,a
      00143B 86 82            [24] 4430 	mov	dpl,@r0
      00143D 08               [12] 4431 	inc	r0
      00143E 86 83            [24] 4432 	mov	dph,@r0
      001440 C0 04            [24] 4433 	push	ar4
      001442 C0 02            [24] 4434 	push	ar2
      001444 12r00r00         [24] 4435 	lcall	__divuint
      001447 AE 82            [24] 4436 	mov	r6,dpl
      001449 AF 83            [24] 4437 	mov	r7,dph
      00144B D0 02            [24] 4438 	pop	ar2
      00144D D0 04            [24] 4439 	pop	ar4
      00144F 7D 00            [12] 4440 	mov	r5,#0x00
      001451 7B 00            [12] 4441 	mov	r3,#0x00
      001453 A8*00            [24] 4442 	mov	r0,_bp
      001455 08               [12] 4443 	inc	r0
      001456 08               [12] 4444 	inc	r0
      001457 EE               [12] 4445 	mov	a,r6
      001458 26               [12] 4446 	add	a,@r0
      001459 FE               [12] 4447 	mov	r6,a
      00145A EF               [12] 4448 	mov	a,r7
      00145B 08               [12] 4449 	inc	r0
      00145C 36               [12] 4450 	addc	a,@r0
      00145D FF               [12] 4451 	mov	r7,a
      00145E ED               [12] 4452 	mov	a,r5
      00145F 08               [12] 4453 	inc	r0
      001460 36               [12] 4454 	addc	a,@r0
      001461 FD               [12] 4455 	mov	r5,a
      001462 EB               [12] 4456 	mov	a,r3
      001463 08               [12] 4457 	inc	r0
      001464 36               [12] 4458 	addc	a,@r0
      001465 FB               [12] 4459 	mov	r3,a
      001466 E5*00            [12] 4460 	mov	a,_bp
      001468 24 0E            [12] 4461 	add	a,#0x0e
      00146A F8               [12] 4462 	mov	r0,a
      00146B A6 06            [24] 4463 	mov	@r0,ar6
      00146D 08               [12] 4464 	inc	r0
      00146E A6 07            [24] 4465 	mov	@r0,ar7
      001470 08               [12] 4466 	inc	r0
      001471 A6 05            [24] 4467 	mov	@r0,ar5
      001473 08               [12] 4468 	inc	r0
      001474 A6 03            [24] 4469 	mov	@r0,ar3
                                   4470 ;	fat.h:796: bytes_read_in_current_sector = bytes_read_in_current_cluster % __global_vbr.bps;
      001476 8A*00            [24] 4471 	mov	__moduint_PARM_2,r2
      001478 8C*01            [24] 4472 	mov	(__moduint_PARM_2 + 1),r4
      00147A E5*00            [12] 4473 	mov	a,_bp
      00147C 24 0A            [12] 4474 	add	a,#0x0a
      00147E F8               [12] 4475 	mov	r0,a
      00147F 86 82            [24] 4476 	mov	dpl,@r0
      001481 08               [12] 4477 	inc	r0
      001482 86 83            [24] 4478 	mov	dph,@r0
      001484 12r00r00         [24] 4479 	lcall	__moduint
      001487 C8               [12] 4480 	xch	a,r0
      001488 E5*00            [12] 4481 	mov	a,_bp
      00148A 24 0C            [12] 4482 	add	a,#0x0c
      00148C C8               [12] 4483 	xch	a,r0
      00148D A6 82            [24] 4484 	mov	@r0,dpl
      00148F 08               [12] 4485 	inc	r0
      001490 A6 83            [24] 4486 	mov	@r0,dph
                                   4487 ;	fat.h:800: if(__global_rootEntry.bytes_read + nbytes > __global_rootEntry.size )
      001492 A8*00            [24] 4488 	mov	r0,_bp
      001494 08               [12] 4489 	inc	r0
      001495 08               [12] 4490 	inc	r0
      001496 79r3D            [12] 4491 	mov	r1,#(___global_rootEntry + 0x0014)
      001498 E7               [12] 4492 	mov	a,@r1
      001499 F6               [12] 4493 	mov	@r0,a
      00149A 09               [12] 4494 	inc	r1
      00149B E7               [12] 4495 	mov	a,@r1
      00149C 08               [12] 4496 	inc	r0
      00149D F6               [12] 4497 	mov	@r0,a
      00149E 09               [12] 4498 	inc	r1
      00149F E7               [12] 4499 	mov	a,@r1
      0014A0 08               [12] 4500 	inc	r0
      0014A1 F6               [12] 4501 	mov	@r0,a
      0014A2 09               [12] 4502 	inc	r1
      0014A3 E7               [12] 4503 	mov	a,@r1
      0014A4 08               [12] 4504 	inc	r0
      0014A5 F6               [12] 4505 	mov	@r0,a
      0014A6 A8*00            [24] 4506 	mov	r0,_bp
      0014A8 08               [12] 4507 	inc	r0
      0014A9 86 03            [24] 4508 	mov	ar3,@r0
      0014AB 7D 00            [12] 4509 	mov	r5,#0x00
      0014AD 7E 00            [12] 4510 	mov	r6,#0x00
      0014AF 7F 00            [12] 4511 	mov	r7,#0x00
      0014B1 A8*00            [24] 4512 	mov	r0,_bp
      0014B3 08               [12] 4513 	inc	r0
      0014B4 08               [12] 4514 	inc	r0
      0014B5 EB               [12] 4515 	mov	a,r3
      0014B6 26               [12] 4516 	add	a,@r0
      0014B7 FB               [12] 4517 	mov	r3,a
      0014B8 ED               [12] 4518 	mov	a,r5
      0014B9 08               [12] 4519 	inc	r0
      0014BA 36               [12] 4520 	addc	a,@r0
      0014BB FD               [12] 4521 	mov	r5,a
      0014BC EE               [12] 4522 	mov	a,r6
      0014BD 08               [12] 4523 	inc	r0
      0014BE 36               [12] 4524 	addc	a,@r0
      0014BF FE               [12] 4525 	mov	r6,a
      0014C0 EF               [12] 4526 	mov	a,r7
      0014C1 08               [12] 4527 	inc	r0
      0014C2 36               [12] 4528 	addc	a,@r0
      0014C3 FF               [12] 4529 	mov	r7,a
      0014C4 E5*00            [12] 4530 	mov	a,_bp
      0014C6 24 06            [12] 4531 	add	a,#0x06
      0014C8 F8               [12] 4532 	mov	r0,a
      0014C9 79r37            [12] 4533 	mov	r1,#(___global_rootEntry + 0x000e)
      0014CB E7               [12] 4534 	mov	a,@r1
      0014CC F6               [12] 4535 	mov	@r0,a
      0014CD 09               [12] 4536 	inc	r1
      0014CE E7               [12] 4537 	mov	a,@r1
      0014CF 08               [12] 4538 	inc	r0
      0014D0 F6               [12] 4539 	mov	@r0,a
      0014D1 09               [12] 4540 	inc	r1
      0014D2 E7               [12] 4541 	mov	a,@r1
      0014D3 08               [12] 4542 	inc	r0
      0014D4 F6               [12] 4543 	mov	@r0,a
      0014D5 09               [12] 4544 	inc	r1
      0014D6 E7               [12] 4545 	mov	a,@r1
      0014D7 08               [12] 4546 	inc	r0
      0014D8 F6               [12] 4547 	mov	@r0,a
      0014D9 E5*00            [12] 4548 	mov	a,_bp
      0014DB 24 06            [12] 4549 	add	a,#0x06
      0014DD F8               [12] 4550 	mov	r0,a
      0014DE C3               [12] 4551 	clr	c
      0014DF E6               [12] 4552 	mov	a,@r0
      0014E0 9B               [12] 4553 	subb	a,r3
      0014E1 08               [12] 4554 	inc	r0
      0014E2 E6               [12] 4555 	mov	a,@r0
      0014E3 9D               [12] 4556 	subb	a,r5
      0014E4 08               [12] 4557 	inc	r0
      0014E5 E6               [12] 4558 	mov	a,@r0
      0014E6 9E               [12] 4559 	subb	a,r6
      0014E7 08               [12] 4560 	inc	r0
      0014E8 E6               [12] 4561 	mov	a,@r0
      0014E9 9F               [12] 4562 	subb	a,r7
      0014EA 50 14            [24] 4563 	jnc	00109$
                                   4564 ;	fat.h:802: nbytes = __global_rootEntry.size - __global_rootEntry.bytes_read;//;
      0014EC E5*00            [12] 4565 	mov	a,_bp
      0014EE 24 06            [12] 4566 	add	a,#0x06
      0014F0 F8               [12] 4567 	mov	r0,a
      0014F1 86 07            [24] 4568 	mov	ar7,@r0
      0014F3 A8*00            [24] 4569 	mov	r0,_bp
      0014F5 08               [12] 4570 	inc	r0
      0014F6 08               [12] 4571 	inc	r0
      0014F7 86 02            [24] 4572 	mov	ar2,@r0
      0014F9 A8*00            [24] 4573 	mov	r0,_bp
      0014FB 08               [12] 4574 	inc	r0
      0014FC EF               [12] 4575 	mov	a,r7
      0014FD C3               [12] 4576 	clr	c
      0014FE 9A               [12] 4577 	subb	a,r2
      0014FF F6               [12] 4578 	mov	@r0,a
      001500                       4579 00109$:
                                   4580 ;	fat.h:821: __global_rootEntry.bytes_read += nbytes;
      001500 A8*00            [24] 4581 	mov	r0,_bp
      001502 08               [12] 4582 	inc	r0
      001503 86 04            [24] 4583 	mov	ar4,@r0
      001505 7D 00            [12] 4584 	mov	r5,#0x00
      001507 7E 00            [12] 4585 	mov	r6,#0x00
      001509 7F 00            [12] 4586 	mov	r7,#0x00
      00150B A8*00            [24] 4587 	mov	r0,_bp
      00150D 08               [12] 4588 	inc	r0
      00150E 08               [12] 4589 	inc	r0
      00150F EC               [12] 4590 	mov	a,r4
      001510 26               [12] 4591 	add	a,@r0
      001511 FC               [12] 4592 	mov	r4,a
      001512 ED               [12] 4593 	mov	a,r5
      001513 08               [12] 4594 	inc	r0
      001514 36               [12] 4595 	addc	a,@r0
      001515 FD               [12] 4596 	mov	r5,a
      001516 EE               [12] 4597 	mov	a,r6
      001517 08               [12] 4598 	inc	r0
      001518 36               [12] 4599 	addc	a,@r0
      001519 FE               [12] 4600 	mov	r6,a
      00151A EF               [12] 4601 	mov	a,r7
      00151B 08               [12] 4602 	inc	r0
      00151C 36               [12] 4603 	addc	a,@r0
      00151D FF               [12] 4604 	mov	r7,a
      00151E 78r3D            [12] 4605 	mov	r0,#(___global_rootEntry + 0x0014)
      001520 A6 04            [24] 4606 	mov	@r0,ar4
      001522 08               [12] 4607 	inc	r0
      001523 A6 05            [24] 4608 	mov	@r0,ar5
      001525 08               [12] 4609 	inc	r0
      001526 A6 06            [24] 4610 	mov	@r0,ar6
      001528 08               [12] 4611 	inc	r0
      001529 A6 07            [24] 4612 	mov	@r0,ar7
                                   4613 ;	fat.h:824: SDread(current_sector,bytes_read_in_current_sector,nbytes,dst);
      00152B A8*00            [24] 4614 	mov	r0,_bp
      00152D 08               [12] 4615 	inc	r0
      00152E 86 06            [24] 4616 	mov	ar6,@r0
      001530 7F 00            [12] 4617 	mov	r7,#0x00
      001532 E5*00            [12] 4618 	mov	a,_bp
      001534 24 FB            [12] 4619 	add	a,#0xfb
      001536 F8               [12] 4620 	mov	r0,a
      001537 E6               [12] 4621 	mov	a,@r0
      001538 C0 E0            [24] 4622 	push	acc
      00153A 08               [12] 4623 	inc	r0
      00153B E6               [12] 4624 	mov	a,@r0
      00153C C0 E0            [24] 4625 	push	acc
      00153E 08               [12] 4626 	inc	r0
      00153F E6               [12] 4627 	mov	a,@r0
      001540 C0 E0            [24] 4628 	push	acc
      001542 C0 06            [24] 4629 	push	ar6
      001544 C0 07            [24] 4630 	push	ar7
      001546 E5*00            [12] 4631 	mov	a,_bp
      001548 24 0C            [12] 4632 	add	a,#0x0c
      00154A F8               [12] 4633 	mov	r0,a
      00154B E6               [12] 4634 	mov	a,@r0
      00154C C0 E0            [24] 4635 	push	acc
      00154E 08               [12] 4636 	inc	r0
      00154F E6               [12] 4637 	mov	a,@r0
      001550 C0 E0            [24] 4638 	push	acc
      001552 E5*00            [12] 4639 	mov	a,_bp
      001554 24 0E            [12] 4640 	add	a,#0x0e
      001556 F8               [12] 4641 	mov	r0,a
      001557 86 82            [24] 4642 	mov	dpl,@r0
      001559 08               [12] 4643 	inc	r0
      00155A 86 83            [24] 4644 	mov	dph,@r0
      00155C 08               [12] 4645 	inc	r0
      00155D 86 F0            [24] 4646 	mov	b,@r0
      00155F 08               [12] 4647 	inc	r0
      001560 E6               [12] 4648 	mov	a,@r0
      001561 12r06rDE         [24] 4649 	lcall	_SDread
      001564 E5 81            [12] 4650 	mov	a,sp
      001566 24 F9            [12] 4651 	add	a,#0xf9
      001568 F5 81            [12] 4652 	mov	sp,a
                                   4653 ;	fat.h:829: return nbytes;
      00156A A8*00            [24] 4654 	mov	r0,_bp
      00156C 08               [12] 4655 	inc	r0
      00156D 86 82            [24] 4656 	mov	dpl,@r0
      00156F                       4657 00113$:
                                   4658 ;	fat.h:831: }
      00156F 85*00 81         [24] 4659 	mov	sp,_bp
      001572 D0*00            [24] 4660 	pop	_bp
      001574 22               [24] 4661 	ret
                                   4662 ;------------------------------------------------------------
                                   4663 ;Allocation info for local variables in function 'FAT16_FILE_CAT'
                                   4664 ;------------------------------------------------------------
                                   4665 ;filename                  Allocated to registers r5 r6 r7 
                                   4666 ;temp                      Allocated to stack - _bp +1
                                   4667 ;resp                      Allocated to registers r6 
                                   4668 ;i                         Allocated to registers r5 
                                   4669 ;------------------------------------------------------------
                                   4670 ;	fat.h:833: void FAT16_FILE_CAT(uint8_t *filename) __reentrant
                                   4671 ;	-----------------------------------------
                                   4672 ;	 function FAT16_FILE_CAT
                                   4673 ;	-----------------------------------------
      001575                       4674 _FAT16_FILE_CAT:
      001575 C0*00            [24] 4675 	push	_bp
      001577 E5 81            [12] 4676 	mov	a,sp
      001579 F5*00            [12] 4677 	mov	_bp,a
      00157B 24 08            [12] 4678 	add	a,#0x08
      00157D F5 81            [12] 4679 	mov	sp,a
                                   4680 ;	fat.h:840: if(FAT16_FILE_OPEN(filename))
      00157F 12r11r8F         [24] 4681 	lcall	_FAT16_FILE_OPEN
      001582 E5 82            [12] 4682 	mov	a,dpl
      001584 60 0B            [24] 4683 	jz	00115$
                                   4684 ;	fat.h:842: UartPrint("FILE NOT FOUND\n.");
      001586 90r00r45         [24] 4685 	mov	dptr,#___str_7
      001589 75 F0 80         [24] 4686 	mov	b,#0x80
      00158C 12r01r1B         [24] 4687 	lcall	_UartPrint
                                   4688 ;	fat.h:843: return;
                                   4689 ;	fat.h:846: do
      00158F 80 42            [24] 4690 	sjmp	00110$
      001591                       4691 00115$:
      001591 AF*00            [24] 4692 	mov	r7,_bp
      001593 0F               [12] 4693 	inc	r7
      001594                       4694 00104$:
                                   4695 ;	fat.h:848: resp=FAT16_FILE_READ(FILE_CAT_BUFFER_SIZE,temp);
      001594 8F 04            [24] 4696 	mov	ar4,r7
      001596 7D 00            [12] 4697 	mov	r5,#0x00
      001598 7E 40            [12] 4698 	mov	r6,#0x40
      00159A C0 07            [24] 4699 	push	ar7
      00159C C0 04            [24] 4700 	push	ar4
      00159E C0 05            [24] 4701 	push	ar5
      0015A0 C0 06            [24] 4702 	push	ar6
      0015A2 75 82 08         [24] 4703 	mov	dpl,#0x08
      0015A5 12r13r0C         [24] 4704 	lcall	_FAT16_FILE_READ
      0015A8 AE 82            [24] 4705 	mov	r6,dpl
      0015AA 15 81            [12] 4706 	dec	sp
      0015AC 15 81            [12] 4707 	dec	sp
      0015AE 15 81            [12] 4708 	dec	sp
      0015B0 D0 07            [24] 4709 	pop	ar7
                                   4710 ;	fat.h:849: for(uint8_t i=0;i<resp;i++) UartWrite(temp[i]);
      0015B2 7D 00            [12] 4711 	mov	r5,#0x00
      0015B4                       4712 00108$:
      0015B4 C3               [12] 4713 	clr	c
      0015B5 ED               [12] 4714 	mov	a,r5
      0015B6 9E               [12] 4715 	subb	a,r6
      0015B7 50 17            [24] 4716 	jnc	00105$
      0015B9 ED               [12] 4717 	mov	a,r5
      0015BA 2F               [12] 4718 	add	a,r7
      0015BB F9               [12] 4719 	mov	r1,a
      0015BC 87 82            [24] 4720 	mov	dpl,@r1
      0015BE C0 07            [24] 4721 	push	ar7
      0015C0 C0 06            [24] 4722 	push	ar6
      0015C2 C0 05            [24] 4723 	push	ar5
      0015C4 12r00r95         [24] 4724 	lcall	_UartWrite
      0015C7 D0 05            [24] 4725 	pop	ar5
      0015C9 D0 06            [24] 4726 	pop	ar6
      0015CB D0 07            [24] 4727 	pop	ar7
      0015CD 0D               [12] 4728 	inc	r5
      0015CE 80 E4            [24] 4729 	sjmp	00108$
      0015D0                       4730 00105$:
                                   4731 ;	fat.h:852: } while (resp!=0);
      0015D0 EE               [12] 4732 	mov	a,r6
      0015D1 70 C1            [24] 4733 	jnz	00104$
                                   4734 ;	fat.h:854: return;
      0015D3                       4735 00110$:
                                   4736 ;	fat.h:856: }
      0015D3 85*00 81         [24] 4737 	mov	sp,_bp
      0015D6 D0*00            [24] 4738 	pop	_bp
      0015D8 22               [24] 4739 	ret
                                   4740 ;------------------------------------------------------------
                                   4741 ;Allocation info for local variables in function 'SL_disable_write_protection'
                                   4742 ;------------------------------------------------------------
                                   4743 ;xram_addr                 Allocated to registers 
                                   4744 ;------------------------------------------------------------
                                   4745 ;	serialloader.h:24: void SL_disable_write_protection()
                                   4746 ;	-----------------------------------------
                                   4747 ;	 function SL_disable_write_protection
                                   4748 ;	-----------------------------------------
      0015D9                       4749 _SL_disable_write_protection:
                                   4750 ;	serialloader.h:29: *(xram_addr) = 0xAA;
      0015D9 90 15 55         [24] 4751 	mov	dptr,#0x1555
      0015DC 74 AA            [12] 4752 	mov	a,#0xaa
      0015DE F0               [24] 4753 	movx	@dptr,a
                                   4754 ;	serialloader.h:31: *(xram_addr) = 0x55;
      0015DF 90 0A AA         [24] 4755 	mov	dptr,#0x0aaa
      0015E2 F4               [12] 4756 	cpl	a
      0015E3 F0               [24] 4757 	movx	@dptr,a
                                   4758 ;	serialloader.h:33: *(xram_addr) = 0x80;
                                   4759 ;	serialloader.h:37: *(xram_addr) = 0xAA;
      0015E4 90 15 55         [24] 4760 	mov	dptr,#0x1555
      0015E7 74 80            [12] 4761 	mov	a,#0x80
      0015E9 F0               [24] 4762 	movx	@dptr,a
      0015EA 74 AA            [12] 4763 	mov	a,#0xaa
      0015EC F0               [24] 4764 	movx	@dptr,a
                                   4765 ;	serialloader.h:39: *(xram_addr) = 0x55;
      0015ED 90 0A AA         [24] 4766 	mov	dptr,#0x0aaa
      0015F0 F4               [12] 4767 	cpl	a
      0015F1 F0               [24] 4768 	movx	@dptr,a
                                   4769 ;	serialloader.h:41: *(xram_addr) = 0x20;
      0015F2 90 15 55         [24] 4770 	mov	dptr,#0x1555
      0015F5 74 20            [12] 4771 	mov	a,#0x20
      0015F7 F0               [24] 4772 	movx	@dptr,a
                                   4773 ;	serialloader.h:43: UartWrite('D'); //ack
      0015F8 75 82 44         [24] 4774 	mov	dpl,#0x44
      0015FB 12r00r95         [24] 4775 	lcall	_UartWrite
                                   4776 ;	serialloader.h:45: EEPROM_WRITE_PROTECTION=0; //change flag
      0015FE 75*23 00         [24] 4777 	mov	_EEPROM_WRITE_PROTECTION,#0x00
                                   4778 ;	serialloader.h:46: }
      001601 22               [24] 4779 	ret
                                   4780 ;------------------------------------------------------------
                                   4781 ;Allocation info for local variables in function 'SL_enable_write_protection'
                                   4782 ;------------------------------------------------------------
                                   4783 ;	serialloader.h:48: void SL_enable_write_protection()
                                   4784 ;	-----------------------------------------
                                   4785 ;	 function SL_enable_write_protection
                                   4786 ;	-----------------------------------------
      001602                       4787 _SL_enable_write_protection:
                                   4788 ;	serialloader.h:50: EEPROM_WRITE_PROTECTION=1; //change flag
      001602 75*23 01         [24] 4789 	mov	_EEPROM_WRITE_PROTECTION,#0x01
                                   4790 ;	serialloader.h:51: UartWrite('E'); 
      001605 75 82 45         [24] 4791 	mov	dpl,#0x45
                                   4792 ;	serialloader.h:52: }
      001608 02r00r95         [24] 4793 	ljmp	_UartWrite
                                   4794 ;------------------------------------------------------------
                                   4795 ;Allocation info for local variables in function 'SL_write'
                                   4796 ;------------------------------------------------------------
                                   4797 ;data                      Allocated to registers r5 
                                   4798 ;addr                      Allocated to registers r7 r6 
                                   4799 ;xram_addr                 Allocated to registers 
                                   4800 ;------------------------------------------------------------
                                   4801 ;	serialloader.h:54: void SL_write()
                                   4802 ;	-----------------------------------------
                                   4803 ;	 function SL_write
                                   4804 ;	-----------------------------------------
      00160B                       4805 _SL_write:
                                   4806 ;	serialloader.h:60: while(UartReadReady()==0); //wait till we rcv data
      00160B                       4807 00101$:
      00160B 12r00r81         [24] 4808 	lcall	_UartReadReady
      00160E E5 82            [12] 4809 	mov	a,dpl
      001610 60 F9            [24] 4810 	jz	00101$
                                   4811 ;	serialloader.h:63: addr = UartRead(); //msb
      001612 12r00r8C         [24] 4812 	lcall	_UartRead
                                   4813 ;	serialloader.h:64: addr = addr << 8;
      001615 AE 82            [24] 4814 	mov	r6,dpl
      001617 7F 00            [12] 4815 	mov	r7,#0x00
                                   4816 ;	serialloader.h:65: addr |= UartRead(); //lsb
      001619 C0 07            [24] 4817 	push	ar7
      00161B C0 06            [24] 4818 	push	ar6
      00161D 12r00r8C         [24] 4819 	lcall	_UartRead
      001620 AD 82            [24] 4820 	mov	r5,dpl
      001622 D0 06            [24] 4821 	pop	ar6
      001624 D0 07            [24] 4822 	pop	ar7
      001626 7C 00            [12] 4823 	mov	r4,#0x00
      001628 ED               [12] 4824 	mov	a,r5
      001629 42 07            [12] 4825 	orl	ar7,a
      00162B EC               [12] 4826 	mov	a,r4
      00162C 42 06            [12] 4827 	orl	ar6,a
                                   4828 ;	serialloader.h:67: data = UartRead(); //read data
      00162E C0 07            [24] 4829 	push	ar7
      001630 C0 06            [24] 4830 	push	ar6
      001632 12r00r8C         [24] 4831 	lcall	_UartRead
      001635 AD 82            [24] 4832 	mov	r5,dpl
      001637 D0 06            [24] 4833 	pop	ar6
      001639 D0 07            [24] 4834 	pop	ar7
                                   4835 ;	serialloader.h:69: if(EEPROM_WRITE_PROTECTION)
      00163B E5*23            [12] 4836 	mov	a,_EEPROM_WRITE_PROTECTION
      00163D 60 11            [24] 4837 	jz	00105$
                                   4838 ;	serialloader.h:73: *(xram_addr) = 0xAA;
      00163F 90 15 55         [24] 4839 	mov	dptr,#0x1555
      001642 74 AA            [12] 4840 	mov	a,#0xaa
      001644 F0               [24] 4841 	movx	@dptr,a
                                   4842 ;	serialloader.h:75: *(xram_addr) = 0x55;
      001645 90 0A AA         [24] 4843 	mov	dptr,#0x0aaa
      001648 F4               [12] 4844 	cpl	a
      001649 F0               [24] 4845 	movx	@dptr,a
                                   4846 ;	serialloader.h:77: *(xram_addr) = 0xA0;
      00164A 90 15 55         [24] 4847 	mov	dptr,#0x1555
      00164D 74 A0            [12] 4848 	mov	a,#0xa0
      00164F F0               [24] 4849 	movx	@dptr,a
      001650                       4850 00105$:
                                   4851 ;	serialloader.h:80: xram_addr = (__xdata unsigned char*) addr;
      001650 8F 82            [24] 4852 	mov	dpl,r7
      001652 8E 83            [24] 4853 	mov	dph,r6
                                   4854 ;	serialloader.h:82: *(xram_addr) = data; //write to xram
      001654 ED               [12] 4855 	mov	a,r5
      001655 F0               [24] 4856 	movx	@dptr,a
                                   4857 ;	serialloader.h:84: UartWrite('W'); //ack
      001656 75 82 57         [24] 4858 	mov	dpl,#0x57
                                   4859 ;	serialloader.h:86: }
      001659 02r00r95         [24] 4860 	ljmp	_UartWrite
                                   4861 ;------------------------------------------------------------
                                   4862 ;Allocation info for local variables in function 'SL_read'
                                   4863 ;------------------------------------------------------------
                                   4864 ;data                      Allocated to registers r7 
                                   4865 ;addr                      Allocated to registers r7 r6 
                                   4866 ;xram_addr                 Allocated to registers 
                                   4867 ;------------------------------------------------------------
                                   4868 ;	serialloader.h:88: void SL_read()
                                   4869 ;	-----------------------------------------
                                   4870 ;	 function SL_read
                                   4871 ;	-----------------------------------------
      00165C                       4872 _SL_read:
                                   4873 ;	serialloader.h:94: while(UartReadReady()==0); //wait till we rcv data
      00165C                       4874 00101$:
      00165C 12r00r81         [24] 4875 	lcall	_UartReadReady
      00165F E5 82            [12] 4876 	mov	a,dpl
      001661 60 F9            [24] 4877 	jz	00101$
                                   4878 ;	serialloader.h:98: addr = UartRead(); //msb
      001663 12r00r8C         [24] 4879 	lcall	_UartRead
                                   4880 ;	serialloader.h:99: addr = addr << 8;
      001666 AE 82            [24] 4881 	mov	r6,dpl
      001668 7F 00            [12] 4882 	mov	r7,#0x00
                                   4883 ;	serialloader.h:100: addr |= UartRead(); //lsb
      00166A C0 07            [24] 4884 	push	ar7
      00166C C0 06            [24] 4885 	push	ar6
      00166E 12r00r8C         [24] 4886 	lcall	_UartRead
      001671 AD 82            [24] 4887 	mov	r5,dpl
      001673 D0 06            [24] 4888 	pop	ar6
      001675 D0 07            [24] 4889 	pop	ar7
      001677 7C 00            [12] 4890 	mov	r4,#0x00
      001679 ED               [12] 4891 	mov	a,r5
      00167A 42 07            [12] 4892 	orl	ar7,a
      00167C EC               [12] 4893 	mov	a,r4
      00167D 42 06            [12] 4894 	orl	ar6,a
                                   4895 ;	serialloader.h:102: xram_addr = (__xdata unsigned char*) addr;
      00167F 8F 82            [24] 4896 	mov	dpl,r7
      001681 8E 83            [24] 4897 	mov	dph,r6
                                   4898 ;	serialloader.h:104: data = *(xram_addr); //read from xram
      001683 E0               [24] 4899 	movx	a,@dptr
                                   4900 ;	serialloader.h:106: UartWrite(data);
      001684 F5 82            [12] 4901 	mov	dpl,a
                                   4902 ;	serialloader.h:108: }
      001686 02r00r95         [24] 4903 	ljmp	_UartWrite
                                   4904 ;------------------------------------------------------------
                                   4905 ;Allocation info for local variables in function 'SL_getcmd'
                                   4906 ;------------------------------------------------------------
                                   4907 ;cmd                       Allocated to registers r7 
                                   4908 ;------------------------------------------------------------
                                   4909 ;	serialloader.h:111: unsigned char SL_getcmd()
                                   4910 ;	-----------------------------------------
                                   4911 ;	 function SL_getcmd
                                   4912 ;	-----------------------------------------
      001689                       4913 _SL_getcmd:
                                   4914 ;	serialloader.h:114: while(UartReadReady()) UartRead(); //flush 
      001689                       4915 00101$:
      001689 12r00r81         [24] 4916 	lcall	_UartReadReady
      00168C E5 82            [12] 4917 	mov	a,dpl
      00168E 60 05            [24] 4918 	jz	00104$
      001690 12r00r8C         [24] 4919 	lcall	_UartRead
                                   4920 ;	serialloader.h:116: while(UartReadReady()==0); //wait till we rcv data 
      001693 80 F4            [24] 4921 	sjmp	00101$
      001695                       4922 00104$:
      001695 12r00r81         [24] 4923 	lcall	_UartReadReady
      001698 E5 82            [12] 4924 	mov	a,dpl
      00169A 60 F9            [24] 4925 	jz	00104$
                                   4926 ;	serialloader.h:119: cmd = UartRead(); //read
      00169C 12r00r8C         [24] 4927 	lcall	_UartRead
      00169F AF 82            [24] 4928 	mov	r7,dpl
                                   4929 ;	serialloader.h:121: switch(cmd)
      0016A1 BF 44 02         [24] 4930 	cjne	r7,#0x44,00159$
      0016A4 80 3A            [24] 4931 	sjmp	00110$
      0016A6                       4932 00159$:
      0016A6 BF 45 02         [24] 4933 	cjne	r7,#0x45,00160$
      0016A9 80 3E            [24] 4934 	sjmp	00111$
      0016AB                       4935 00160$:
      0016AB BF 52 02         [24] 4936 	cjne	r7,#0x52,00161$
      0016AE 80 1E            [24] 4937 	sjmp	00108$
      0016B0                       4938 00161$:
      0016B0 BF 56 02         [24] 4939 	cjne	r7,#0x56,00162$
      0016B3 80 0A            [24] 4940 	sjmp	00107$
      0016B5                       4941 00162$:
      0016B5 BF 57 02         [24] 4942 	cjne	r7,#0x57,00163$
      0016B8 80 1D            [24] 4943 	sjmp	00109$
      0016BA                       4944 00163$:
                                   4945 ;	serialloader.h:123: case 'V':
      0016BA BF 58 38         [24] 4946 	cjne	r7,#0x58,00114$
      0016BD 80 33            [24] 4947 	sjmp	00112$
      0016BF                       4948 00107$:
                                   4949 ;	serialloader.h:124: UartPrint(SERIAL_LOADER_VERSION_INFO);
      0016BF 90r1Ar72         [24] 4950 	mov	dptr,#_SERIAL_LOADER_VERSION_INFO
      0016C2 75 F0 80         [24] 4951 	mov	b,#0x80
      0016C5 C0 07            [24] 4952 	push	ar7
      0016C7 12r01r1B         [24] 4953 	lcall	_UartPrint
      0016CA D0 07            [24] 4954 	pop	ar7
                                   4955 ;	serialloader.h:125: break;
                                   4956 ;	serialloader.h:126: case 'R':
      0016CC 80 27            [24] 4957 	sjmp	00114$
      0016CE                       4958 00108$:
                                   4959 ;	serialloader.h:127: SL_read();
      0016CE C0 07            [24] 4960 	push	ar7
      0016D0 12r16r5C         [24] 4961 	lcall	_SL_read
      0016D3 D0 07            [24] 4962 	pop	ar7
                                   4963 ;	serialloader.h:128: break;
                                   4964 ;	serialloader.h:129: case 'W':
      0016D5 80 1E            [24] 4965 	sjmp	00114$
      0016D7                       4966 00109$:
                                   4967 ;	serialloader.h:130: SL_write();
      0016D7 C0 07            [24] 4968 	push	ar7
      0016D9 12r16r0B         [24] 4969 	lcall	_SL_write
      0016DC D0 07            [24] 4970 	pop	ar7
                                   4971 ;	serialloader.h:131: break;
                                   4972 ;	serialloader.h:132: case 'D':
      0016DE 80 15            [24] 4973 	sjmp	00114$
      0016E0                       4974 00110$:
                                   4975 ;	serialloader.h:133: SL_disable_write_protection();
      0016E0 C0 07            [24] 4976 	push	ar7
      0016E2 12r15rD9         [24] 4977 	lcall	_SL_disable_write_protection
      0016E5 D0 07            [24] 4978 	pop	ar7
                                   4979 ;	serialloader.h:134: break;
                                   4980 ;	serialloader.h:135: case 'E':
      0016E7 80 0C            [24] 4981 	sjmp	00114$
      0016E9                       4982 00111$:
                                   4983 ;	serialloader.h:136: SL_enable_write_protection();
      0016E9 C0 07            [24] 4984 	push	ar7
      0016EB 12r16r02         [24] 4985 	lcall	_SL_enable_write_protection
      0016EE D0 07            [24] 4986 	pop	ar7
                                   4987 ;	serialloader.h:137: break;
                                   4988 ;	serialloader.h:138: case 'X': //execute
      0016F0 80 03            [24] 4989 	sjmp	00114$
      0016F2                       4990 00112$:
                                   4991 ;	serialloader.h:139: SELF_RESET_PORT &= ~(1<<SELF_RESET_PIN);
      0016F2 53 90 EF         [24] 4992 	anl	_P1,#0xef
                                   4993 ;	serialloader.h:143: }
      0016F5                       4994 00114$:
                                   4995 ;	serialloader.h:145: return cmd;
      0016F5 8F 82            [24] 4996 	mov	dpl,r7
                                   4997 ;	serialloader.h:146: }
      0016F7 22               [24] 4998 	ret
                                   4999 ;------------------------------------------------------------
                                   5000 ;Allocation info for local variables in function 'SelectFAT16PartitionPrompt'
                                   5001 ;------------------------------------------------------------
                                   5002 ;_resp                     Allocated to registers r6 
                                   5003 ;_temp                     Allocated to registers r7 
                                   5004 ;i                         Allocated to registers r5 
                                   5005 ;i                         Allocated to registers r4 
                                   5006 ;------------------------------------------------------------
                                   5007 ;	main.c:31: void SelectFAT16PartitionPrompt() __reentrant
                                   5008 ;	-----------------------------------------
                                   5009 ;	 function SelectFAT16PartitionPrompt
                                   5010 ;	-----------------------------------------
      0016F8                       5011 _SelectFAT16PartitionPrompt:
                                   5012 ;	main.c:33: uint8_t _resp=0,_temp=0;
      0016F8 7F 00            [12] 5013 	mov	r7,#0x00
                                   5014 ;	main.c:36: if(MBR_CHECK__SIGNATURE())
      0016FA C0 07            [24] 5015 	push	ar7
      0016FC 12r0BrAE         [24] 5016 	lcall	_MBR_CHECK__SIGNATURE
      0016FF E5 82            [12] 5017 	mov	a,dpl
      001701 D0 07            [24] 5018 	pop	ar7
      001703 60 0D            [24] 5019 	jz	00102$
                                   5020 ;	main.c:39: UartPrint("BAD MBR!\n");
      001705 90r00r56         [24] 5021 	mov	dptr,#___str_9
      001708 75 F0 80         [24] 5022 	mov	b,#0x80
      00170B C0 07            [24] 5023 	push	ar7
      00170D 12r01r1B         [24] 5024 	lcall	_UartPrint
      001710 D0 07            [24] 5025 	pop	ar7
      001712                       5026 00102$:
                                   5027 ;	main.c:43: _resp=MBR_DETECT_FAT16(); 	// _resp now contains the bit set for the partitions which have valid FAT16 ID
      001712 C0 07            [24] 5028 	push	ar7
      001714 12r0Cr8C         [24] 5029 	lcall	_MBR_DETECT_FAT16
      001717 AE 82            [24] 5030 	mov	r6,dpl
      001719 D0 07            [24] 5031 	pop	ar7
                                   5032 ;	main.c:46: if(_resp)
      00171B EE               [12] 5033 	mov	a,r6
      00171C 70 03            [24] 5034 	jnz	00188$
      00171E 02r18r64         [24] 5035 	ljmp	00124$
      001721                       5036 00188$:
                                   5037 ;	main.c:50: for(uint8_t i=0;i<4;i++)
      001721 7D 00            [12] 5038 	mov	r5,#0x00
      001723                       5039 00127$:
      001723 BD 04 00         [24] 5040 	cjne	r5,#0x04,00189$
      001726                       5041 00189$:
      001726 40 03            [24] 5042 	jc	00190$
      001728 02r17rA9         [24] 5043 	ljmp	00106$
      00172B                       5044 00190$:
                                   5045 ;	main.c:52: UartPrint("\nPtn. ");UartWriteNumber(i,HEX);UartWrite('> ');
      00172B C0 07            [24] 5046 	push	ar7
      00172D 90r00r60         [24] 5047 	mov	dptr,#___str_10
      001730 75 F0 80         [24] 5048 	mov	b,#0x80
      001733 C0 07            [24] 5049 	push	ar7
      001735 C0 06            [24] 5050 	push	ar6
      001737 C0 05            [24] 5051 	push	ar5
      001739 12r01r1B         [24] 5052 	lcall	_UartPrint
      00173C D0 05            [24] 5053 	pop	ar5
      00173E C0 05            [24] 5054 	push	ar5
      001740 E4               [12] 5055 	clr	a
      001741 C0 E0            [24] 5056 	push	acc
      001743 8D 82            [24] 5057 	mov	dpl,r5
      001745 12r01r4D         [24] 5058 	lcall	_UartWriteNumber
      001748 15 81            [12] 5059 	dec	sp
      00174A 75 82 3E         [24] 5060 	mov	dpl,#0x3e
      00174D 12r00r95         [24] 5061 	lcall	_UartWrite
      001750 D0 05            [24] 5062 	pop	ar5
      001752 D0 06            [24] 5063 	pop	ar6
      001754 D0 07            [24] 5064 	pop	ar7
                                   5065 ;	main.c:53: if(_resp & 1<<i) UartPrint("FAT16");
      001756 8D F0            [24] 5066 	mov	b,r5
      001758 05 F0            [12] 5067 	inc	b
      00175A 7B 01            [12] 5068 	mov	r3,#0x01
      00175C 7C 00            [12] 5069 	mov	r4,#0x00
      00175E 80 06            [24] 5070 	sjmp	00192$
      001760                       5071 00191$:
      001760 EB               [12] 5072 	mov	a,r3
      001761 2B               [12] 5073 	add	a,r3
      001762 FB               [12] 5074 	mov	r3,a
      001763 EC               [12] 5075 	mov	a,r4
      001764 33               [12] 5076 	rlc	a
      001765 FC               [12] 5077 	mov	r4,a
      001766                       5078 00192$:
      001766 D5 F0 F7         [24] 5079 	djnz	b,00191$
      001769 8E 02            [24] 5080 	mov	ar2,r6
      00176B 7F 00            [12] 5081 	mov	r7,#0x00
      00176D EA               [12] 5082 	mov	a,r2
      00176E 52 03            [12] 5083 	anl	ar3,a
      001770 EF               [12] 5084 	mov	a,r7
      001771 52 04            [12] 5085 	anl	ar4,a
      001773 D0 07            [24] 5086 	pop	ar7
      001775 EB               [12] 5087 	mov	a,r3
      001776 4C               [12] 5088 	orl	a,r4
      001777 60 17            [24] 5089 	jz	00104$
      001779 90r00r67         [24] 5090 	mov	dptr,#___str_11
      00177C 75 F0 80         [24] 5091 	mov	b,#0x80
      00177F C0 07            [24] 5092 	push	ar7
      001781 C0 06            [24] 5093 	push	ar6
      001783 C0 05            [24] 5094 	push	ar5
      001785 12r01r1B         [24] 5095 	lcall	_UartPrint
      001788 D0 05            [24] 5096 	pop	ar5
      00178A D0 06            [24] 5097 	pop	ar6
      00178C D0 07            [24] 5098 	pop	ar7
      00178E 80 15            [24] 5099 	sjmp	00128$
      001790                       5100 00104$:
                                   5101 ;	main.c:54: else UartPrint("Unknown");
      001790 90r00r6D         [24] 5102 	mov	dptr,#___str_12
      001793 75 F0 80         [24] 5103 	mov	b,#0x80
      001796 C0 07            [24] 5104 	push	ar7
      001798 C0 06            [24] 5105 	push	ar6
      00179A C0 05            [24] 5106 	push	ar5
      00179C 12r01r1B         [24] 5107 	lcall	_UartPrint
      00179F D0 05            [24] 5108 	pop	ar5
      0017A1 D0 06            [24] 5109 	pop	ar6
      0017A3 D0 07            [24] 5110 	pop	ar7
      0017A5                       5111 00128$:
                                   5112 ;	main.c:50: for(uint8_t i=0;i<4;i++)
      0017A5 0D               [12] 5113 	inc	r5
      0017A6 02r17r23         [24] 5114 	ljmp	00127$
      0017A9                       5115 00106$:
                                   5116 ;	main.c:60: if( (_resp & (_resp-1)) == 0)
      0017A9 8E 05            [24] 5117 	mov	ar5,r6
      0017AB 7E 00            [12] 5118 	mov	r6,#0x00
      0017AD ED               [12] 5119 	mov	a,r5
      0017AE 24 FF            [12] 5120 	add	a,#0xff
      0017B0 FB               [12] 5121 	mov	r3,a
      0017B1 EE               [12] 5122 	mov	a,r6
      0017B2 34 FF            [12] 5123 	addc	a,#0xff
      0017B4 FC               [12] 5124 	mov	r4,a
      0017B5 ED               [12] 5125 	mov	a,r5
      0017B6 52 03            [12] 5126 	anl	ar3,a
      0017B8 EE               [12] 5127 	mov	a,r6
      0017B9 52 04            [12] 5128 	anl	ar4,a
      0017BB EB               [12] 5129 	mov	a,r3
      0017BC 4C               [12] 5130 	orl	a,r4
                                   5131 ;	main.c:62: for(uint8_t i=0;i<4;i++)
      0017BD 70 31            [24] 5132 	jnz	00111$
      0017BF FC               [12] 5133 	mov	r4,a
      0017C0 FB               [12] 5134 	mov	r3,a
      0017C1                       5135 00130$:
      0017C1 BB 04 00         [24] 5136 	cjne	r3,#0x04,00195$
      0017C4                       5137 00195$:
      0017C4 50 42            [24] 5138 	jnc	00112$
                                   5139 ;	main.c:64: if(_resp & 1<<i) 
      0017C6 C0 04            [24] 5140 	push	ar4
      0017C8 8B F0            [24] 5141 	mov	b,r3
      0017CA 05 F0            [12] 5142 	inc	b
      0017CC 7A 01            [12] 5143 	mov	r2,#0x01
      0017CE 7C 00            [12] 5144 	mov	r4,#0x00
      0017D0 80 06            [24] 5145 	sjmp	00198$
      0017D2                       5146 00197$:
      0017D2 EA               [12] 5147 	mov	a,r2
      0017D3 2A               [12] 5148 	add	a,r2
      0017D4 FA               [12] 5149 	mov	r2,a
      0017D5 EC               [12] 5150 	mov	a,r4
      0017D6 33               [12] 5151 	rlc	a
      0017D7 FC               [12] 5152 	mov	r4,a
      0017D8                       5153 00198$:
      0017D8 D5 F0 F7         [24] 5154 	djnz	b,00197$
      0017DB ED               [12] 5155 	mov	a,r5
      0017DC 52 02            [12] 5156 	anl	ar2,a
      0017DE EE               [12] 5157 	mov	a,r6
      0017DF 52 04            [12] 5158 	anl	ar4,a
      0017E1 EA               [12] 5159 	mov	a,r2
      0017E2 4C               [12] 5160 	orl	a,r4
      0017E3 D0 04            [24] 5161 	pop	ar4
      0017E5 60 04            [24] 5162 	jz	00131$
                                   5163 ;	main.c:66: _temp=i; // select the i-th partition
      0017E7 8C 07            [24] 5164 	mov	ar7,r4
                                   5165 ;	main.c:67: break; //break from for loop
      0017E9 80 1D            [24] 5166 	sjmp	00112$
      0017EB                       5167 00131$:
                                   5168 ;	main.c:62: for(uint8_t i=0;i<4;i++)
      0017EB 0B               [12] 5169 	inc	r3
      0017EC 8B 04            [24] 5170 	mov	ar4,r3
      0017EE 80 D1            [24] 5171 	sjmp	00130$
      0017F0                       5172 00111$:
                                   5173 ;	main.c:74: UartPrint("Slct Ptn. >\n");
      0017F0 90r00r75         [24] 5174 	mov	dptr,#___str_13
      0017F3 75 F0 80         [24] 5175 	mov	b,#0x80
      0017F6 C0 06            [24] 5176 	push	ar6
      0017F8 C0 05            [24] 5177 	push	ar5
      0017FA 12r01r1B         [24] 5178 	lcall	_UartPrint
                                   5179 ;	main.c:75: _temp=UartScanByte();
      0017FD 12r03r5B         [24] 5180 	lcall	_UartScanByte
      001800 AC 82            [24] 5181 	mov	r4,dpl
      001802 D0 05            [24] 5182 	pop	ar5
      001804 D0 06            [24] 5183 	pop	ar6
      001806 8C 07            [24] 5184 	mov	ar7,r4
      001808                       5185 00112$:
                                   5186 ;	main.c:79: if( _temp<4 && (_resp & (1<<_temp)) )
      001808 BF 04 00         [24] 5187 	cjne	r7,#0x04,00200$
      00180B                       5188 00200$:
      00180B 50 43            [24] 5189 	jnc	00117$
      00180D 8F F0            [24] 5190 	mov	b,r7
      00180F 05 F0            [12] 5191 	inc	b
      001811 7B 01            [12] 5192 	mov	r3,#0x01
      001813 7C 00            [12] 5193 	mov	r4,#0x00
      001815 80 06            [24] 5194 	sjmp	00203$
      001817                       5195 00202$:
      001817 EB               [12] 5196 	mov	a,r3
      001818 2B               [12] 5197 	add	a,r3
      001819 FB               [12] 5198 	mov	r3,a
      00181A EC               [12] 5199 	mov	a,r4
      00181B 33               [12] 5200 	rlc	a
      00181C FC               [12] 5201 	mov	r4,a
      00181D                       5202 00203$:
      00181D D5 F0 F7         [24] 5203 	djnz	b,00202$
      001820 EB               [12] 5204 	mov	a,r3
      001821 52 05            [12] 5205 	anl	ar5,a
      001823 EC               [12] 5206 	mov	a,r4
      001824 52 06            [12] 5207 	anl	ar6,a
      001826 ED               [12] 5208 	mov	a,r5
      001827 4E               [12] 5209 	orl	a,r6
      001828 60 26            [24] 5210 	jz	00117$
                                   5211 ;	main.c:81: UartPrint("\n\nPtn. Mounted:");UartWriteNumber(_temp,HEX);
      00182A 90r00r82         [24] 5212 	mov	dptr,#___str_14
      00182D 75 F0 80         [24] 5213 	mov	b,#0x80
      001830 C0 07            [24] 5214 	push	ar7
      001832 12r01r1B         [24] 5215 	lcall	_UartPrint
      001835 D0 07            [24] 5216 	pop	ar7
      001837 C0 07            [24] 5217 	push	ar7
      001839 E4               [12] 5218 	clr	a
      00183A C0 E0            [24] 5219 	push	acc
      00183C 8F 82            [24] 5220 	mov	dpl,r7
      00183E 12r01r4D         [24] 5221 	lcall	_UartWriteNumber
      001841 15 81            [12] 5222 	dec	sp
                                   5223 ;	main.c:82: UartWrite('\n');
      001843 75 82 0A         [24] 5224 	mov	dpl,#0x0a
      001846 12r00r95         [24] 5225 	lcall	_UartWrite
      001849 D0 07            [24] 5226 	pop	ar7
                                   5227 ;	main.c:83: VBR_MOUNT_VBR(_temp);
      00184B 8F 82            [24] 5228 	mov	dpl,r7
      00184D 02r0CrC3         [24] 5229 	ljmp	_VBR_MOUNT_VBR
      001850                       5230 00117$:
                                   5231 ;	main.c:87: UartPrint("\nBad Ptn.\n");
      001850 90r00r92         [24] 5232 	mov	dptr,#___str_15
      001853 75 F0 80         [24] 5233 	mov	b,#0x80
      001856 12r01r1B         [24] 5234 	lcall	_UartPrint
                                   5235 ;	main.c:88: UartPrint(HALTING_MSG); while(1);
      001859 90r1Ar7F         [24] 5236 	mov	dptr,#_SelectFAT16PartitionPrompt_HALTING_MSG_65536_195
      00185C 75 F0 80         [24] 5237 	mov	b,#0x80
      00185F 12r01r1B         [24] 5238 	lcall	_UartPrint
      001862                       5239 00114$:
      001862 80 FE            [24] 5240 	sjmp	00114$
      001864                       5241 00124$:
                                   5242 ;	main.c:94: UartPrint("No FAT16 Ptn.\n");
      001864 90r00r9D         [24] 5243 	mov	dptr,#___str_16
      001867 75 F0 80         [24] 5244 	mov	b,#0x80
      00186A 12r01r1B         [24] 5245 	lcall	_UartPrint
                                   5246 ;	main.c:95: UartPrint(HALTING_MSG); while(1);
      00186D 90r1Ar7F         [24] 5247 	mov	dptr,#_SelectFAT16PartitionPrompt_HALTING_MSG_65536_195
      001870 75 F0 80         [24] 5248 	mov	b,#0x80
      001873 12r01r1B         [24] 5249 	lcall	_UartPrint
      001876                       5250 00121$:
                                   5251 ;	main.c:98: }
      001876 80 FE            [24] 5252 	sjmp	00121$
                                   5253 ;------------------------------------------------------------
                                   5254 ;Allocation info for local variables in function 'SelectFileAndFileOpen'
                                   5255 ;------------------------------------------------------------
                                   5256 ;_result                   Allocated to registers r7 
                                   5257 ;i                         Allocated to registers r7 
                                   5258 ;j                         Allocated to registers r6 
                                   5259 ;------------------------------------------------------------
                                   5260 ;	main.c:100: void SelectFileAndFileOpen() __reentrant
                                   5261 ;	-----------------------------------------
                                   5262 ;	 function SelectFileAndFileOpen
                                   5263 ;	-----------------------------------------
      001878                       5264 _SelectFileAndFileOpen:
                                   5265 ;	main.c:103: FAT16_ROOTENTRY_SCAN_RESET();
      001878 12r11r5A         [24] 5266 	lcall	_FAT16_ROOTENTRY_SCAN_RESET
                                   5267 ;	main.c:104: UartPrint("\nINDEX\t\tFILE\n");
      00187B 90r00rAC         [24] 5268 	mov	dptr,#___str_17
      00187E 75 F0 80         [24] 5269 	mov	b,#0x80
      001881 12r01r1B         [24] 5270 	lcall	_UartPrint
                                   5271 ;	main.c:107: for(uint8_t i=0;i<255;i++) 
      001884 7F 00            [12] 5272 	mov	r7,#0x00
      001886                       5273 00112$:
      001886 BF FF 00         [24] 5274 	cjne	r7,#0xff,00148$
      001889                       5275 00148$:
      001889 50 58            [24] 5276 	jnc	00107$
                                   5277 ;	main.c:109: _result = FAT16_ROOTENTRY_SCAN();
      00188B C0 07            [24] 5278 	push	ar7
      00188D 12r11r6C         [24] 5279 	lcall	_FAT16_ROOTENTRY_SCAN
      001890 AE 82            [24] 5280 	mov	r6,dpl
      001892 D0 07            [24] 5281 	pop	ar7
                                   5282 ;	main.c:110: if(_result==0xff) break; //end of scan
      001894 BE FF 02         [24] 5283 	cjne	r6,#0xff,00150$
      001897 80 4A            [24] 5284 	sjmp	00107$
      001899                       5285 00150$:
                                   5286 ;	main.c:111: else if (_result==0) //valid file
      001899 EE               [12] 5287 	mov	a,r6
      00189A 70 44            [24] 5288 	jnz	00113$
                                   5289 ;	main.c:113: UartWriteNumber(__global_rootEntry.entry_index,DEC); //print root entry index
      00189C 78r3B            [12] 5290 	mov	r0,#(___global_rootEntry + 0x0012)
      00189E 86 06            [24] 5291 	mov	ar6,@r0
      0018A0 C0 07            [24] 5292 	push	ar7
      0018A2 74 01            [12] 5293 	mov	a,#0x01
      0018A4 C0 E0            [24] 5294 	push	acc
      0018A6 8E 82            [24] 5295 	mov	dpl,r6
      0018A8 12r01r4D         [24] 5296 	lcall	_UartWriteNumber
      0018AB 15 81            [12] 5297 	dec	sp
                                   5298 ;	main.c:114: UartWrite('\t');
      0018AD 75 82 09         [24] 5299 	mov	dpl,#0x09
      0018B0 12r00r95         [24] 5300 	lcall	_UartWrite
                                   5301 ;	main.c:115: UartWrite('\t');
      0018B3 75 82 09         [24] 5302 	mov	dpl,#0x09
      0018B6 12r00r95         [24] 5303 	lcall	_UartWrite
      0018B9 D0 07            [24] 5304 	pop	ar7
                                   5305 ;	main.c:116: for(uint8_t j=0;j<11;j++)UartWrite(__global_rootEntry.name[j]); //print name
      0018BB 7E 00            [12] 5306 	mov	r6,#0x00
      0018BD                       5307 00109$:
      0018BD BE 0B 00         [24] 5308 	cjne	r6,#0x0b,00152$
      0018C0                       5309 00152$:
      0018C0 50 14            [24] 5310 	jnc	00101$
      0018C2 EE               [12] 5311 	mov	a,r6
      0018C3 24r29            [12] 5312 	add	a,#___global_rootEntry
      0018C5 F9               [12] 5313 	mov	r1,a
      0018C6 87 82            [24] 5314 	mov	dpl,@r1
      0018C8 C0 07            [24] 5315 	push	ar7
      0018CA C0 06            [24] 5316 	push	ar6
      0018CC 12r00r95         [24] 5317 	lcall	_UartWrite
      0018CF D0 06            [24] 5318 	pop	ar6
      0018D1 D0 07            [24] 5319 	pop	ar7
      0018D3 0E               [12] 5320 	inc	r6
      0018D4 80 E7            [24] 5321 	sjmp	00109$
      0018D6                       5322 00101$:
                                   5323 ;	main.c:117: UartWrite('\n');
      0018D6 75 82 0A         [24] 5324 	mov	dpl,#0x0a
      0018D9 C0 07            [24] 5325 	push	ar7
      0018DB 12r00r95         [24] 5326 	lcall	_UartWrite
      0018DE D0 07            [24] 5327 	pop	ar7
      0018E0                       5328 00113$:
                                   5329 ;	main.c:107: for(uint8_t i=0;i<255;i++) 
      0018E0 0F               [12] 5330 	inc	r7
      0018E1 80 A3            [24] 5331 	sjmp	00112$
      0018E3                       5332 00107$:
                                   5333 ;	main.c:121: UartPrint("\nSlct index >\n");
      0018E3 90r00rBA         [24] 5334 	mov	dptr,#___str_18
      0018E6 75 F0 80         [24] 5335 	mov	b,#0x80
      0018E9 12r01r1B         [24] 5336 	lcall	_UartPrint
                                   5337 ;	main.c:122: _result=UartScanByte();
      0018EC 12r03r5B         [24] 5338 	lcall	_UartScanByte
                                   5339 ;	main.c:123: FAT16_ROOTENTRY_READ(_result); //load the selected
      0018EF 7E 00            [12] 5340 	mov	r6,#0x00
      0018F1 8E 83            [24] 5341 	mov	dph,r6
                                   5342 ;	main.c:124: }
      0018F3 02r11r39         [24] 5343 	ljmp	_FAT16_ROOTENTRY_READ
                                   5344 ;------------------------------------------------------------
                                   5345 ;Allocation info for local variables in function 'main'
                                   5346 ;------------------------------------------------------------
                                   5347 ;buff                      Allocated with name '_main_buff_65536_214'
                                   5348 ;_resp                     Allocated to registers r7 
                                   5349 ;xram_addr                 Allocated to registers r6 r7 
                                   5350 ;_t                        Allocated to registers r5 r6 
                                   5351 ;wastetime                 Allocated to registers r4 
                                   5352 ;i                         Allocated to registers r5 
                                   5353 ;i                         Allocated to registers r5 
                                   5354 ;------------------------------------------------------------
                                   5355 ;	main.c:135: void main(void)
                                   5356 ;	-----------------------------------------
                                   5357 ;	 function main
                                   5358 ;	-----------------------------------------
      0018F6                       5359 _main:
                                   5360 ;	main.c:144: uint8_t _resp=0;
      0018F6 7F 00            [12] 5361 	mov	r7,#0x00
                                   5362 ;	main.c:151: UartBegin();
      0018F8 C0 07            [24] 5363 	push	ar7
      0018FA 12r00r72         [24] 5364 	lcall	_UartBegin
                                   5365 ;	main.c:152: spi_init(); 
      0018FD 12r04r21         [24] 5366 	lcall	_spi_init
                                   5367 ;	main.c:153: SDinit();
      001900 12r06r5A         [24] 5368 	lcall	_SDinit
                                   5369 ;	main.c:157: UartPrint("\nSYAMPUTER:V0\n");
      001903 90r00rC9         [24] 5370 	mov	dptr,#___str_19
      001906 75 F0 80         [24] 5371 	mov	b,#0x80
      001909 12r01r1B         [24] 5372 	lcall	_UartPrint
      00190C D0 07            [24] 5373 	pop	ar7
                                   5374 ;	main.c:159: while(UartReadReady())UartRead(); //flush
      00190E                       5375 00101$:
      00190E C0 07            [24] 5376 	push	ar7
      001910 12r00r81         [24] 5377 	lcall	_UartReadReady
      001913 E5 82            [12] 5378 	mov	a,dpl
      001915 D0 07            [24] 5379 	pop	ar7
      001917 60 09            [24] 5380 	jz	00154$
      001919 C0 07            [24] 5381 	push	ar7
      00191B 12r00r8C         [24] 5382 	lcall	_UartRead
      00191E D0 07            [24] 5383 	pop	ar7
                                   5384 ;	main.c:164: for(unsigned int _t=0;_t<65000;_t++)
      001920 80 EC            [24] 5385 	sjmp	00101$
      001922                       5386 00154$:
      001922 7D 00            [12] 5387 	mov	r5,#0x00
      001924 7E 00            [12] 5388 	mov	r6,#0x00
      001926                       5389 00138$:
      001926 C3               [12] 5390 	clr	c
      001927 ED               [12] 5391 	mov	a,r5
      001928 94 E8            [12] 5392 	subb	a,#0xe8
      00192A EE               [12] 5393 	mov	a,r6
      00192B 94 FD            [12] 5394 	subb	a,#0xfd
      00192D 50 2B            [24] 5395 	jnc	00107$
                                   5396 ;	main.c:166: if(UartReadReady())
      00192F C0 07            [24] 5397 	push	ar7
      001931 C0 06            [24] 5398 	push	ar6
      001933 C0 05            [24] 5399 	push	ar5
      001935 12r00r81         [24] 5400 	lcall	_UartReadReady
      001938 E5 82            [12] 5401 	mov	a,dpl
      00193A D0 05            [24] 5402 	pop	ar5
      00193C D0 06            [24] 5403 	pop	ar6
      00193E D0 07            [24] 5404 	pop	ar7
      001940 60 07            [24] 5405 	jz	00153$
                                   5406 ;	main.c:168: _resp=UartRead();
      001942 12r00r8C         [24] 5407 	lcall	_UartRead
      001945 AF 82            [24] 5408 	mov	r7,dpl
                                   5409 ;	main.c:169: break;
                                   5410 ;	main.c:171: for(uint8_t wastetime=0;wastetime<3;wastetime++);
      001947 80 11            [24] 5411 	sjmp	00107$
      001949                       5412 00153$:
      001949 7C 00            [12] 5413 	mov	r4,#0x00
      00194B                       5414 00135$:
      00194B BC 03 00         [24] 5415 	cjne	r4,#0x03,00233$
      00194E                       5416 00233$:
      00194E 50 03            [24] 5417 	jnc	00139$
      001950 0C               [12] 5418 	inc	r4
      001951 80 F8            [24] 5419 	sjmp	00135$
      001953                       5420 00139$:
                                   5421 ;	main.c:164: for(unsigned int _t=0;_t<65000;_t++)
      001953 0D               [12] 5422 	inc	r5
      001954 BD 00 CF         [24] 5423 	cjne	r5,#0x00,00138$
      001957 0E               [12] 5424 	inc	r6
      001958 80 CC            [24] 5425 	sjmp	00138$
      00195A                       5426 00107$:
                                   5427 ;	main.c:176: switch (_resp)
      00195A BF 56 10         [24] 5428 	cjne	r7,#0x56,00113$
                                   5429 ;	main.c:179: UartPrint("ISA:FS0:8052\n");
      00195D 90r00rD8         [24] 5430 	mov	dptr,#___str_20
      001960 75 F0 80         [24] 5431 	mov	b,#0x80
      001963 12r01r1B         [24] 5432 	lcall	_UartPrint
                                   5433 ;	main.c:180: while(SL_getcmd()); //break when command is 0
      001966                       5434 00109$:
      001966 12r16r89         [24] 5435 	lcall	_SL_getcmd
      001969 E5 82            [12] 5436 	mov	a,dpl
      00196B 70 F9            [24] 5437 	jnz	00109$
                                   5438 ;	main.c:184: }
      00196D                       5439 00113$:
                                   5440 ;	main.c:189: SelectFAT16PartitionPrompt();
      00196D 12r16rF8         [24] 5441 	lcall	_SelectFAT16PartitionPrompt
                                   5442 ;	main.c:196: if(FAT16_FILE_OPEN(DEFAULT_LOAD_FILENAME)==0)
      001970 90r00rE6         [24] 5443 	mov	dptr,#___str_21
      001973 75 F0 80         [24] 5444 	mov	b,#0x80
      001976 12r11r8F         [24] 5445 	lcall	_FAT16_FILE_OPEN
      001979 E5 82            [12] 5446 	mov	a,dpl
      00197B 70 11            [24] 5447 	jnz	00115$
                                   5448 ;	main.c:198: UartPrint(DEFAULT_LOAD_FILENAME);
      00197D 90r00rE6         [24] 5449 	mov	dptr,#___str_21
      001980 75 F0 80         [24] 5450 	mov	b,#0x80
      001983 12r01r1B         [24] 5451 	lcall	_UartPrint
                                   5452 ;	main.c:199: UartWrite('\n');
      001986 75 82 0A         [24] 5453 	mov	dpl,#0x0a
      001989 12r00r95         [24] 5454 	lcall	_UartWrite
      00198C 80 03            [24] 5455 	sjmp	00165$
      00198E                       5456 00115$:
                                   5457 ;	main.c:201: else SelectFileAndFileOpen();
      00198E 12r18r78         [24] 5458 	lcall	_SelectFileAndFileOpen
                                   5459 ;	main.c:203: while(1)
      001991                       5460 00165$:
      001991                       5461 00129$:
                                   5462 ;	main.c:205: xram_addr=(__xdata unsigned char*)(uint16_t)__global_rootEntry.bytes_read;        
      001991 78r3D            [12] 5463 	mov	r0,#(___global_rootEntry + 0x0014)
      001993 86 06            [24] 5464 	mov	ar6,@r0
      001995 08               [12] 5465 	inc	r0
      001996 86 07            [24] 5466 	mov	ar7,@r0
                                   5467 ;	main.c:206: _resp=FAT16_FILE_READ(FILE_BUFF_SIZE,buff);
      001998 C0 07            [24] 5468 	push	ar7
      00199A C0 06            [24] 5469 	push	ar6
      00199C 74r24            [12] 5470 	mov	a,#_main_buff_65536_214
      00199E C0 E0            [24] 5471 	push	acc
      0019A0 74s00            [12] 5472 	mov	a,#(_main_buff_65536_214 >> 8)
      0019A2 C0 E0            [24] 5473 	push	acc
      0019A4 74 40            [12] 5474 	mov	a,#0x40
      0019A6 C0 E0            [24] 5475 	push	acc
      0019A8 75 82 10         [24] 5476 	mov	dpl,#0x10
      0019AB 12r13r0C         [24] 5477 	lcall	_FAT16_FILE_READ
      0019AE AD 82            [24] 5478 	mov	r5,dpl
      0019B0 15 81            [12] 5479 	dec	sp
      0019B2 15 81            [12] 5480 	dec	sp
      0019B4 15 81            [12] 5481 	dec	sp
      0019B6 D0 06            [24] 5482 	pop	ar6
      0019B8 D0 07            [24] 5483 	pop	ar7
                                   5484 ;	main.c:207: if(_resp==0) 
      0019BA ED               [12] 5485 	mov	a,r5
      0019BB 70 0C            [24] 5486 	jnz	00160$
                                   5487 ;	main.c:209: UartPrint("\n<RUN>\n");
      0019BD 90r00rED         [24] 5488 	mov	dptr,#___str_22
      0019C0 75 F0 80         [24] 5489 	mov	b,#0x80
      0019C3 12r01r1B         [24] 5490 	lcall	_UartPrint
                                   5491 ;	main.c:210: break;
      0019C6 02r1Ar52         [24] 5492 	ljmp	00130$
                                   5493 ;	main.c:212: for(uint8_t i=0;i<FILE_BUFF_SIZE;i++)
      0019C9                       5494 00160$:
      0019C9 7D 00            [12] 5495 	mov	r5,#0x00
      0019CB                       5496 00141$:
      0019CB BD 10 00         [24] 5497 	cjne	r5,#0x10,00241$
      0019CE                       5498 00241$:
      0019CE 50 12            [24] 5499 	jnc	00119$
                                   5500 ;	main.c:218: *(xram_addr+i) = buff[i];
      0019D0 ED               [12] 5501 	mov	a,r5
      0019D1 2E               [12] 5502 	add	a,r6
      0019D2 F5 82            [12] 5503 	mov	dpl,a
      0019D4 E4               [12] 5504 	clr	a
      0019D5 3F               [12] 5505 	addc	a,r7
      0019D6 F5 83            [12] 5506 	mov	dph,a
      0019D8 ED               [12] 5507 	mov	a,r5
      0019D9 24r24            [12] 5508 	add	a,#_main_buff_65536_214
      0019DB F9               [12] 5509 	mov	r1,a
      0019DC E7               [12] 5510 	mov	a,@r1
      0019DD FC               [12] 5511 	mov	r4,a
      0019DE F0               [24] 5512 	movx	@dptr,a
                                   5513 ;	main.c:212: for(uint8_t i=0;i<FILE_BUFF_SIZE;i++)
      0019DF 0D               [12] 5514 	inc	r5
      0019E0 80 E9            [24] 5515 	sjmp	00141$
      0019E2                       5516 00119$:
                                   5517 ;	main.c:222: for(uint8_t i=0;i<FILE_BUFF_SIZE;i++)
      0019E2 7D 00            [12] 5518 	mov	r5,#0x00
      0019E4                       5519 00144$:
      0019E4 BD 10 00         [24] 5520 	cjne	r5,#0x10,00243$
      0019E7                       5521 00243$:
      0019E7 50 24            [24] 5522 	jnc	00125$
                                   5523 ;	main.c:224: if(buff[i]!=*(xram_addr+i)) 
      0019E9 ED               [12] 5524 	mov	a,r5
      0019EA 24r24            [12] 5525 	add	a,#_main_buff_65536_214
      0019EC F9               [12] 5526 	mov	r1,a
      0019ED 87 04            [24] 5527 	mov	ar4,@r1
      0019EF ED               [12] 5528 	mov	a,r5
      0019F0 2E               [12] 5529 	add	a,r6
      0019F1 F5 82            [12] 5530 	mov	dpl,a
      0019F3 E4               [12] 5531 	clr	a
      0019F4 3F               [12] 5532 	addc	a,r7
      0019F5 F5 83            [12] 5533 	mov	dph,a
      0019F7 E0               [24] 5534 	movx	a,@dptr
      0019F8 FB               [12] 5535 	mov	r3,a
      0019F9 EC               [12] 5536 	mov	a,r4
      0019FA B5 03 02         [24] 5537 	cjne	a,ar3,00245$
      0019FD 80 0B            [24] 5538 	sjmp	00145$
      0019FF                       5539 00245$:
                                   5540 ;	main.c:226: UartPrint("\nVerif. fail");
      0019FF 90r00rF5         [24] 5541 	mov	dptr,#___str_23
      001A02 75 F0 80         [24] 5542 	mov	b,#0x80
      001A05 12r01r1B         [24] 5543 	lcall	_UartPrint
                                   5544 ;	main.c:228: while(1);
      001A08                       5545 00121$:
      001A08 80 FE            [24] 5546 	sjmp	00121$
      001A0A                       5547 00145$:
                                   5548 ;	main.c:222: for(uint8_t i=0;i<FILE_BUFF_SIZE;i++)
      001A0A 0D               [12] 5549 	inc	r5
      001A0B 80 D7            [24] 5550 	sjmp	00144$
      001A0D                       5551 00125$:
                                   5552 ;	main.c:234: if(__global_rootEntry.bytes_read % 64 == 0)
      001A0D 78r3D            [12] 5553 	mov	r0,#(___global_rootEntry + 0x0014)
      001A0F 86 04            [24] 5554 	mov	ar4,@r0
      001A11 08               [12] 5555 	inc	r0
      001A12 86 05            [24] 5556 	mov	ar5,@r0
      001A14 08               [12] 5557 	inc	r0
      001A15 86 06            [24] 5558 	mov	ar6,@r0
      001A17 08               [12] 5559 	inc	r0
      001A18 86 07            [24] 5560 	mov	ar7,@r0
      001A1A EC               [12] 5561 	mov	a,r4
      001A1B 54 3F            [12] 5562 	anl	a,#0x3f
      001A1D 60 03            [24] 5563 	jz	00247$
      001A1F 02r19r91         [24] 5564 	ljmp	00129$
      001A22                       5565 00247$:
                                   5566 ;	main.c:237: UartPrintNumber(__global_rootEntry.bytes_read);
      001A22 8C 82            [24] 5567 	mov	dpl,r4
      001A24 8D 83            [24] 5568 	mov	dph,r5
      001A26 8E F0            [24] 5569 	mov	b,r6
      001A28 EF               [12] 5570 	mov	a,r7
      001A29 12r02r61         [24] 5571 	lcall	_UartPrintNumber
                                   5572 ;	main.c:238: UartWrite('/');
      001A2C 75 82 2F         [24] 5573 	mov	dpl,#0x2f
      001A2F 12r00r95         [24] 5574 	lcall	_UartWrite
                                   5575 ;	main.c:239: UartPrintNumber(__global_rootEntry.size);
      001A32 78r37            [12] 5576 	mov	r0,#(___global_rootEntry + 0x000e)
      001A34 86 04            [24] 5577 	mov	ar4,@r0
      001A36 08               [12] 5578 	inc	r0
      001A37 86 05            [24] 5579 	mov	ar5,@r0
      001A39 08               [12] 5580 	inc	r0
      001A3A 86 06            [24] 5581 	mov	ar6,@r0
      001A3C 08               [12] 5582 	inc	r0
      001A3D 86 07            [24] 5583 	mov	ar7,@r0
      001A3F 8C 82            [24] 5584 	mov	dpl,r4
      001A41 8D 83            [24] 5585 	mov	dph,r5
      001A43 8E F0            [24] 5586 	mov	b,r6
      001A45 EF               [12] 5587 	mov	a,r7
      001A46 12r02r61         [24] 5588 	lcall	_UartPrintNumber
                                   5589 ;	main.c:240: UartWrite('\r');
      001A49 75 82 0D         [24] 5590 	mov	dpl,#0x0d
      001A4C 12r00r95         [24] 5591 	lcall	_UartWrite
      001A4F 02r19r91         [24] 5592 	ljmp	00129$
      001A52                       5593 00130$:
                                   5594 ;	main.c:245: SELF_RESET_PORT &= ~(1<<SELF_RESET_PIN);
      001A52 53 90 EF         [24] 5595 	anl	_P1,#0xef
                                   5596 ;	main.c:248: while(1);    
      001A55                       5597 00132$:
                                   5598 ;	main.c:250: }
      001A55 80 FE            [24] 5599 	sjmp	00132$
                                   5600 	.area CSEG    (CODE)
                                   5601 	.area CONST   (CODE)
                                   5602 	.area CONST   (CODE)
      000000                       5603 ___str_0:
      000000 4E 75 6D 62 65 72 28  5604 	.ascii "Number(hex) < "
             68 65 78 29 20 3C 20
      00000E 00                    5605 	.db 0x00
                                   5606 	.area CSEG    (CODE)
                                   5607 	.area CONST   (CODE)
      00000F                       5608 ___str_1:
      00000F 0A                    5609 	.db 0x0a
      000010 52 4F 4F 54 5F 45 4E  5610 	.ascii "ROOT_ENTRY_INDEX:"
             54 52 59 5F 49 4E 44
             45 58 3A
      000021 00                    5611 	.db 0x00
                                   5612 	.area CSEG    (CODE)
                                   5613 	.area CONST   (CODE)
      000022                       5614 ___str_2:
      000022 0A                    5615 	.db 0x0a
      000023 46 49 4C 45 3A 20     5616 	.ascii "FILE: "
      000029 00                    5617 	.db 0x00
                                   5618 	.area CSEG    (CODE)
                                   5619 	.area CONST   (CODE)
      00002A                       5620 ___str_3:
      00002A 0A                    5621 	.db 0x0a
      00002B 53 54 41 52 54 3A 20  5622 	.ascii "START: "
      000032 00                    5623 	.db 0x00
                                   5624 	.area CSEG    (CODE)
                                   5625 	.area CONST   (CODE)
      000033                       5626 ___str_4:
      000033 0A                    5627 	.db 0x0a
      000034 53 49 5A 45 3A 20     5628 	.ascii "SIZE: "
      00003A 00                    5629 	.db 0x00
                                   5630 	.area CSEG    (CODE)
                                   5631 	.area CONST   (CODE)
      00003B                       5632 ___str_5:
      00003B 0A                    5633 	.db 0x0a
      00003C 41 54 54 52 3A 20 30  5634 	.ascii "ATTR: 0x"
             78
      000044 00                    5635 	.db 0x00
                                   5636 	.area CSEG    (CODE)
      001A57                       5637 _FAT16_FILE_READ_power2error_65536_176:
      001A57 6E 62 79 74 65 73 20  5638 	.ascii "nbytes must be power of 2"
             6D 75 73 74 20 62 65
             20 70 6F 77 65 72 20
             6F 66 20 32
      001A70 0A                    5639 	.db 0x0a
      001A71 00                    5640 	.db 0x00
                                   5641 	.area CONST   (CODE)
      000045                       5642 ___str_7:
      000045 46 49 4C 45 20 4E 4F  5643 	.ascii "FILE NOT FOUND"
             54 20 46 4F 55 4E 44
      000053 0A                    5644 	.db 0x0a
      000054 2E                    5645 	.ascii "."
      000055 00                    5646 	.db 0x00
                                   5647 	.area CSEG    (CODE)
      001A72                       5648 _SERIAL_LOADER_VERSION_INFO:
      001A72 49 53 41 3A 53 30 3A  5649 	.ascii "ISA:S0:8052"
             38 30 35 32
      001A7D 0A                    5650 	.db 0x0a
      001A7E 00                    5651 	.db 0x00
      001A7F                       5652 _SelectFAT16PartitionPrompt_HALTING_MSG_65536_195:
      001A7F 48 41 4C 54 21        5653 	.ascii "HALT!"
      001A84 00                    5654 	.db 0x00
                                   5655 	.area CONST   (CODE)
      000056                       5656 ___str_9:
      000056 42 41 44 20 4D 42 52  5657 	.ascii "BAD MBR!"
             21
      00005E 0A                    5658 	.db 0x0a
      00005F 00                    5659 	.db 0x00
                                   5660 	.area CSEG    (CODE)
                                   5661 	.area CONST   (CODE)
      000060                       5662 ___str_10:
      000060 0A                    5663 	.db 0x0a
      000061 50 74 6E 2E 20        5664 	.ascii "Ptn. "
      000066 00                    5665 	.db 0x00
                                   5666 	.area CSEG    (CODE)
                                   5667 	.area CONST   (CODE)
      000067                       5668 ___str_11:
      000067 46 41 54 31 36        5669 	.ascii "FAT16"
      00006C 00                    5670 	.db 0x00
                                   5671 	.area CSEG    (CODE)
                                   5672 	.area CONST   (CODE)
      00006D                       5673 ___str_12:
      00006D 55 6E 6B 6E 6F 77 6E  5674 	.ascii "Unknown"
      000074 00                    5675 	.db 0x00
                                   5676 	.area CSEG    (CODE)
                                   5677 	.area CONST   (CODE)
      000075                       5678 ___str_13:
      000075 53 6C 63 74 20 50 74  5679 	.ascii "Slct Ptn. >"
             6E 2E 20 3E
      000080 0A                    5680 	.db 0x0a
      000081 00                    5681 	.db 0x00
                                   5682 	.area CSEG    (CODE)
                                   5683 	.area CONST   (CODE)
      000082                       5684 ___str_14:
      000082 0A                    5685 	.db 0x0a
      000083 0A                    5686 	.db 0x0a
      000084 50 74 6E 2E 20 4D 6F  5687 	.ascii "Ptn. Mounted:"
             75 6E 74 65 64 3A
      000091 00                    5688 	.db 0x00
                                   5689 	.area CSEG    (CODE)
                                   5690 	.area CONST   (CODE)
      000092                       5691 ___str_15:
      000092 0A                    5692 	.db 0x0a
      000093 42 61 64 20 50 74 6E  5693 	.ascii "Bad Ptn."
             2E
      00009B 0A                    5694 	.db 0x0a
      00009C 00                    5695 	.db 0x00
                                   5696 	.area CSEG    (CODE)
                                   5697 	.area CONST   (CODE)
      00009D                       5698 ___str_16:
      00009D 4E 6F 20 46 41 54 31  5699 	.ascii "No FAT16 Ptn."
             36 20 50 74 6E 2E
      0000AA 0A                    5700 	.db 0x0a
      0000AB 00                    5701 	.db 0x00
                                   5702 	.area CSEG    (CODE)
                                   5703 	.area CONST   (CODE)
      0000AC                       5704 ___str_17:
      0000AC 0A                    5705 	.db 0x0a
      0000AD 49 4E 44 45 58        5706 	.ascii "INDEX"
      0000B2 09                    5707 	.db 0x09
      0000B3 09                    5708 	.db 0x09
      0000B4 46 49 4C 45           5709 	.ascii "FILE"
      0000B8 0A                    5710 	.db 0x0a
      0000B9 00                    5711 	.db 0x00
                                   5712 	.area CSEG    (CODE)
                                   5713 	.area CONST   (CODE)
      0000BA                       5714 ___str_18:
      0000BA 0A                    5715 	.db 0x0a
      0000BB 53 6C 63 74 20 69 6E  5716 	.ascii "Slct index >"
             64 65 78 20 3E
      0000C7 0A                    5717 	.db 0x0a
      0000C8 00                    5718 	.db 0x00
                                   5719 	.area CSEG    (CODE)
                                   5720 	.area CONST   (CODE)
      0000C9                       5721 ___str_19:
      0000C9 0A                    5722 	.db 0x0a
      0000CA 53 59 41 4D 50 55 54  5723 	.ascii "SYAMPUTER:V0"
             45 52 3A 56 30
      0000D6 0A                    5724 	.db 0x0a
      0000D7 00                    5725 	.db 0x00
                                   5726 	.area CSEG    (CODE)
                                   5727 	.area CONST   (CODE)
      0000D8                       5728 ___str_20:
      0000D8 49 53 41 3A 46 53 30  5729 	.ascii "ISA:FS0:8052"
             3A 38 30 35 32
      0000E4 0A                    5730 	.db 0x0a
      0000E5 00                    5731 	.db 0x00
                                   5732 	.area CSEG    (CODE)
                                   5733 	.area CONST   (CODE)
      0000E6                       5734 ___str_21:
      0000E6 46 57 2E 42 49 4E     5735 	.ascii "FW.BIN"
      0000EC 00                    5736 	.db 0x00
                                   5737 	.area CSEG    (CODE)
                                   5738 	.area CONST   (CODE)
      0000ED                       5739 ___str_22:
      0000ED 0A                    5740 	.db 0x0a
      0000EE 3C 52 55 4E 3E        5741 	.ascii "<RUN>"
      0000F3 0A                    5742 	.db 0x0a
      0000F4 00                    5743 	.db 0x00
                                   5744 	.area CSEG    (CODE)
                                   5745 	.area CONST   (CODE)
      0000F5                       5746 ___str_23:
      0000F5 0A                    5747 	.db 0x0a
      0000F6 56 65 72 69 66 2E 20  5748 	.ascii "Verif. fail"
             66 61 69 6C
      000101 00                    5749 	.db 0x00
                                   5750 	.area CSEG    (CODE)
                                   5751 	.area XINIT   (CODE)
                                   5752 	.area CABS    (ABS,CODE)
