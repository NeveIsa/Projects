                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.9.0 #11195 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _HELPER_strncmp_PARM_3
                                     12 	.globl _HELPER_strncmp_PARM_2
                                     13 	.globl _HELPER_strcmp_PARM_2
                                     14 	.globl _spi_transfer_PARM_2
                                     15 	.globl _main
                                     16 	.globl _setup
                                     17 	.globl _SelectFileAndFileOpen
                                     18 	.globl _SelectFAT16PartitionPrompt
                                     19 	.globl _delay
                                     20 	.globl _SL_getcmd
                                     21 	.globl _SL_read
                                     22 	.globl _SL_write
                                     23 	.globl _SL_enable_write_protection
                                     24 	.globl _SL_disable_write_protection
                                     25 	.globl _delay_ms
                                     26 	.globl _FAT16_FILE_CAT
                                     27 	.globl _FAT16_FILE_READ
                                     28 	.globl _FAT16_GET_NEXT_CLUSTER
                                     29 	.globl _FAT16_FILE_OPEN
                                     30 	.globl _FAT16_ROOTENTRY_SCAN
                                     31 	.globl _FAT16_ROOTENTRY_SCAN_RESET
                                     32 	.globl _FAT16_ROOTENTRY_READ
                                     33 	.globl _FAT16_IS_ROOTENTRY_VALID_FILE
                                     34 	.globl _FAT16_LOAD_ROOTENTRY
                                     35 	.globl _FAT16_ROOTENTRY_DUMP
                                     36 	.globl _VBR_FAT16_CHECK_COMPATIBILITY
                                     37 	.globl _VBR_MOUNT_VBR
                                     38 	.globl _VBR_DUMP
                                     39 	.globl _MBR_DETECT_FAT16
                                     40 	.globl _MBR_LOAD_PARTITION_TABLE_ENTRY
                                     41 	.globl _MBR_CHECK__SIGNATURE
                                     42 	.globl _HELPER_filename_to_8dot3filename
                                     43 	.globl _HELPER_to_uppercase
                                     44 	.globl _HELPER_rootentry_type
                                     45 	.globl _HELPER_strlen
                                     46 	.globl _HELPER_strncmp
                                     47 	.globl _HELPER_strcmp
                                     48 	.globl _HELPER_load_littleendian32
                                     49 	.globl _HELPER_load_littleendian16
                                     50 	.globl _SDreadBlock
                                     51 	.globl _SDread
                                     52 	.globl _SDinit
                                     53 	.globl _sd_acmd
                                     54 	.globl _sd_cmd
                                     55 	.globl _sd_initial_clk
                                     56 	.globl _sd_isbusy
                                     57 	.globl _spi_transfer_all
                                     58 	.globl _spi_transfer
                                     59 	.globl _spi_init
                                     60 	.globl _spi_delay
                                     61 	.globl _UartScanLine
                                     62 	.globl _UartScanByte
                                     63 	.globl _UartPrintNumber
                                     64 	.globl _UartWriteNumbers
                                     65 	.globl _UartWriteNumber
                                     66 	.globl _UartPrint
                                     67 	.globl _UartReadBuff
                                     68 	.globl _UartWriteBuff
                                     69 	.globl _UartWrite
                                     70 	.globl _UartRead
                                     71 	.globl _UartReadReady
                                     72 	.globl _UartBegin
                                     73 	.globl _dec2hexNibble
                                     74 	.globl _hex2dec
                                     75 	.globl _hexNibble2dec
                                     76 	.globl _TF2
                                     77 	.globl _EXF2
                                     78 	.globl _RCLK
                                     79 	.globl _TCLK
                                     80 	.globl _EXEN2
                                     81 	.globl _TR2
                                     82 	.globl _C_T2
                                     83 	.globl _CP_RL2
                                     84 	.globl _T2CON_7
                                     85 	.globl _T2CON_6
                                     86 	.globl _T2CON_5
                                     87 	.globl _T2CON_4
                                     88 	.globl _T2CON_3
                                     89 	.globl _T2CON_2
                                     90 	.globl _T2CON_1
                                     91 	.globl _T2CON_0
                                     92 	.globl _PT2
                                     93 	.globl _ET2
                                     94 	.globl _CY
                                     95 	.globl _AC
                                     96 	.globl _F0
                                     97 	.globl _RS1
                                     98 	.globl _RS0
                                     99 	.globl _OV
                                    100 	.globl _F1
                                    101 	.globl _P
                                    102 	.globl _PS
                                    103 	.globl _PT1
                                    104 	.globl _PX1
                                    105 	.globl _PT0
                                    106 	.globl _PX0
                                    107 	.globl _RD
                                    108 	.globl _WR
                                    109 	.globl _T1
                                    110 	.globl _T0
                                    111 	.globl _INT1
                                    112 	.globl _INT0
                                    113 	.globl _TXD
                                    114 	.globl _RXD
                                    115 	.globl _P3_7
                                    116 	.globl _P3_6
                                    117 	.globl _P3_5
                                    118 	.globl _P3_4
                                    119 	.globl _P3_3
                                    120 	.globl _P3_2
                                    121 	.globl _P3_1
                                    122 	.globl _P3_0
                                    123 	.globl _EA
                                    124 	.globl _ES
                                    125 	.globl _ET1
                                    126 	.globl _EX1
                                    127 	.globl _ET0
                                    128 	.globl _EX0
                                    129 	.globl _P2_7
                                    130 	.globl _P2_6
                                    131 	.globl _P2_5
                                    132 	.globl _P2_4
                                    133 	.globl _P2_3
                                    134 	.globl _P2_2
                                    135 	.globl _P2_1
                                    136 	.globl _P2_0
                                    137 	.globl _SM0
                                    138 	.globl _SM1
                                    139 	.globl _SM2
                                    140 	.globl _REN
                                    141 	.globl _TB8
                                    142 	.globl _RB8
                                    143 	.globl _TI
                                    144 	.globl _RI
                                    145 	.globl _P1_7
                                    146 	.globl _P1_6
                                    147 	.globl _P1_5
                                    148 	.globl _P1_4
                                    149 	.globl _P1_3
                                    150 	.globl _P1_2
                                    151 	.globl _P1_1
                                    152 	.globl _P1_0
                                    153 	.globl _TF1
                                    154 	.globl _TR1
                                    155 	.globl _TF0
                                    156 	.globl _TR0
                                    157 	.globl _IE1
                                    158 	.globl _IT1
                                    159 	.globl _IE0
                                    160 	.globl _IT0
                                    161 	.globl _P0_7
                                    162 	.globl _P0_6
                                    163 	.globl _P0_5
                                    164 	.globl _P0_4
                                    165 	.globl _P0_3
                                    166 	.globl _P0_2
                                    167 	.globl _P0_1
                                    168 	.globl _P0_0
                                    169 	.globl _TH2
                                    170 	.globl _TL2
                                    171 	.globl _RCAP2H
                                    172 	.globl _RCAP2L
                                    173 	.globl _T2CON
                                    174 	.globl _B
                                    175 	.globl _ACC
                                    176 	.globl _PSW
                                    177 	.globl _IP
                                    178 	.globl _P3
                                    179 	.globl _IE
                                    180 	.globl _P2
                                    181 	.globl _SBUF
                                    182 	.globl _SCON
                                    183 	.globl _P1
                                    184 	.globl _TH1
                                    185 	.globl _TH0
                                    186 	.globl _TL1
                                    187 	.globl _TL0
                                    188 	.globl _TMOD
                                    189 	.globl _TCON
                                    190 	.globl _PCON
                                    191 	.globl _DPH
                                    192 	.globl _DPL
                                    193 	.globl _SP
                                    194 	.globl _P0
                                    195 	.globl _EEPROM_WRITE_PROTECTION
                                    196 	.globl _HELPER_filename_to_8dot3filename_PARM_2
                                    197 	.globl _SDreadBlock_PARM_2
                                    198 	.globl _sd_acmd_PARM_2
                                    199 	.globl _sd_cmd_PARM_2
                                    200 	.globl _spi_transfer_all_PARM_3
                                    201 	.globl _spi_transfer_all_PARM_2
                                    202 	.globl _UartReadBuff_PARM_2
                                    203 	.globl _UartWriteBuff_PARM_2
                                    204 	.globl _hex2dec_PARM_2
                                    205 ;--------------------------------------------------------
                                    206 ; special function registers
                                    207 ;--------------------------------------------------------
                                    208 	.area RSEG    (ABS,DATA)
      000000                        209 	.org 0x0000
                           000080   210 _P0	=	0x0080
                           000081   211 _SP	=	0x0081
                           000082   212 _DPL	=	0x0082
                           000083   213 _DPH	=	0x0083
                           000087   214 _PCON	=	0x0087
                           000088   215 _TCON	=	0x0088
                           000089   216 _TMOD	=	0x0089
                           00008A   217 _TL0	=	0x008a
                           00008B   218 _TL1	=	0x008b
                           00008C   219 _TH0	=	0x008c
                           00008D   220 _TH1	=	0x008d
                           000090   221 _P1	=	0x0090
                           000098   222 _SCON	=	0x0098
                           000099   223 _SBUF	=	0x0099
                           0000A0   224 _P2	=	0x00a0
                           0000A8   225 _IE	=	0x00a8
                           0000B0   226 _P3	=	0x00b0
                           0000B8   227 _IP	=	0x00b8
                           0000D0   228 _PSW	=	0x00d0
                           0000E0   229 _ACC	=	0x00e0
                           0000F0   230 _B	=	0x00f0
                           0000C8   231 _T2CON	=	0x00c8
                           0000CA   232 _RCAP2L	=	0x00ca
                           0000CB   233 _RCAP2H	=	0x00cb
                           0000CC   234 _TL2	=	0x00cc
                           0000CD   235 _TH2	=	0x00cd
                                    236 ;--------------------------------------------------------
                                    237 ; special function bits
                                    238 ;--------------------------------------------------------
                                    239 	.area RSEG    (ABS,DATA)
      000000                        240 	.org 0x0000
                           000080   241 _P0_0	=	0x0080
                           000081   242 _P0_1	=	0x0081
                           000082   243 _P0_2	=	0x0082
                           000083   244 _P0_3	=	0x0083
                           000084   245 _P0_4	=	0x0084
                           000085   246 _P0_5	=	0x0085
                           000086   247 _P0_6	=	0x0086
                           000087   248 _P0_7	=	0x0087
                           000088   249 _IT0	=	0x0088
                           000089   250 _IE0	=	0x0089
                           00008A   251 _IT1	=	0x008a
                           00008B   252 _IE1	=	0x008b
                           00008C   253 _TR0	=	0x008c
                           00008D   254 _TF0	=	0x008d
                           00008E   255 _TR1	=	0x008e
                           00008F   256 _TF1	=	0x008f
                           000090   257 _P1_0	=	0x0090
                           000091   258 _P1_1	=	0x0091
                           000092   259 _P1_2	=	0x0092
                           000093   260 _P1_3	=	0x0093
                           000094   261 _P1_4	=	0x0094
                           000095   262 _P1_5	=	0x0095
                           000096   263 _P1_6	=	0x0096
                           000097   264 _P1_7	=	0x0097
                           000098   265 _RI	=	0x0098
                           000099   266 _TI	=	0x0099
                           00009A   267 _RB8	=	0x009a
                           00009B   268 _TB8	=	0x009b
                           00009C   269 _REN	=	0x009c
                           00009D   270 _SM2	=	0x009d
                           00009E   271 _SM1	=	0x009e
                           00009F   272 _SM0	=	0x009f
                           0000A0   273 _P2_0	=	0x00a0
                           0000A1   274 _P2_1	=	0x00a1
                           0000A2   275 _P2_2	=	0x00a2
                           0000A3   276 _P2_3	=	0x00a3
                           0000A4   277 _P2_4	=	0x00a4
                           0000A5   278 _P2_5	=	0x00a5
                           0000A6   279 _P2_6	=	0x00a6
                           0000A7   280 _P2_7	=	0x00a7
                           0000A8   281 _EX0	=	0x00a8
                           0000A9   282 _ET0	=	0x00a9
                           0000AA   283 _EX1	=	0x00aa
                           0000AB   284 _ET1	=	0x00ab
                           0000AC   285 _ES	=	0x00ac
                           0000AF   286 _EA	=	0x00af
                           0000B0   287 _P3_0	=	0x00b0
                           0000B1   288 _P3_1	=	0x00b1
                           0000B2   289 _P3_2	=	0x00b2
                           0000B3   290 _P3_3	=	0x00b3
                           0000B4   291 _P3_4	=	0x00b4
                           0000B5   292 _P3_5	=	0x00b5
                           0000B6   293 _P3_6	=	0x00b6
                           0000B7   294 _P3_7	=	0x00b7
                           0000B0   295 _RXD	=	0x00b0
                           0000B1   296 _TXD	=	0x00b1
                           0000B2   297 _INT0	=	0x00b2
                           0000B3   298 _INT1	=	0x00b3
                           0000B4   299 _T0	=	0x00b4
                           0000B5   300 _T1	=	0x00b5
                           0000B6   301 _WR	=	0x00b6
                           0000B7   302 _RD	=	0x00b7
                           0000B8   303 _PX0	=	0x00b8
                           0000B9   304 _PT0	=	0x00b9
                           0000BA   305 _PX1	=	0x00ba
                           0000BB   306 _PT1	=	0x00bb
                           0000BC   307 _PS	=	0x00bc
                           0000D0   308 _P	=	0x00d0
                           0000D1   309 _F1	=	0x00d1
                           0000D2   310 _OV	=	0x00d2
                           0000D3   311 _RS0	=	0x00d3
                           0000D4   312 _RS1	=	0x00d4
                           0000D5   313 _F0	=	0x00d5
                           0000D6   314 _AC	=	0x00d6
                           0000D7   315 _CY	=	0x00d7
                           0000AD   316 _ET2	=	0x00ad
                           0000BD   317 _PT2	=	0x00bd
                           0000C8   318 _T2CON_0	=	0x00c8
                           0000C9   319 _T2CON_1	=	0x00c9
                           0000CA   320 _T2CON_2	=	0x00ca
                           0000CB   321 _T2CON_3	=	0x00cb
                           0000CC   322 _T2CON_4	=	0x00cc
                           0000CD   323 _T2CON_5	=	0x00cd
                           0000CE   324 _T2CON_6	=	0x00ce
                           0000CF   325 _T2CON_7	=	0x00cf
                           0000C8   326 _CP_RL2	=	0x00c8
                           0000C9   327 _C_T2	=	0x00c9
                           0000CA   328 _TR2	=	0x00ca
                           0000CB   329 _EXEN2	=	0x00cb
                           0000CC   330 _TCLK	=	0x00cc
                           0000CD   331 _RCLK	=	0x00cd
                           0000CE   332 _EXF2	=	0x00ce
                           0000CF   333 _TF2	=	0x00cf
                                    334 ;--------------------------------------------------------
                                    335 ; overlayable register banks
                                    336 ;--------------------------------------------------------
                                    337 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        338 	.ds 8
                                    339 ;--------------------------------------------------------
                                    340 ; internal ram data
                                    341 ;--------------------------------------------------------
                                    342 	.area DSEG    (DATA)
      000000                        343 _hex2dec_PARM_2:
      000000                        344 	.ds 1
      000001                        345 _UartWriteBuff_PARM_2:
      000001                        346 	.ds 1
      000002                        347 _UartReadBuff_PARM_2:
      000002                        348 	.ds 1
      000003                        349 _spi_transfer_all_PARM_2:
      000003                        350 	.ds 1
      000004                        351 _spi_transfer_all_PARM_3:
      000004                        352 	.ds 1
      000005                        353 _sd_cmd_PARM_2:
      000005                        354 	.ds 4
      000009                        355 _sd_acmd_PARM_2:
      000009                        356 	.ds 4
      00000D                        357 _SDreadBlock_PARM_2:
      00000D                        358 	.ds 3
      000010                        359 _HELPER_filename_to_8dot3filename_PARM_2:
      000010                        360 	.ds 3
      000013                        361 _HELPER_filename_to_8dot3filename_fname_65536_125:
      000013                        362 	.ds 3
      000016                        363 _HELPER_filename_to_8dot3filename_i_131072_131:
      000016                        364 	.ds 1
      000017                        365 _VBR_MOUNT_VBR_sloc0_1_0:
      000017                        366 	.ds 4
      00001B                        367 _FAT16_LOAD_ROOTENTRY_roote_number_65536_155:
      00001B                        368 	.ds 2
      00001D                        369 _FAT16_LOAD_ROOTENTRY_sloc0_1_0:
      00001D                        370 	.ds 4
      000021                        371 _FAT16_LOAD_ROOTENTRY_sloc1_1_0:
      000021                        372 	.ds 2
      000023                        373 _EEPROM_WRITE_PROTECTION::
      000023                        374 	.ds 1
      000024                        375 _main_buff_65536_230:
      000024                        376 	.ds 16
                                    377 ;--------------------------------------------------------
                                    378 ; overlayable items in internal ram 
                                    379 ;--------------------------------------------------------
                                    380 	.area	OSEG    (OVR,DATA)
                                    381 	.area	OSEG    (OVR,DATA)
                                    382 	.area	OSEG    (OVR,DATA)
                                    383 	.area	OSEG    (OVR,DATA)
                                    384 	.area	OSEG    (OVR,DATA)
                                    385 	.area	OSEG    (OVR,DATA)
      000000                        386 _spi_transfer_PARM_2:
      000000                        387 	.ds 1
                                    388 	.area	OSEG    (OVR,DATA)
      000000                        389 _HELPER_strcmp_PARM_2:
      000000                        390 	.ds 3
                                    391 	.area	OSEG    (OVR,DATA)
      000000                        392 _HELPER_strncmp_PARM_2:
      000000                        393 	.ds 3
      000003                        394 _HELPER_strncmp_PARM_3:
      000003                        395 	.ds 1
                                    396 	.area	OSEG    (OVR,DATA)
                                    397 	.area	OSEG    (OVR,DATA)
                                    398 	.area	OSEG    (OVR,DATA)
                                    399 	.area	OSEG    (OVR,DATA)
                                    400 ;--------------------------------------------------------
                                    401 ; Stack segment in internal ram 
                                    402 ;--------------------------------------------------------
                                    403 	.area	SSEG
      000000                        404 __start__stack:
      000000                        405 	.ds	1
                                    406 
                                    407 ;--------------------------------------------------------
                                    408 ; indirectly addressable internal ram data
                                    409 ;--------------------------------------------------------
                                    410 	.area ISEG    (DATA)
      000000                        411 ___global_partitionTableEntry:
      000000                        412 	.ds 9
      000009                        413 ___global_vbr:
      000009                        414 	.ds 31
      000028                        415 ___global_nthPartitionVBRmounted:
      000028                        416 	.ds 1
      000029                        417 ___global_rootEntry:
      000029                        418 	.ds 24
      000041                        419 _MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_137:
      000041                        420 	.ds 16
      000051                        421 _VBR_MOUNT_VBR_temp_65536_144:
      000051                        422 	.ds 16
      000061                        423 _FAT16_LOAD_ROOTENTRY_temp_65536_156:
      000061                        424 	.ds 32
                                    425 ;--------------------------------------------------------
                                    426 ; absolute internal ram data
                                    427 ;--------------------------------------------------------
                                    428 	.area IABS    (ABS,DATA)
                                    429 	.area IABS    (ABS,DATA)
                                    430 ;--------------------------------------------------------
                                    431 ; bit data
                                    432 ;--------------------------------------------------------
                                    433 	.area BSEG    (BIT)
                                    434 ;--------------------------------------------------------
                                    435 ; paged external ram data
                                    436 ;--------------------------------------------------------
                                    437 	.area PSEG    (PAG,XDATA)
                                    438 ;--------------------------------------------------------
                                    439 ; external ram data
                                    440 ;--------------------------------------------------------
                                    441 	.area XSEG    (XDATA)
                                    442 ;--------------------------------------------------------
                                    443 ; absolute external ram data
                                    444 ;--------------------------------------------------------
                                    445 	.area XABS    (ABS,XDATA)
                                    446 ;--------------------------------------------------------
                                    447 ; external initialized ram data
                                    448 ;--------------------------------------------------------
                                    449 	.area XISEG   (XDATA)
                                    450 	.area HOME    (CODE)
                                    451 	.area GSINIT0 (CODE)
                                    452 	.area GSINIT1 (CODE)
                                    453 	.area GSINIT2 (CODE)
                                    454 	.area GSINIT3 (CODE)
                                    455 	.area GSINIT4 (CODE)
                                    456 	.area GSINIT5 (CODE)
                                    457 	.area GSINIT  (CODE)
                                    458 	.area GSFINAL (CODE)
                                    459 	.area CSEG    (CODE)
                                    460 ;--------------------------------------------------------
                                    461 ; interrupt vector 
                                    462 ;--------------------------------------------------------
                                    463 	.area HOME    (CODE)
      000000                        464 __interrupt_vect:
      000000 02r00r00         [24]  465 	ljmp	__sdcc_gsinit_startup
                                    466 ;--------------------------------------------------------
                                    467 ; global & static initialisations
                                    468 ;--------------------------------------------------------
                                    469 	.area HOME    (CODE)
                                    470 	.area GSINIT  (CODE)
                                    471 	.area GSFINAL (CODE)
                                    472 	.area GSINIT  (CODE)
                                    473 	.globl __sdcc_gsinit_startup
                                    474 	.globl __sdcc_program_startup
                                    475 	.globl __start__stack
                                    476 	.globl __mcs51_genXINIT
                                    477 	.globl __mcs51_genXRAMCLEAR
                                    478 	.globl __mcs51_genRAMCLEAR
                                    479 ;	serialloader.h:11: volatile unsigned char EEPROM_WRITE_PROTECTION=1;
      000000 75*23 01         [24]  480 	mov	_EEPROM_WRITE_PROTECTION,#0x01
                                    481 ;	fat.h:237: __idata static uint8_t __global_nthPartitionVBRmounted=255; //mounted if value is 0-3 for the 4 partitions,else not mounted
      000003 78r28            [12]  482 	mov	r0,#___global_nthPartitionVBRmounted
      000005 76 FF            [12]  483 	mov	@r0,#0xff
                                    484 	.area GSFINAL (CODE)
      000000 02r00r03         [24]  485 	ljmp	__sdcc_program_startup
                                    486 ;--------------------------------------------------------
                                    487 ; Home
                                    488 ;--------------------------------------------------------
                                    489 	.area HOME    (CODE)
                                    490 	.area HOME    (CODE)
      000003                        491 __sdcc_program_startup:
      000003 02r1Ar79         [24]  492 	ljmp	_main
                                    493 ;	return from main will return to caller
                                    494 ;--------------------------------------------------------
                                    495 ; code
                                    496 ;--------------------------------------------------------
                                    497 	.area CSEG    (CODE)
                                    498 ;------------------------------------------------------------
                                    499 ;Allocation info for local variables in function 'hexNibble2dec'
                                    500 ;------------------------------------------------------------
                                    501 ;nibble                    Allocated to registers r7 
                                    502 ;------------------------------------------------------------
                                    503 ;	uart.h:6: unsigned char hexNibble2dec(char nibble)
                                    504 ;	-----------------------------------------
                                    505 ;	 function hexNibble2dec
                                    506 ;	-----------------------------------------
      000000                        507 _hexNibble2dec:
                           000007   508 	ar7 = 0x07
                           000006   509 	ar6 = 0x06
                           000005   510 	ar5 = 0x05
                           000004   511 	ar4 = 0x04
                           000003   512 	ar3 = 0x03
                           000002   513 	ar2 = 0x02
                           000001   514 	ar1 = 0x01
                           000000   515 	ar0 = 0x00
      000000 AF 82            [24]  516 	mov	r7,dpl
                                    517 ;	uart.h:8: if('0' <= nibble && nibble <= '9') return nibble - 0x30;
      000002 BF 30 00         [24]  518 	cjne	r7,#0x30,00139$
      000005                        519 00139$:
      000005 40 0D            [24]  520 	jc	00110$
      000007 EF               [12]  521 	mov	a,r7
      000008 24 C6            [12]  522 	add	a,#0xff - 0x39
      00000A 40 08            [24]  523 	jc	00110$
      00000C 8F 06            [24]  524 	mov	ar6,r7
      00000E EE               [12]  525 	mov	a,r6
      00000F 24 D0            [12]  526 	add	a,#0xd0
      000011 F5 82            [12]  527 	mov	dpl,a
      000013 22               [24]  528 	ret
      000014                        529 00110$:
                                    530 ;	uart.h:9: else if('A' <= nibble && nibble <= 'F') return 10 + nibble - 'A';
      000014 BF 41 00         [24]  531 	cjne	r7,#0x41,00142$
      000017                        532 00142$:
      000017 40 0D            [24]  533 	jc	00106$
      000019 EF               [12]  534 	mov	a,r7
      00001A 24 B9            [12]  535 	add	a,#0xff - 0x46
      00001C 40 08            [24]  536 	jc	00106$
      00001E 8F 06            [24]  537 	mov	ar6,r7
      000020 74 C9            [12]  538 	mov	a,#0xc9
      000022 2E               [12]  539 	add	a,r6
      000023 F5 82            [12]  540 	mov	dpl,a
      000025 22               [24]  541 	ret
      000026                        542 00106$:
                                    543 ;	uart.h:10: else if('a' <= nibble && nibble <= 'f') return 10 + nibble - 'a';
      000026 BF 61 00         [24]  544 	cjne	r7,#0x61,00145$
      000029                        545 00145$:
      000029 40 0B            [24]  546 	jc	00102$
      00002B EF               [12]  547 	mov	a,r7
      00002C 24 99            [12]  548 	add	a,#0xff - 0x66
      00002E 40 06            [24]  549 	jc	00102$
      000030 74 A9            [12]  550 	mov	a,#0xa9
      000032 2F               [12]  551 	add	a,r7
      000033 F5 82            [12]  552 	mov	dpl,a
      000035 22               [24]  553 	ret
      000036                        554 00102$:
                                    555 ;	uart.h:11: else return 0;
      000036 75 82 00         [24]  556 	mov	dpl,#0x00
                                    557 ;	uart.h:12: }
      000039 22               [24]  558 	ret
                                    559 ;------------------------------------------------------------
                                    560 ;Allocation info for local variables in function 'hex2dec'
                                    561 ;------------------------------------------------------------
                                    562 ;LSnibble                  Allocated with name '_hex2dec_PARM_2'
                                    563 ;MSnibble                  Allocated to registers r7 
                                    564 ;------------------------------------------------------------
                                    565 ;	uart.h:14: unsigned char hex2dec(char MSnibble,char LSnibble)
                                    566 ;	-----------------------------------------
                                    567 ;	 function hex2dec
                                    568 ;	-----------------------------------------
      00003A                        569 _hex2dec:
                                    570 ;	uart.h:17: return 16*hexNibble2dec(MSnibble) + hexNibble2dec(LSnibble);
      00003A 12r00r00         [24]  571 	lcall	_hexNibble2dec
      00003D E5 82            [12]  572 	mov	a,dpl
      00003F C4               [12]  573 	swap	a
      000040 54 F0            [12]  574 	anl	a,#0xf0
      000042 FF               [12]  575 	mov	r7,a
      000043 85*00 82         [24]  576 	mov	dpl,_hex2dec_PARM_2
      000046 C0 07            [24]  577 	push	ar7
      000048 12r00r00         [24]  578 	lcall	_hexNibble2dec
      00004B AE 82            [24]  579 	mov	r6,dpl
      00004D D0 07            [24]  580 	pop	ar7
      00004F EE               [12]  581 	mov	a,r6
      000050 2F               [12]  582 	add	a,r7
      000051 F5 82            [12]  583 	mov	dpl,a
                                    584 ;	uart.h:18: }
      000053 22               [24]  585 	ret
                                    586 ;------------------------------------------------------------
                                    587 ;Allocation info for local variables in function 'dec2hexNibble'
                                    588 ;------------------------------------------------------------
                                    589 ;dec                       Allocated to registers r7 
                                    590 ;------------------------------------------------------------
                                    591 ;	uart.h:21: unsigned char dec2hexNibble(unsigned char dec)
                                    592 ;	-----------------------------------------
                                    593 ;	 function dec2hexNibble
                                    594 ;	-----------------------------------------
      000054                        595 _dec2hexNibble:
                                    596 ;	uart.h:24: if(dec>15) return 'X'; // X for invalid
      000054 E5 82            [12]  597 	mov	a,dpl
      000056 FF               [12]  598 	mov	r7,a
      000057 24 F0            [12]  599 	add	a,#0xff - 0x0f
      000059 50 04            [24]  600 	jnc	00102$
      00005B 75 82 58         [24]  601 	mov	dpl,#0x58
      00005E 22               [24]  602 	ret
      00005F                        603 00102$:
                                    604 ;	uart.h:26: if(dec<=9) return 0x30 + dec;
      00005F EF               [12]  605 	mov	a,r7
      000060 24 F6            [12]  606 	add	a,#0xff - 0x09
      000062 40 08            [24]  607 	jc	00104$
      000064 8F 06            [24]  608 	mov	ar6,r7
      000066 74 30            [12]  609 	mov	a,#0x30
      000068 2E               [12]  610 	add	a,r6
      000069 F5 82            [12]  611 	mov	dpl,a
      00006B 22               [24]  612 	ret
      00006C                        613 00104$:
                                    614 ;	uart.h:27: else return 'A' + dec - 10;
      00006C 74 37            [12]  615 	mov	a,#0x37
      00006E 2F               [12]  616 	add	a,r7
      00006F F5 82            [12]  617 	mov	dpl,a
                                    618 ;	uart.h:28: }
      000071 22               [24]  619 	ret
                                    620 ;------------------------------------------------------------
                                    621 ;Allocation info for local variables in function 'UartBegin'
                                    622 ;------------------------------------------------------------
                                    623 ;	uart.h:33: void UartBegin()
                                    624 ;	-----------------------------------------
                                    625 ;	 function UartBegin
                                    626 ;	-----------------------------------------
      000072                        627 _UartBegin:
                                    628 ;	uart.h:37: TMOD = 0X20; //TIMER1 8 BIT AUTO-RELOAD
      000072 75 89 20         [24]  629 	mov	_TMOD,#0x20
                                    630 ;	uart.h:39: TH1 = 0XF3; //2400
      000075 75 8D F3         [24]  631 	mov	_TH1,#0xf3
                                    632 ;	uart.h:40: SCON = 0X50;
      000078 75 98 50         [24]  633 	mov	_SCON,#0x50
                                    634 ;	uart.h:42: PCON |= 1<<7; //double the baudrate - 4800
      00007B 43 87 80         [24]  635 	orl	_PCON,#0x80
                                    636 ;	uart.h:44: TR1 = 1; //START TIMER
                                    637 ;	assignBit
      00007E D2 8E            [12]  638 	setb	_TR1
                                    639 ;	uart.h:45: }
      000080 22               [24]  640 	ret
                                    641 ;------------------------------------------------------------
                                    642 ;Allocation info for local variables in function 'UartReadReady'
                                    643 ;------------------------------------------------------------
                                    644 ;	uart.h:47: unsigned char UartReadReady()
                                    645 ;	-----------------------------------------
                                    646 ;	 function UartReadReady
                                    647 ;	-----------------------------------------
      000081                        648 _UartReadReady:
                                    649 ;	uart.h:49: if(RI==0)return 0; //not received any char
      000081 20 98 04         [24]  650 	jb	_RI,00102$
      000084 75 82 00         [24]  651 	mov	dpl,#0x00
      000087 22               [24]  652 	ret
      000088                        653 00102$:
                                    654 ;	uart.h:50: else return 1; //received and ready
      000088 75 82 01         [24]  655 	mov	dpl,#0x01
                                    656 ;	uart.h:51: }
      00008B 22               [24]  657 	ret
                                    658 ;------------------------------------------------------------
                                    659 ;Allocation info for local variables in function 'UartRead'
                                    660 ;------------------------------------------------------------
                                    661 ;value                     Allocated to registers 
                                    662 ;------------------------------------------------------------
                                    663 ;	uart.h:53: unsigned char UartRead()
                                    664 ;	-----------------------------------------
                                    665 ;	 function UartRead
                                    666 ;	-----------------------------------------
      00008C                        667 _UartRead:
                                    668 ;	uart.h:56: while(RI==0); //wait till RX
      00008C                        669 00101$:
                                    670 ;	uart.h:57: RI=0;
                                    671 ;	assignBit
      00008C 10 98 02         [24]  672 	jbc	_RI,00114$
      00008F 80 FB            [24]  673 	sjmp	00101$
      000091                        674 00114$:
                                    675 ;	uart.h:58: value = SBUF;
      000091 85 99 82         [24]  676 	mov	dpl,_SBUF
                                    677 ;	uart.h:59: return value;
                                    678 ;	uart.h:60: }
      000094 22               [24]  679 	ret
                                    680 ;------------------------------------------------------------
                                    681 ;Allocation info for local variables in function 'UartWrite'
                                    682 ;------------------------------------------------------------
                                    683 ;value                     Allocated to registers 
                                    684 ;------------------------------------------------------------
                                    685 ;	uart.h:63: void UartWrite(unsigned char value)
                                    686 ;	-----------------------------------------
                                    687 ;	 function UartWrite
                                    688 ;	-----------------------------------------
      000095                        689 _UartWrite:
      000095 85 82 99         [24]  690 	mov	_SBUF,dpl
                                    691 ;	uart.h:66: while(TI==0); // wait till TX
      000098                        692 00101$:
                                    693 ;	uart.h:67: TI=0;
                                    694 ;	assignBit
      000098 10 99 02         [24]  695 	jbc	_TI,00114$
      00009B 80 FB            [24]  696 	sjmp	00101$
      00009D                        697 00114$:
                                    698 ;	uart.h:68: }
      00009D 22               [24]  699 	ret
                                    700 ;------------------------------------------------------------
                                    701 ;Allocation info for local variables in function 'UartWriteBuff'
                                    702 ;------------------------------------------------------------
                                    703 ;length                    Allocated with name '_UartWriteBuff_PARM_2'
                                    704 ;p                         Allocated to registers r5 r6 r7 
                                    705 ;i                         Allocated to registers r4 
                                    706 ;------------------------------------------------------------
                                    707 ;	uart.h:70: void UartWriteBuff(unsigned char *p, unsigned char length)
                                    708 ;	-----------------------------------------
                                    709 ;	 function UartWriteBuff
                                    710 ;	-----------------------------------------
      00009E                        711 _UartWriteBuff:
      00009E AD 82            [24]  712 	mov	r5,dpl
      0000A0 AE 83            [24]  713 	mov	r6,dph
      0000A2 AF F0            [24]  714 	mov	r7,b
                                    715 ;	uart.h:73: for (i=0;i<length;i++)
      0000A4 7C 00            [12]  716 	mov	r4,#0x00
      0000A6                        717 00103$:
      0000A6 C3               [12]  718 	clr	c
      0000A7 EC               [12]  719 	mov	a,r4
      0000A8 95*01            [12]  720 	subb	a,_UartWriteBuff_PARM_2
      0000AA 50 29            [24]  721 	jnc	00105$
                                    722 ;	uart.h:75: UartWrite(p[i]);
      0000AC EC               [12]  723 	mov	a,r4
      0000AD 2D               [12]  724 	add	a,r5
      0000AE F9               [12]  725 	mov	r1,a
      0000AF E4               [12]  726 	clr	a
      0000B0 3E               [12]  727 	addc	a,r6
      0000B1 FA               [12]  728 	mov	r2,a
      0000B2 8F 03            [24]  729 	mov	ar3,r7
      0000B4 89 82            [24]  730 	mov	dpl,r1
      0000B6 8A 83            [24]  731 	mov	dph,r2
      0000B8 8B F0            [24]  732 	mov	b,r3
      0000BA 12r00r00         [24]  733 	lcall	__gptrget
      0000BD F5 82            [12]  734 	mov	dpl,a
      0000BF C0 07            [24]  735 	push	ar7
      0000C1 C0 06            [24]  736 	push	ar6
      0000C3 C0 05            [24]  737 	push	ar5
      0000C5 C0 04            [24]  738 	push	ar4
      0000C7 12r00r95         [24]  739 	lcall	_UartWrite
      0000CA D0 04            [24]  740 	pop	ar4
      0000CC D0 05            [24]  741 	pop	ar5
      0000CE D0 06            [24]  742 	pop	ar6
      0000D0 D0 07            [24]  743 	pop	ar7
                                    744 ;	uart.h:73: for (i=0;i<length;i++)
      0000D2 0C               [12]  745 	inc	r4
      0000D3 80 D1            [24]  746 	sjmp	00103$
      0000D5                        747 00105$:
                                    748 ;	uart.h:77: }
      0000D5 22               [24]  749 	ret
                                    750 ;------------------------------------------------------------
                                    751 ;Allocation info for local variables in function 'UartReadBuff'
                                    752 ;------------------------------------------------------------
                                    753 ;length                    Allocated with name '_UartReadBuff_PARM_2'
                                    754 ;p                         Allocated to registers r5 r6 r7 
                                    755 ;i                         Allocated to registers r4 
                                    756 ;------------------------------------------------------------
                                    757 ;	uart.h:79: void UartReadBuff(unsigned char *p, unsigned char length)
                                    758 ;	-----------------------------------------
                                    759 ;	 function UartReadBuff
                                    760 ;	-----------------------------------------
      0000D6                        761 _UartReadBuff:
      0000D6 AD 82            [24]  762 	mov	r5,dpl
      0000D8 AE 83            [24]  763 	mov	r6,dph
      0000DA AF F0            [24]  764 	mov	r7,b
                                    765 ;	uart.h:82: for (i=0;i<length;i++)
      0000DC 7C 00            [12]  766 	mov	r4,#0x00
      0000DE                        767 00103$:
      0000DE C3               [12]  768 	clr	c
      0000DF EC               [12]  769 	mov	a,r4
      0000E0 95*02            [12]  770 	subb	a,_UartReadBuff_PARM_2
      0000E2 50 36            [24]  771 	jnc	00105$
                                    772 ;	uart.h:84: p[i] = UartRead();
      0000E4 EC               [12]  773 	mov	a,r4
      0000E5 2D               [12]  774 	add	a,r5
      0000E6 F9               [12]  775 	mov	r1,a
      0000E7 E4               [12]  776 	clr	a
      0000E8 3E               [12]  777 	addc	a,r6
      0000E9 FA               [12]  778 	mov	r2,a
      0000EA 8F 03            [24]  779 	mov	ar3,r7
      0000EC C0 07            [24]  780 	push	ar7
      0000EE C0 06            [24]  781 	push	ar6
      0000F0 C0 05            [24]  782 	push	ar5
      0000F2 C0 04            [24]  783 	push	ar4
      0000F4 C0 03            [24]  784 	push	ar3
      0000F6 C0 02            [24]  785 	push	ar2
      0000F8 C0 01            [24]  786 	push	ar1
      0000FA 12r00r8C         [24]  787 	lcall	_UartRead
      0000FD A8 82            [24]  788 	mov	r0,dpl
      0000FF D0 01            [24]  789 	pop	ar1
      000101 D0 02            [24]  790 	pop	ar2
      000103 D0 03            [24]  791 	pop	ar3
      000105 D0 04            [24]  792 	pop	ar4
      000107 D0 05            [24]  793 	pop	ar5
      000109 D0 06            [24]  794 	pop	ar6
      00010B D0 07            [24]  795 	pop	ar7
      00010D 89 82            [24]  796 	mov	dpl,r1
      00010F 8A 83            [24]  797 	mov	dph,r2
      000111 8B F0            [24]  798 	mov	b,r3
      000113 E8               [12]  799 	mov	a,r0
      000114 12r00r00         [24]  800 	lcall	__gptrput
                                    801 ;	uart.h:82: for (i=0;i<length;i++)
      000117 0C               [12]  802 	inc	r4
      000118 80 C4            [24]  803 	sjmp	00103$
      00011A                        804 00105$:
                                    805 ;	uart.h:86: }
      00011A 22               [24]  806 	ret
                                    807 ;------------------------------------------------------------
                                    808 ;Allocation info for local variables in function 'UartPrint'
                                    809 ;------------------------------------------------------------
                                    810 ;p                         Allocated to registers 
                                    811 ;------------------------------------------------------------
                                    812 ;	uart.h:88: void UartPrint(unsigned char *p)
                                    813 ;	-----------------------------------------
                                    814 ;	 function UartPrint
                                    815 ;	-----------------------------------------
      00011B                        816 _UartPrint:
      00011B AD 82            [24]  817 	mov	r5,dpl
      00011D AE 83            [24]  818 	mov	r6,dph
      00011F AF F0            [24]  819 	mov	r7,b
                                    820 ;	uart.h:90: do
      000121                        821 00101$:
                                    822 ;	uart.h:92: UartWrite(*p);
      000121 8D 82            [24]  823 	mov	dpl,r5
      000123 8E 83            [24]  824 	mov	dph,r6
      000125 8F F0            [24]  825 	mov	b,r7
      000127 12r00r00         [24]  826 	lcall	__gptrget
      00012A FC               [12]  827 	mov	r4,a
      00012B A3               [24]  828 	inc	dptr
      00012C AD 82            [24]  829 	mov	r5,dpl
      00012E AE 83            [24]  830 	mov	r6,dph
      000130 8C 82            [24]  831 	mov	dpl,r4
      000132 C0 07            [24]  832 	push	ar7
      000134 C0 06            [24]  833 	push	ar6
      000136 C0 05            [24]  834 	push	ar5
      000138 12r00r95         [24]  835 	lcall	_UartWrite
      00013B D0 05            [24]  836 	pop	ar5
      00013D D0 06            [24]  837 	pop	ar6
      00013F D0 07            [24]  838 	pop	ar7
                                    839 ;	uart.h:93: }while(*(++p)!=0);
      000141 8D 82            [24]  840 	mov	dpl,r5
      000143 8E 83            [24]  841 	mov	dph,r6
      000145 8F F0            [24]  842 	mov	b,r7
      000147 12r00r00         [24]  843 	lcall	__gptrget
      00014A 70 D5            [24]  844 	jnz	00101$
                                    845 ;	uart.h:94: }
      00014C 22               [24]  846 	ret
                                    847 ;------------------------------------------------------------
                                    848 ;Allocation info for local variables in function 'UartWriteNumber'
                                    849 ;------------------------------------------------------------
                                    850 ;format                    Allocated to stack - _bp -3
                                    851 ;num                       Allocated to registers r7 
                                    852 ;msd                       Allocated to registers r4 
                                    853 ;lsd                       Allocated to registers r6 
                                    854 ;extra                     Allocated to registers r3 
                                    855 ;------------------------------------------------------------
                                    856 ;	uart.h:99: void UartWriteNumber(unsigned char num,unsigned char format) __reentrant
                                    857 ;	-----------------------------------------
                                    858 ;	 function UartWriteNumber
                                    859 ;	-----------------------------------------
      00014D                        860 _UartWriteNumber:
      00014D C0*00            [24]  861 	push	_bp
      00014F 85 81*00         [24]  862 	mov	_bp,sp
      000152 AF 82            [24]  863 	mov	r7,dpl
                                    864 ;	uart.h:104: if(format==HEX)
      000154 E5*00            [12]  865 	mov	a,_bp
      000156 24 FD            [12]  866 	add	a,#0xfd
      000158 F8               [12]  867 	mov	r0,a
      000159 E6               [12]  868 	mov	a,@r0
                                    869 ;	uart.h:106: msd = num/16;
      00015A 70 32            [24]  870 	jnz	00104$
      00015C 8F 05            [24]  871 	mov	ar5,r7
      00015E FE               [12]  872 	mov	r6,a
      00015F 75*00 10         [24]  873 	mov	__divsint_PARM_2,#0x10
                                    874 ;	1-genFromRTrack replaced	mov	(__divsint_PARM_2 + 1),#0x00
      000162 8E*01            [24]  875 	mov	(__divsint_PARM_2 + 1),r6
      000164 8D 82            [24]  876 	mov	dpl,r5
      000166 8E 83            [24]  877 	mov	dph,r6
      000168 C0 06            [24]  878 	push	ar6
      00016A C0 05            [24]  879 	push	ar5
      00016C 12r00r00         [24]  880 	lcall	__divsint
      00016F AB 82            [24]  881 	mov	r3,dpl
      000171 D0 05            [24]  882 	pop	ar5
      000173 D0 06            [24]  883 	pop	ar6
                                    884 ;	uart.h:107: lsd = num%16;
      000175 53 05 0F         [24]  885 	anl	ar5,#0x0f
                                    886 ;	uart.h:108: UartWrite(dec2hexNibble(msd));
      000178 8B 82            [24]  887 	mov	dpl,r3
      00017A C0 05            [24]  888 	push	ar5
      00017C 12r00r54         [24]  889 	lcall	_dec2hexNibble
      00017F 12r00r95         [24]  890 	lcall	_UartWrite
      000182 D0 05            [24]  891 	pop	ar5
                                    892 ;	uart.h:109: UartWrite(dec2hexNibble(lsd));
      000184 8D 82            [24]  893 	mov	dpl,r5
      000186 12r00r54         [24]  894 	lcall	_dec2hexNibble
      000189 12r00r95         [24]  895 	lcall	_UartWrite
      00018C 80 7B            [24]  896 	sjmp	00106$
      00018E                        897 00104$:
                                    898 ;	uart.h:112: else if(format==DEC)
      00018E E5*00            [12]  899 	mov	a,_bp
      000190 24 FD            [12]  900 	add	a,#0xfd
      000192 F8               [12]  901 	mov	r0,a
      000193 B6 01 73         [24]  902 	cjne	@r0,#0x01,00106$
                                    903 ;	uart.h:114: msd = num/100; // 100s place
      000196 7E 00            [12]  904 	mov	r6,#0x00
      000198 75*00 64         [24]  905 	mov	__divsint_PARM_2,#0x64
                                    906 ;	1-genFromRTrack replaced	mov	(__divsint_PARM_2 + 1),#0x00
      00019B 8E*01            [24]  907 	mov	(__divsint_PARM_2 + 1),r6
      00019D 8F 82            [24]  908 	mov	dpl,r7
      00019F 8E 83            [24]  909 	mov	dph,r6
      0001A1 C0 07            [24]  910 	push	ar7
      0001A3 C0 06            [24]  911 	push	ar6
      0001A5 12r00r00         [24]  912 	lcall	__divsint
      0001A8 AC 82            [24]  913 	mov	r4,dpl
      0001AA D0 06            [24]  914 	pop	ar6
      0001AC D0 07            [24]  915 	pop	ar7
                                    916 ;	uart.h:115: extra = (num%100)/10; //tenth place
      0001AE 75*00 64         [24]  917 	mov	__modsint_PARM_2,#0x64
      0001B1 75*01 00         [24]  918 	mov	(__modsint_PARM_2 + 1),#0x00
      0001B4 8F 82            [24]  919 	mov	dpl,r7
      0001B6 8E 83            [24]  920 	mov	dph,r6
      0001B8 C0 07            [24]  921 	push	ar7
      0001BA C0 06            [24]  922 	push	ar6
      0001BC C0 04            [24]  923 	push	ar4
      0001BE 12r00r00         [24]  924 	lcall	__modsint
      0001C1 75*00 0A         [24]  925 	mov	__divsint_PARM_2,#0x0a
      0001C4 75*01 00         [24]  926 	mov	(__divsint_PARM_2 + 1),#0x00
      0001C7 12r00r00         [24]  927 	lcall	__divsint
      0001CA AB 82            [24]  928 	mov	r3,dpl
      0001CC D0 04            [24]  929 	pop	ar4
      0001CE D0 06            [24]  930 	pop	ar6
      0001D0 D0 07            [24]  931 	pop	ar7
                                    932 ;	uart.h:116: lsd = num%10;
      0001D2 75*00 0A         [24]  933 	mov	__modsint_PARM_2,#0x0a
      0001D5 75*01 00         [24]  934 	mov	(__modsint_PARM_2 + 1),#0x00
      0001D8 8F 82            [24]  935 	mov	dpl,r7
      0001DA 8E 83            [24]  936 	mov	dph,r6
      0001DC C0 04            [24]  937 	push	ar4
      0001DE C0 03            [24]  938 	push	ar3
      0001E0 12r00r00         [24]  939 	lcall	__modsint
      0001E3 AE 82            [24]  940 	mov	r6,dpl
      0001E5 D0 03            [24]  941 	pop	ar3
      0001E7 D0 04            [24]  942 	pop	ar4
                                    943 ;	uart.h:118: UartWrite(msd + 0x30);
      0001E9 74 30            [12]  944 	mov	a,#0x30
      0001EB 2C               [12]  945 	add	a,r4
      0001EC F5 82            [12]  946 	mov	dpl,a
      0001EE C0 06            [24]  947 	push	ar6
      0001F0 C0 03            [24]  948 	push	ar3
      0001F2 12r00r95         [24]  949 	lcall	_UartWrite
      0001F5 D0 03            [24]  950 	pop	ar3
                                    951 ;	uart.h:119: UartWrite(extra + 0x30);
      0001F7 74 30            [12]  952 	mov	a,#0x30
      0001F9 2B               [12]  953 	add	a,r3
      0001FA F5 82            [12]  954 	mov	dpl,a
      0001FC 12r00r95         [24]  955 	lcall	_UartWrite
      0001FF D0 06            [24]  956 	pop	ar6
                                    957 ;	uart.h:120: UartWrite(lsd + 0x30);
      000201 74 30            [12]  958 	mov	a,#0x30
      000203 2E               [12]  959 	add	a,r6
      000204 F5 82            [12]  960 	mov	dpl,a
      000206 12r00r95         [24]  961 	lcall	_UartWrite
      000209                        962 00106$:
                                    963 ;	uart.h:123: }
      000209 D0*00            [24]  964 	pop	_bp
      00020B 22               [24]  965 	ret
                                    966 ;------------------------------------------------------------
                                    967 ;Allocation info for local variables in function 'UartWriteNumbers'
                                    968 ;------------------------------------------------------------
                                    969 ;length                    Allocated to stack - _bp -3
                                    970 ;format                    Allocated to stack - _bp -4
                                    971 ;delimiter                 Allocated to stack - _bp -5
                                    972 ;p                         Allocated to registers 
                                    973 ;i                         Allocated to registers r4 
                                    974 ;------------------------------------------------------------
                                    975 ;	uart.h:125: void UartWriteNumbers(unsigned char *p, unsigned char length,unsigned char format,unsigned char delimiter) __reentrant
                                    976 ;	-----------------------------------------
                                    977 ;	 function UartWriteNumbers
                                    978 ;	-----------------------------------------
      00020C                        979 _UartWriteNumbers:
      00020C C0*00            [24]  980 	push	_bp
      00020E 85 81*00         [24]  981 	mov	_bp,sp
      000211 AD 82            [24]  982 	mov	r5,dpl
      000213 AE 83            [24]  983 	mov	r6,dph
      000215 AF F0            [24]  984 	mov	r7,b
                                    985 ;	uart.h:129: for(i=0;i<length;i++,p++)
      000217 7C 00            [12]  986 	mov	r4,#0x00
      000219                        987 00103$:
      000219 E5*00            [12]  988 	mov	a,_bp
      00021B 24 FD            [12]  989 	add	a,#0xfd
      00021D F8               [12]  990 	mov	r0,a
      00021E C3               [12]  991 	clr	c
      00021F EC               [12]  992 	mov	a,r4
      000220 96               [12]  993 	subb	a,@r0
      000221 50 3B            [24]  994 	jnc	00105$
                                    995 ;	uart.h:131: UartWriteNumber(*p,format);
      000223 8D 82            [24]  996 	mov	dpl,r5
      000225 8E 83            [24]  997 	mov	dph,r6
      000227 8F F0            [24]  998 	mov	b,r7
      000229 12r00r00         [24]  999 	lcall	__gptrget
      00022C FB               [12] 1000 	mov	r3,a
      00022D A3               [24] 1001 	inc	dptr
      00022E AD 82            [24] 1002 	mov	r5,dpl
      000230 AE 83            [24] 1003 	mov	r6,dph
      000232 C0 07            [24] 1004 	push	ar7
      000234 C0 06            [24] 1005 	push	ar6
      000236 C0 05            [24] 1006 	push	ar5
      000238 C0 04            [24] 1007 	push	ar4
      00023A E5*00            [12] 1008 	mov	a,_bp
      00023C 24 FC            [12] 1009 	add	a,#0xfc
      00023E F8               [12] 1010 	mov	r0,a
      00023F E6               [12] 1011 	mov	a,@r0
      000240 C0 E0            [24] 1012 	push	acc
      000242 8B 82            [24] 1013 	mov	dpl,r3
      000244 12r01r4D         [24] 1014 	lcall	_UartWriteNumber
      000247 15 81            [12] 1015 	dec	sp
                                   1016 ;	uart.h:132: UartWrite(delimiter);
      000249 E5*00            [12] 1017 	mov	a,_bp
      00024B 24 FB            [12] 1018 	add	a,#0xfb
      00024D F8               [12] 1019 	mov	r0,a
      00024E 86 82            [24] 1020 	mov	dpl,@r0
      000250 12r00r95         [24] 1021 	lcall	_UartWrite
      000253 D0 04            [24] 1022 	pop	ar4
      000255 D0 05            [24] 1023 	pop	ar5
      000257 D0 06            [24] 1024 	pop	ar6
      000259 D0 07            [24] 1025 	pop	ar7
                                   1026 ;	uart.h:129: for(i=0;i<length;i++,p++)
      00025B 0C               [12] 1027 	inc	r4
      00025C 80 BB            [24] 1028 	sjmp	00103$
      00025E                       1029 00105$:
                                   1030 ;	uart.h:134: }
      00025E D0*00            [24] 1031 	pop	_bp
      000260 22               [24] 1032 	ret
                                   1033 ;------------------------------------------------------------
                                   1034 ;Allocation info for local variables in function 'UartPrintNumber'
                                   1035 ;------------------------------------------------------------
                                   1036 ;n                         Allocated to stack - _bp +1
                                   1037 ;digit                     Allocated to stack - _bp +7
                                   1038 ;i                         Allocated to stack - _bp +5
                                   1039 ;j                         Allocated to registers r3 
                                   1040 ;leading_zeroes_flag       Allocated to stack - _bp +6
                                   1041 ;sloc0                     Allocated to stack - _bp +12
                                   1042 ;------------------------------------------------------------
                                   1043 ;	uart.h:136: void UartPrintNumber(unsigned long n) __reentrant
                                   1044 ;	-----------------------------------------
                                   1045 ;	 function UartPrintNumber
                                   1046 ;	-----------------------------------------
      000261                       1047 _UartPrintNumber:
      000261 C0*00            [24] 1048 	push	_bp
      000263 85 81*00         [24] 1049 	mov	_bp,sp
      000266 C0 82            [24] 1050 	push	dpl
      000268 C0 83            [24] 1051 	push	dph
      00026A C0 F0            [24] 1052 	push	b
      00026C C0 E0            [24] 1053 	push	acc
      00026E E5 81            [12] 1054 	mov	a,sp
      000270 24 06            [12] 1055 	add	a,#0x06
      000272 F5 81            [12] 1056 	mov	sp,a
                                   1057 ;	uart.h:152: char i,j,leading_zeroes_flag=1;
      000274 E5*00            [12] 1058 	mov	a,_bp
      000276 24 06            [12] 1059 	add	a,#0x06
      000278 F8               [12] 1060 	mov	r0,a
      000279 76 01            [12] 1061 	mov	@r0,#0x01
                                   1062 ;	uart.h:153: for(i=8;i>0;i--)
      00027B E5*00            [12] 1063 	mov	a,_bp
      00027D 24 05            [12] 1064 	add	a,#0x05
      00027F F8               [12] 1065 	mov	r0,a
      000280 76 08            [12] 1066 	mov	@r0,#0x08
      000282                       1067 00112$:
                                   1068 ;	uart.h:155: digit=n;
      000282 A8*00            [24] 1069 	mov	r0,_bp
      000284 08               [12] 1070 	inc	r0
      000285 E5*00            [12] 1071 	mov	a,_bp
      000287 24 07            [12] 1072 	add	a,#0x07
      000289 F9               [12] 1073 	mov	r1,a
      00028A E6               [12] 1074 	mov	a,@r0
      00028B F7               [12] 1075 	mov	@r1,a
      00028C 08               [12] 1076 	inc	r0
      00028D 09               [12] 1077 	inc	r1
      00028E E6               [12] 1078 	mov	a,@r0
      00028F F7               [12] 1079 	mov	@r1,a
      000290 08               [12] 1080 	inc	r0
      000291 09               [12] 1081 	inc	r1
      000292 E6               [12] 1082 	mov	a,@r0
      000293 F7               [12] 1083 	mov	@r1,a
      000294 08               [12] 1084 	inc	r0
      000295 09               [12] 1085 	inc	r1
      000296 E6               [12] 1086 	mov	a,@r0
      000297 F7               [12] 1087 	mov	@r1,a
                                   1088 ;	uart.h:156: for(j=1;j<i;j++) digit/=10;
      000298 7B 01            [12] 1089 	mov	r3,#0x01
      00029A                       1090 00110$:
      00029A E5*00            [12] 1091 	mov	a,_bp
      00029C 24 05            [12] 1092 	add	a,#0x05
      00029E F8               [12] 1093 	mov	r0,a
      00029F C3               [12] 1094 	clr	c
      0002A0 EB               [12] 1095 	mov	a,r3
      0002A1 96               [12] 1096 	subb	a,@r0
      0002A2 50 3A            [24] 1097 	jnc	00101$
      0002A4 75*00 0A         [24] 1098 	mov	__divulong_PARM_2,#0x0a
      0002A7 E4               [12] 1099 	clr	a
      0002A8 F5*01            [12] 1100 	mov	(__divulong_PARM_2 + 1),a
      0002AA F5*02            [12] 1101 	mov	(__divulong_PARM_2 + 2),a
      0002AC F5*03            [12] 1102 	mov	(__divulong_PARM_2 + 3),a
      0002AE E5*00            [12] 1103 	mov	a,_bp
      0002B0 24 07            [12] 1104 	add	a,#0x07
      0002B2 F8               [12] 1105 	mov	r0,a
      0002B3 86 82            [24] 1106 	mov	dpl,@r0
      0002B5 08               [12] 1107 	inc	r0
      0002B6 86 83            [24] 1108 	mov	dph,@r0
      0002B8 08               [12] 1109 	inc	r0
      0002B9 86 F0            [24] 1110 	mov	b,@r0
      0002BB 08               [12] 1111 	inc	r0
      0002BC E6               [12] 1112 	mov	a,@r0
      0002BD C0 03            [24] 1113 	push	ar3
      0002BF 12r00r00         [24] 1114 	lcall	__divulong
      0002C2 AC 82            [24] 1115 	mov	r4,dpl
      0002C4 AD 83            [24] 1116 	mov	r5,dph
      0002C6 AE F0            [24] 1117 	mov	r6,b
      0002C8 FF               [12] 1118 	mov	r7,a
      0002C9 D0 03            [24] 1119 	pop	ar3
      0002CB E5*00            [12] 1120 	mov	a,_bp
      0002CD 24 07            [12] 1121 	add	a,#0x07
      0002CF F8               [12] 1122 	mov	r0,a
      0002D0 A6 04            [24] 1123 	mov	@r0,ar4
      0002D2 08               [12] 1124 	inc	r0
      0002D3 A6 05            [24] 1125 	mov	@r0,ar5
      0002D5 08               [12] 1126 	inc	r0
      0002D6 A6 06            [24] 1127 	mov	@r0,ar6
      0002D8 08               [12] 1128 	inc	r0
      0002D9 A6 07            [24] 1129 	mov	@r0,ar7
      0002DB 0B               [12] 1130 	inc	r3
      0002DC 80 BC            [24] 1131 	sjmp	00110$
      0002DE                       1132 00101$:
                                   1133 ;	uart.h:158: if(leading_zeroes_flag && digit%10) leading_zeroes_flag=0; //flag to start printing
      0002DE E5*00            [12] 1134 	mov	a,_bp
      0002E0 24 06            [12] 1135 	add	a,#0x06
      0002E2 F8               [12] 1136 	mov	r0,a
      0002E3 E6               [12] 1137 	mov	a,@r0
      0002E4 60 30            [24] 1138 	jz	00103$
      0002E6 75*00 0A         [24] 1139 	mov	__modulong_PARM_2,#0x0a
      0002E9 E4               [12] 1140 	clr	a
      0002EA F5*01            [12] 1141 	mov	(__modulong_PARM_2 + 1),a
      0002EC F5*02            [12] 1142 	mov	(__modulong_PARM_2 + 2),a
      0002EE F5*03            [12] 1143 	mov	(__modulong_PARM_2 + 3),a
      0002F0 E5*00            [12] 1144 	mov	a,_bp
      0002F2 24 07            [12] 1145 	add	a,#0x07
      0002F4 F8               [12] 1146 	mov	r0,a
      0002F5 86 82            [24] 1147 	mov	dpl,@r0
      0002F7 08               [12] 1148 	inc	r0
      0002F8 86 83            [24] 1149 	mov	dph,@r0
      0002FA 08               [12] 1150 	inc	r0
      0002FB 86 F0            [24] 1151 	mov	b,@r0
      0002FD 08               [12] 1152 	inc	r0
      0002FE E6               [12] 1153 	mov	a,@r0
      0002FF 12r00r00         [24] 1154 	lcall	__modulong
      000302 AA 82            [24] 1155 	mov	r2,dpl
      000304 AB 83            [24] 1156 	mov	r3,dph
      000306 AE F0            [24] 1157 	mov	r6,b
      000308 FF               [12] 1158 	mov	r7,a
      000309 EA               [12] 1159 	mov	a,r2
      00030A 4B               [12] 1160 	orl	a,r3
      00030B 4E               [12] 1161 	orl	a,r6
      00030C 4F               [12] 1162 	orl	a,r7
      00030D 60 07            [24] 1163 	jz	00103$
      00030F E5*00            [12] 1164 	mov	a,_bp
      000311 24 06            [12] 1165 	add	a,#0x06
      000313 F8               [12] 1166 	mov	r0,a
      000314 76 00            [12] 1167 	mov	@r0,#0x00
      000316                       1168 00103$:
                                   1169 ;	uart.h:160: if(leading_zeroes_flag); //pass - do not print
      000316 E5*00            [12] 1170 	mov	a,_bp
      000318 24 06            [12] 1171 	add	a,#0x06
      00031A F8               [12] 1172 	mov	r0,a
      00031B E6               [12] 1173 	mov	a,@r0
      00031C 70 26            [24] 1174 	jnz	00113$
                                   1175 ;	uart.h:161: else UartWrite(0x30 + digit%10);
      00031E 75*00 0A         [24] 1176 	mov	__modulong_PARM_2,#0x0a
      000321 E4               [12] 1177 	clr	a
      000322 F5*01            [12] 1178 	mov	(__modulong_PARM_2 + 1),a
      000324 F5*02            [12] 1179 	mov	(__modulong_PARM_2 + 2),a
      000326 F5*03            [12] 1180 	mov	(__modulong_PARM_2 + 3),a
      000328 E5*00            [12] 1181 	mov	a,_bp
      00032A 24 07            [12] 1182 	add	a,#0x07
      00032C F8               [12] 1183 	mov	r0,a
      00032D 86 82            [24] 1184 	mov	dpl,@r0
      00032F 08               [12] 1185 	inc	r0
      000330 86 83            [24] 1186 	mov	dph,@r0
      000332 08               [12] 1187 	inc	r0
      000333 86 F0            [24] 1188 	mov	b,@r0
      000335 08               [12] 1189 	inc	r0
      000336 E6               [12] 1190 	mov	a,@r0
      000337 12r00r00         [24] 1191 	lcall	__modulong
      00033A AC 82            [24] 1192 	mov	r4,dpl
      00033C 74 30            [12] 1193 	mov	a,#0x30
      00033E 2C               [12] 1194 	add	a,r4
      00033F F5 82            [12] 1195 	mov	dpl,a
      000341 12r00r95         [24] 1196 	lcall	_UartWrite
      000344                       1197 00113$:
                                   1198 ;	uart.h:153: for(i=8;i>0;i--)
      000344 E5*00            [12] 1199 	mov	a,_bp
      000346 24 05            [12] 1200 	add	a,#0x05
      000348 F8               [12] 1201 	mov	r0,a
      000349 16               [12] 1202 	dec	@r0
      00034A E5*00            [12] 1203 	mov	a,_bp
      00034C 24 05            [12] 1204 	add	a,#0x05
      00034E F8               [12] 1205 	mov	r0,a
      00034F E6               [12] 1206 	mov	a,@r0
      000350 60 03            [24] 1207 	jz	00149$
      000352 02r02r82         [24] 1208 	ljmp	00112$
      000355                       1209 00149$:
                                   1210 ;	uart.h:163: }
      000355 85*00 81         [24] 1211 	mov	sp,_bp
      000358 D0*00            [24] 1212 	pop	_bp
      00035A 22               [24] 1213 	ret
                                   1214 ;------------------------------------------------------------
                                   1215 ;Allocation info for local variables in function 'UartScanByte'
                                   1216 ;------------------------------------------------------------
                                   1217 ;unibble                   Allocated to registers r7 
                                   1218 ;lnibble                   Allocated to registers r6 
                                   1219 ;------------------------------------------------------------
                                   1220 ;	uart.h:166: uint8_t UartScanByte() __reentrant
                                   1221 ;	-----------------------------------------
                                   1222 ;	 function UartScanByte
                                   1223 ;	-----------------------------------------
      00035B                       1224 _UartScanByte:
                                   1225 ;	uart.h:170: while(UartReadReady()) UartRead(); //flush
      00035B                       1226 00101$:
      00035B 12r00r81         [24] 1227 	lcall	_UartReadReady
      00035E E5 82            [12] 1228 	mov	a,dpl
      000360 60 05            [24] 1229 	jz	00103$
      000362 12r00r8C         [24] 1230 	lcall	_UartRead
      000365 80 F4            [24] 1231 	sjmp	00101$
      000367                       1232 00103$:
                                   1233 ;	uart.h:171: UartPrint("Number(HEX, eg FE for 254): ");
      000367 90r00r00         [24] 1234 	mov	dptr,#___str_0
      00036A 75 F0 80         [24] 1235 	mov	b,#0x80
      00036D 12r01r1B         [24] 1236 	lcall	_UartPrint
                                   1237 ;	uart.h:173: unibble = UartRead();
      000370 12r00r8C         [24] 1238 	lcall	_UartRead
                                   1239 ;	uart.h:174: UartWrite(unibble);
      000373 AF 82            [24] 1240 	mov  r7,dpl
      000375 C0 07            [24] 1241 	push	ar7
      000377 12r00r95         [24] 1242 	lcall	_UartWrite
                                   1243 ;	uart.h:175: lnibble = UartRead();
      00037A 12r00r8C         [24] 1244 	lcall	_UartRead
                                   1245 ;	uart.h:176: UartWrite(lnibble);
      00037D AE 82            [24] 1246 	mov  r6,dpl
      00037F C0 06            [24] 1247 	push	ar6
      000381 12r00r95         [24] 1248 	lcall	_UartWrite
                                   1249 ;	uart.h:178: UartWrite('\n');
      000384 75 82 0A         [24] 1250 	mov	dpl,#0x0a
      000387 12r00r95         [24] 1251 	lcall	_UartWrite
      00038A D0 06            [24] 1252 	pop	ar6
      00038C D0 07            [24] 1253 	pop	ar7
                                   1254 ;	uart.h:180: return hex2dec(unibble,lnibble);
      00038E 8E*00            [24] 1255 	mov	_hex2dec_PARM_2,r6
      000390 8F 82            [24] 1256 	mov	dpl,r7
                                   1257 ;	uart.h:181: }
      000392 02r00r3A         [24] 1258 	ljmp	_hex2dec
                                   1259 ;------------------------------------------------------------
                                   1260 ;Allocation info for local variables in function 'UartScanLine'
                                   1261 ;------------------------------------------------------------
                                   1262 ;maxLength                 Allocated to stack - _bp -3
                                   1263 ;dst                       Allocated to stack - _bp +1
                                   1264 ;recv                      Allocated to registers r2 
                                   1265 ;count                     Allocated to registers r4 
                                   1266 ;------------------------------------------------------------
                                   1267 ;	uart.h:183: uint8_t UartScanLine(uint8_t *dst, uint8_t maxLength) __reentrant
                                   1268 ;	-----------------------------------------
                                   1269 ;	 function UartScanLine
                                   1270 ;	-----------------------------------------
      000395                       1271 _UartScanLine:
      000395 C0*00            [24] 1272 	push	_bp
      000397 85 81*00         [24] 1273 	mov	_bp,sp
      00039A C0 82            [24] 1274 	push	dpl
      00039C C0 83            [24] 1275 	push	dph
      00039E C0 F0            [24] 1276 	push	b
                                   1277 ;	uart.h:185: uint8_t recv,count=0;
      0003A0 7C 00            [12] 1278 	mov	r4,#0x00
                                   1279 ;	uart.h:187: while(UartReadReady()) UartRead(); //flush
      0003A2                       1280 00101$:
      0003A2 C0 04            [24] 1281 	push	ar4
      0003A4 12r00r81         [24] 1282 	lcall	_UartReadReady
      0003A7 E5 82            [12] 1283 	mov	a,dpl
      0003A9 D0 04            [24] 1284 	pop	ar4
      0003AB 60 09            [24] 1285 	jz	00118$
      0003AD C0 04            [24] 1286 	push	ar4
      0003AF 12r00r8C         [24] 1287 	lcall	_UartRead
      0003B2 D0 04            [24] 1288 	pop	ar4
                                   1289 ;	uart.h:189: while(1)
      0003B4 80 EC            [24] 1290 	sjmp	00101$
      0003B6                       1291 00118$:
      0003B6 7B 00            [12] 1292 	mov	r3,#0x00
      0003B8                       1293 00110$:
                                   1294 ;	uart.h:192: recv=UartRead();
      0003B8 C0 04            [24] 1295 	push	ar4
      0003BA C0 03            [24] 1296 	push	ar3
      0003BC 12r00r8C         [24] 1297 	lcall	_UartRead
                                   1298 ;	uart.h:193: UartWrite(recv);
      0003BF AA 82            [24] 1299 	mov  r2,dpl
      0003C1 C0 02            [24] 1300 	push	ar2
      0003C3 12r00r95         [24] 1301 	lcall	_UartWrite
      0003C6 D0 02            [24] 1302 	pop	ar2
      0003C8 D0 03            [24] 1303 	pop	ar3
      0003CA D0 04            [24] 1304 	pop	ar4
                                   1305 ;	uart.h:194: if(recv == '\n') 
      0003CC BA 0A 19         [24] 1306 	cjne	r2,#0x0a,00105$
                                   1307 ;	uart.h:196: *(dst+count)=0; //add string terminate
      0003CF A8*00            [24] 1308 	mov	r0,_bp
      0003D1 08               [12] 1309 	inc	r0
      0003D2 EC               [12] 1310 	mov	a,r4
      0003D3 26               [12] 1311 	add	a,@r0
      0003D4 FD               [12] 1312 	mov	r5,a
      0003D5 E4               [12] 1313 	clr	a
      0003D6 08               [12] 1314 	inc	r0
      0003D7 36               [12] 1315 	addc	a,@r0
      0003D8 FE               [12] 1316 	mov	r6,a
      0003D9 08               [12] 1317 	inc	r0
      0003DA 86 07            [24] 1318 	mov	ar7,@r0
      0003DC 8D 82            [24] 1319 	mov	dpl,r5
      0003DE 8E 83            [24] 1320 	mov	dph,r6
      0003E0 8F F0            [24] 1321 	mov	b,r7
      0003E2 E4               [12] 1322 	clr	a
      0003E3 12r00r00         [24] 1323 	lcall	__gptrput
                                   1324 ;	uart.h:197: break;
      0003E6 80 31            [24] 1325 	sjmp	00111$
      0003E8                       1326 00105$:
                                   1327 ;	uart.h:199: else *(dst+count)=recv;
      0003E8 A8*00            [24] 1328 	mov	r0,_bp
      0003EA 08               [12] 1329 	inc	r0
      0003EB EB               [12] 1330 	mov	a,r3
      0003EC 26               [12] 1331 	add	a,@r0
      0003ED FD               [12] 1332 	mov	r5,a
      0003EE E4               [12] 1333 	clr	a
      0003EF 08               [12] 1334 	inc	r0
      0003F0 36               [12] 1335 	addc	a,@r0
      0003F1 FE               [12] 1336 	mov	r6,a
      0003F2 08               [12] 1337 	inc	r0
      0003F3 86 07            [24] 1338 	mov	ar7,@r0
      0003F5 8D 82            [24] 1339 	mov	dpl,r5
      0003F7 8E 83            [24] 1340 	mov	dph,r6
      0003F9 8F F0            [24] 1341 	mov	b,r7
      0003FB EA               [12] 1342 	mov	a,r2
      0003FC 12r00r00         [24] 1343 	lcall	__gptrput
                                   1344 ;	uart.h:201: if(count==maxLength) 
      0003FF E5*00            [12] 1345 	mov	a,_bp
      000401 24 FD            [12] 1346 	add	a,#0xfd
      000403 F8               [12] 1347 	mov	r0,a
      000404 E6               [12] 1348 	mov	a,@r0
      000405 B5 03 0C         [24] 1349 	cjne	a,ar3,00108$
                                   1350 ;	uart.h:203: *(dst+count)=0; // terminate string.
      000408 8D 82            [24] 1351 	mov	dpl,r5
      00040A 8E 83            [24] 1352 	mov	dph,r6
      00040C 8F F0            [24] 1353 	mov	b,r7
      00040E E4               [12] 1354 	clr	a
      00040F 12r00r00         [24] 1355 	lcall	__gptrput
                                   1356 ;	uart.h:204: break;
      000412 80 05            [24] 1357 	sjmp	00111$
      000414                       1358 00108$:
                                   1359 ;	uart.h:207: count++;
      000414 0B               [12] 1360 	inc	r3
      000415 8B 04            [24] 1361 	mov	ar4,r3
      000417 80 9F            [24] 1362 	sjmp	00110$
      000419                       1363 00111$:
                                   1364 ;	uart.h:211: return count;
      000419 8C 82            [24] 1365 	mov	dpl,r4
                                   1366 ;	uart.h:213: }
      00041B 85*00 81         [24] 1367 	mov	sp,_bp
      00041E D0*00            [24] 1368 	pop	_bp
      000420 22               [24] 1369 	ret
                                   1370 ;------------------------------------------------------------
                                   1371 ;Allocation info for local variables in function 'spi_delay'
                                   1372 ;------------------------------------------------------------
                                   1373 ;ms                        Allocated to registers r6 r7 
                                   1374 ;j                         Allocated to registers r4 r5 
                                   1375 ;i                         Allocated to registers r2 r3 
                                   1376 ;------------------------------------------------------------
                                   1377 ;	spi.h:1: void spi_delay(unsigned int ms)
                                   1378 ;	-----------------------------------------
                                   1379 ;	 function spi_delay
                                   1380 ;	-----------------------------------------
      000421                       1381 _spi_delay:
      000421 AE 82            [24] 1382 	mov	r6,dpl
      000423 AF 83            [24] 1383 	mov	r7,dph
                                   1384 ;	spi.h:3: unsigned int j=0,i=0;
      000425 7C 00            [12] 1385 	mov	r4,#0x00
      000427 7D 00            [12] 1386 	mov	r5,#0x00
                                   1387 ;	spi.h:4: for( i=0;i<ms;i++)
      000429 7A 00            [12] 1388 	mov	r2,#0x00
      00042B 7B 00            [12] 1389 	mov	r3,#0x00
      00042D                       1390 00107$:
      00042D C3               [12] 1391 	clr	c
      00042E EA               [12] 1392 	mov	a,r2
      00042F 9E               [12] 1393 	subb	a,r6
      000430 EB               [12] 1394 	mov	a,r3
      000431 9F               [12] 1395 	subb	a,r7
      000432 50 1F            [24] 1396 	jnc	00109$
      000434 8C 00            [24] 1397 	mov	ar0,r4
      000436 8D 01            [24] 1398 	mov	ar1,r5
      000438                       1399 00104$:
                                   1400 ;	spi.h:6: for(;j<120;j++);
      000438 C3               [12] 1401 	clr	c
      000439 E8               [12] 1402 	mov	a,r0
      00043A 94 78            [12] 1403 	subb	a,#0x78
      00043C E9               [12] 1404 	mov	a,r1
      00043D 94 00            [12] 1405 	subb	a,#0x00
      00043F 50 07            [24] 1406 	jnc	00114$
      000441 08               [12] 1407 	inc	r0
      000442 B8 00 F3         [24] 1408 	cjne	r0,#0x00,00104$
      000445 09               [12] 1409 	inc	r1
      000446 80 F0            [24] 1410 	sjmp	00104$
      000448                       1411 00114$:
      000448 88 04            [24] 1412 	mov	ar4,r0
      00044A 89 05            [24] 1413 	mov	ar5,r1
                                   1414 ;	spi.h:4: for( i=0;i<ms;i++)
      00044C 0A               [12] 1415 	inc	r2
      00044D BA 00 DD         [24] 1416 	cjne	r2,#0x00,00107$
      000450 0B               [12] 1417 	inc	r3
      000451 80 DA            [24] 1418 	sjmp	00107$
      000453                       1419 00109$:
                                   1420 ;	spi.h:8: }
      000453 22               [24] 1421 	ret
                                   1422 ;------------------------------------------------------------
                                   1423 ;Allocation info for local variables in function 'spi_init'
                                   1424 ;------------------------------------------------------------
                                   1425 ;	spi.h:32: void spi_init()
                                   1426 ;	-----------------------------------------
                                   1427 ;	 function spi_init
                                   1428 ;	-----------------------------------------
      000454                       1429 _spi_init:
                                   1430 ;	spi.h:35: spi_miso_high(); //make MISO input
      000454 43 90 04         [24] 1431 	orl	_P1,#0x04
                                   1432 ;	spi.h:36: spi_mosi_high(); //recommended in sd card tutorial
      000457 43 90 02         [24] 1433 	orl	_P1,#0x02
                                   1434 ;	spi.h:37: spi_cs_high(); //deselect
      00045A 43 90 08         [24] 1435 	orl	_P1,#0x08
                                   1436 ;	spi.h:38: spi_clk_low(); //mode 0, idle clk is low
      00045D 53 90 FE         [24] 1437 	anl	_P1,#0xfe
                                   1438 ;	spi.h:39: }
      000460 22               [24] 1439 	ret
                                   1440 ;------------------------------------------------------------
                                   1441 ;Allocation info for local variables in function 'spi_transfer'
                                   1442 ;------------------------------------------------------------
                                   1443 ;handle_cs                 Allocated with name '_spi_transfer_PARM_2'
                                   1444 ;tx                        Allocated to registers r7 
                                   1445 ;rx                        Allocated to registers r6 
                                   1446 ;i                         Allocated to registers r5 
                                   1447 ;------------------------------------------------------------
                                   1448 ;	spi.h:41: uint8_t spi_transfer(uint8_t tx,uint8_t handle_cs)
                                   1449 ;	-----------------------------------------
                                   1450 ;	 function spi_transfer
                                   1451 ;	-----------------------------------------
      000461                       1452 _spi_transfer:
      000461 AF 82            [24] 1453 	mov	r7,dpl
                                   1454 ;	spi.h:44: rx=0; //clear the rx - sdcc compiler throws warning otherwise
      000463 7E 00            [12] 1455 	mov	r6,#0x00
                                   1456 ;	spi.h:47: spi_clk_low();
      000465 53 90 FE         [24] 1457 	anl	_P1,#0xfe
                                   1458 ;	spi.h:50: if(handle_cs)
      000468 E5*00            [12] 1459 	mov	a,_spi_transfer_PARM_2
      00046A 60 03            [24] 1460 	jz	00139$
                                   1461 ;	spi.h:51: spi_cs_low();
      00046C 53 90 F7         [24] 1462 	anl	_P1,#0xf7
                                   1463 ;	spi.h:54: for(i=0;i<8;i++)
      00046F                       1464 00139$:
      00046F 7D 00            [12] 1465 	mov	r5,#0x00
      000471                       1466 00132$:
                                   1467 ;	spi.h:57: if(tx & 0x80) spi_mosi_high();
      000471 EF               [12] 1468 	mov	a,r7
      000472 30 E7 05         [24] 1469 	jnb	acc.7,00112$
      000475 43 90 02         [24] 1470 	orl	_P1,#0x02
                                   1471 ;	spi.h:58: else spi_mosi_low();
      000478 80 03            [24] 1472 	sjmp	00117$
      00047A                       1473 00112$:
      00047A 53 90 FD         [24] 1474 	anl	_P1,#0xfd
      00047D                       1475 00117$:
                                   1476 ;	spi.h:60: tx <<=1;
      00047D 8F 04            [24] 1477 	mov	ar4,r7
      00047F EC               [12] 1478 	mov	a,r4
      000480 2C               [12] 1479 	add	a,r4
      000481 FF               [12] 1480 	mov	r7,a
                                   1481 ;	spi.h:65: rx <<=1;
      000482 8E 04            [24] 1482 	mov	ar4,r6
      000484 EC               [12] 1483 	mov	a,r4
      000485 2C               [12] 1484 	add	a,r4
      000486 FE               [12] 1485 	mov	r6,a
                                   1486 ;	spi.h:68: spi_clk_high();
      000487 43 90 01         [24] 1487 	orl	_P1,#0x01
                                   1488 ;	spi.h:71: if(spi_read_miso()) rx |=1;
      00048A E5 90            [12] 1489 	mov	a,_P1
      00048C 30 E2 03         [24] 1490 	jnb	acc.2,00123$
      00048F 43 06 01         [24] 1491 	orl	ar6,#0x01
                                   1492 ;	spi.h:76: spi_clk_low();
      000492                       1493 00123$:
      000492 53 90 FE         [24] 1494 	anl	_P1,#0xfe
                                   1495 ;	spi.h:54: for(i=0;i<8;i++)
      000495 0D               [12] 1496 	inc	r5
      000496 BD 08 00         [24] 1497 	cjne	r5,#0x08,00164$
      000499                       1498 00164$:
      000499 40 D6            [24] 1499 	jc	00132$
                                   1500 ;	spi.h:81: if(handle_cs)
      00049B E5*00            [12] 1501 	mov	a,_spi_transfer_PARM_2
      00049D 60 03            [24] 1502 	jz	00131$
                                   1503 ;	spi.h:82: spi_cs_high();
      00049F 43 90 08         [24] 1504 	orl	_P1,#0x08
      0004A2                       1505 00131$:
                                   1506 ;	spi.h:84: return rx;
      0004A2 8E 82            [24] 1507 	mov	dpl,r6
                                   1508 ;	spi.h:85: }
      0004A4 22               [24] 1509 	ret
                                   1510 ;------------------------------------------------------------
                                   1511 ;Allocation info for local variables in function 'spi_transfer_all'
                                   1512 ;------------------------------------------------------------
                                   1513 ;len                       Allocated with name '_spi_transfer_all_PARM_2'
                                   1514 ;handle_cs                 Allocated with name '_spi_transfer_all_PARM_3'
                                   1515 ;buff                      Allocated to registers r5 r6 r7 
                                   1516 ;i                         Allocated to registers r4 
                                   1517 ;------------------------------------------------------------
                                   1518 ;	spi.h:89: void spi_transfer_all(uint8_t *buff, uint8_t len,uint8_t handle_cs)
                                   1519 ;	-----------------------------------------
                                   1520 ;	 function spi_transfer_all
                                   1521 ;	-----------------------------------------
      0004A5                       1522 _spi_transfer_all:
      0004A5 AD 82            [24] 1523 	mov	r5,dpl
      0004A7 AE 83            [24] 1524 	mov	r6,dph
      0004A9 AF F0            [24] 1525 	mov	r7,b
                                   1526 ;	spi.h:94: if(handle_cs)spi_cs_low();
      0004AB E5*04            [12] 1527 	mov	a,_spi_transfer_all_PARM_3
      0004AD 60 03            [24] 1528 	jz	00119$
      0004AF 53 90 F7         [24] 1529 	anl	_P1,#0xf7
                                   1530 ;	spi.h:96: for(i=0;i<len;i++)
      0004B2                       1531 00119$:
      0004B2 7C 00            [12] 1532 	mov	r4,#0x00
      0004B4                       1533 00113$:
      0004B4 C3               [12] 1534 	clr	c
      0004B5 EC               [12] 1535 	mov	a,r4
      0004B6 95*03            [12] 1536 	subb	a,_spi_transfer_all_PARM_2
      0004B8 50 2D            [24] 1537 	jnc	00106$
                                   1538 ;	spi.h:98: spi_transfer(buff[i],0);
      0004BA EC               [12] 1539 	mov	a,r4
      0004BB 2D               [12] 1540 	add	a,r5
      0004BC F9               [12] 1541 	mov	r1,a
      0004BD E4               [12] 1542 	clr	a
      0004BE 3E               [12] 1543 	addc	a,r6
      0004BF FA               [12] 1544 	mov	r2,a
      0004C0 8F 03            [24] 1545 	mov	ar3,r7
      0004C2 89 82            [24] 1546 	mov	dpl,r1
      0004C4 8A 83            [24] 1547 	mov	dph,r2
      0004C6 8B F0            [24] 1548 	mov	b,r3
      0004C8 12r00r00         [24] 1549 	lcall	__gptrget
      0004CB F9               [12] 1550 	mov	r1,a
      0004CC 75*00 00         [24] 1551 	mov	_spi_transfer_PARM_2,#0x00
      0004CF 89 82            [24] 1552 	mov	dpl,r1
      0004D1 C0 07            [24] 1553 	push	ar7
      0004D3 C0 06            [24] 1554 	push	ar6
      0004D5 C0 05            [24] 1555 	push	ar5
      0004D7 C0 04            [24] 1556 	push	ar4
      0004D9 12r04r61         [24] 1557 	lcall	_spi_transfer
      0004DC D0 04            [24] 1558 	pop	ar4
      0004DE D0 05            [24] 1559 	pop	ar5
      0004E0 D0 06            [24] 1560 	pop	ar6
      0004E2 D0 07            [24] 1561 	pop	ar7
                                   1562 ;	spi.h:96: for(i=0;i<len;i++)
      0004E4 0C               [12] 1563 	inc	r4
      0004E5 80 CD            [24] 1564 	sjmp	00113$
      0004E7                       1565 00106$:
                                   1566 ;	spi.h:102: if(handle_cs)spi_cs_high();
      0004E7 E5*04            [12] 1567 	mov	a,_spi_transfer_all_PARM_3
      0004E9 60 03            [24] 1568 	jz	00115$
      0004EB 43 90 08         [24] 1569 	orl	_P1,#0x08
      0004EE                       1570 00115$:
                                   1571 ;	spi.h:104: }
      0004EE 22               [24] 1572 	ret
                                   1573 ;------------------------------------------------------------
                                   1574 ;Allocation info for local variables in function 'sd_isbusy'
                                   1575 ;------------------------------------------------------------
                                   1576 ;i                         Allocated to registers r7 
                                   1577 ;------------------------------------------------------------
                                   1578 ;	sdcard.h:26: uint8_t sd_isbusy()
                                   1579 ;	-----------------------------------------
                                   1580 ;	 function sd_isbusy
                                   1581 ;	-----------------------------------------
      0004EF                       1582 _sd_isbusy:
                                   1583 ;	sdcard.h:29: for(i=0;i<254;i++) //could have been anything(100/200/etc.)
      0004EF 7F 00            [12] 1584 	mov	r7,#0x00
      0004F1                       1585 00104$:
                                   1586 ;	sdcard.h:31: if(sd_spi_write(0xff)==0xff) return 0; //not busy
      0004F1 75*00 00         [24] 1587 	mov	_spi_transfer_PARM_2,#0x00
      0004F4 75 82 FF         [24] 1588 	mov	dpl,#0xff
      0004F7 C0 07            [24] 1589 	push	ar7
      0004F9 12r04r61         [24] 1590 	lcall	_spi_transfer
      0004FC AE 82            [24] 1591 	mov	r6,dpl
      0004FE D0 07            [24] 1592 	pop	ar7
      000500 BE FF 04         [24] 1593 	cjne	r6,#0xff,00105$
      000503 75 82 00         [24] 1594 	mov	dpl,#0x00
      000506 22               [24] 1595 	ret
      000507                       1596 00105$:
                                   1597 ;	sdcard.h:29: for(i=0;i<254;i++) //could have been anything(100/200/etc.)
      000507 0F               [12] 1598 	inc	r7
      000508 BF FE 00         [24] 1599 	cjne	r7,#0xfe,00122$
      00050B                       1600 00122$:
      00050B 40 E4            [24] 1601 	jc	00104$
                                   1602 ;	sdcard.h:34: return 1; //busy
      00050D 75 82 01         [24] 1603 	mov	dpl,#0x01
                                   1604 ;	sdcard.h:35: }
      000510 22               [24] 1605 	ret
                                   1606 ;------------------------------------------------------------
                                   1607 ;Allocation info for local variables in function 'sd_initial_clk'
                                   1608 ;------------------------------------------------------------
                                   1609 ;i                         Allocated to registers r7 
                                   1610 ;------------------------------------------------------------
                                   1611 ;	sdcard.h:37: void sd_initial_clk()
                                   1612 ;	-----------------------------------------
                                   1613 ;	 function sd_initial_clk
                                   1614 ;	-----------------------------------------
      000511                       1615 _sd_initial_clk:
                                   1616 ;	sdcard.h:45: spi_cs_high(); // required by spec but works fine even when cs pin of SDCARD is always pulled to ground to save uC pins
      000511 43 90 08         [24] 1617 	orl	_P1,#0x08
                                   1618 ;	sdcard.h:46: for(uint8_t i=0;i<10;i++)spi_transfer(0xff,0);
      000514 7F 00            [12] 1619 	mov	r7,#0x00
      000516                       1620 00106$:
      000516 BF 0A 00         [24] 1621 	cjne	r7,#0x0a,00119$
      000519                       1622 00119$:
      000519 50 10            [24] 1623 	jnc	00108$
      00051B 75*00 00         [24] 1624 	mov	_spi_transfer_PARM_2,#0x00
      00051E 75 82 FF         [24] 1625 	mov	dpl,#0xff
      000521 C0 07            [24] 1626 	push	ar7
      000523 12r04r61         [24] 1627 	lcall	_spi_transfer
      000526 D0 07            [24] 1628 	pop	ar7
      000528 0F               [12] 1629 	inc	r7
      000529 80 EB            [24] 1630 	sjmp	00106$
      00052B                       1631 00108$:
                                   1632 ;	sdcard.h:47: }
      00052B 22               [24] 1633 	ret
                                   1634 ;------------------------------------------------------------
                                   1635 ;Allocation info for local variables in function 'sd_cmd'
                                   1636 ;------------------------------------------------------------
                                   1637 ;arg                       Allocated with name '_sd_cmd_PARM_2'
                                   1638 ;cmd                       Allocated to registers r7 
                                   1639 ;_resp                     Allocated to registers r5 
                                   1640 ;retries                   Allocated to registers r6 
                                   1641 ;crc                       Allocated to registers r6 
                                   1642 ;i                         Allocated to registers r6 
                                   1643 ;i                         Allocated to registers r7 
                                   1644 ;------------------------------------------------------------
                                   1645 ;	sdcard.h:49: uint8_t sd_cmd(uint8_t cmd, uint32_t arg)
                                   1646 ;	-----------------------------------------
                                   1647 ;	 function sd_cmd
                                   1648 ;	-----------------------------------------
      00052C                       1649 _sd_cmd:
      00052C AF 82            [24] 1650 	mov	r7,dpl
                                   1651 ;	sdcard.h:51: uint8_t _resp=0,retries=0,crc=0xff;
      00052E 7E FF            [12] 1652 	mov	r6,#0xff
                                   1653 ;	sdcard.h:53: spi_cs_low();
      000530 53 90 F7         [24] 1654 	anl	_P1,#0xf7
                                   1655 ;	sdcard.h:55: sd_isbusy(); //wait while sd is busy
      000533 C0 07            [24] 1656 	push	ar7
      000535 C0 06            [24] 1657 	push	ar6
      000537 12r04rEF         [24] 1658 	lcall	_sd_isbusy
      00053A D0 06            [24] 1659 	pop	ar6
      00053C D0 07            [24] 1660 	pop	ar7
                                   1661 ;	sdcard.h:63: sd_spi_write(cmd | 0x40);
      00053E 74 40            [12] 1662 	mov	a,#0x40
      000540 4F               [12] 1663 	orl	a,r7
      000541 F5 82            [12] 1664 	mov	dpl,a
      000543 75*00 00         [24] 1665 	mov	_spi_transfer_PARM_2,#0x00
      000546 C0 07            [24] 1666 	push	ar7
      000548 C0 06            [24] 1667 	push	ar6
      00054A 12r04r61         [24] 1668 	lcall	_spi_transfer
      00054D D0 06            [24] 1669 	pop	ar6
      00054F D0 07            [24] 1670 	pop	ar7
                                   1671 ;	sdcard.h:65: sd_spi_write((arg >> 24) & 0xff);
      000551 85*08 82         [24] 1672 	mov	dpl,(_sd_cmd_PARM_2 + 3)
      000554 75*00 00         [24] 1673 	mov	_spi_transfer_PARM_2,#0x00
      000557 C0 07            [24] 1674 	push	ar7
      000559 C0 06            [24] 1675 	push	ar6
      00055B 12r04r61         [24] 1676 	lcall	_spi_transfer
      00055E D0 06            [24] 1677 	pop	ar6
      000560 D0 07            [24] 1678 	pop	ar7
                                   1679 ;	sdcard.h:66: sd_spi_write((arg >> 16) & 0xff);
      000562 85*07 82         [24] 1680 	mov	dpl,(_sd_cmd_PARM_2 + 2)
      000565 75*00 00         [24] 1681 	mov	_spi_transfer_PARM_2,#0x00
      000568 C0 07            [24] 1682 	push	ar7
      00056A C0 06            [24] 1683 	push	ar6
      00056C 12r04r61         [24] 1684 	lcall	_spi_transfer
      00056F D0 06            [24] 1685 	pop	ar6
      000571 D0 07            [24] 1686 	pop	ar7
                                   1687 ;	sdcard.h:67: sd_spi_write((arg >> 8) & 0xff);
      000573 85*06 82         [24] 1688 	mov	dpl,(_sd_cmd_PARM_2 + 1)
      000576 75*00 00         [24] 1689 	mov	_spi_transfer_PARM_2,#0x00
      000579 C0 07            [24] 1690 	push	ar7
      00057B C0 06            [24] 1691 	push	ar6
      00057D 12r04r61         [24] 1692 	lcall	_spi_transfer
      000580 D0 06            [24] 1693 	pop	ar6
      000582 D0 07            [24] 1694 	pop	ar7
                                   1695 ;	sdcard.h:68: sd_spi_write(arg & 0xff);
      000584 85*05 82         [24] 1696 	mov	dpl,_sd_cmd_PARM_2
      000587 75*00 00         [24] 1697 	mov	_spi_transfer_PARM_2,#0x00
      00058A C0 07            [24] 1698 	push	ar7
      00058C C0 06            [24] 1699 	push	ar6
      00058E 12r04r61         [24] 1700 	lcall	_spi_transfer
      000591 D0 06            [24] 1701 	pop	ar6
      000593 D0 07            [24] 1702 	pop	ar7
                                   1703 ;	sdcard.h:70: if(cmd==CMD0) 
      000595 EF               [12] 1704 	mov	a,r7
      000596 70 04            [24] 1705 	jnz	00107$
                                   1706 ;	sdcard.h:72: crc=0x95;
      000598 7E 95            [12] 1707 	mov	r6,#0x95
      00059A 80 05            [24] 1708 	sjmp	00108$
      00059C                       1709 00107$:
                                   1710 ;	sdcard.h:74: else if(cmd==CMD8) 
      00059C BF 08 02         [24] 1711 	cjne	r7,#0x08,00108$
                                   1712 ;	sdcard.h:76: crc=0x87;
      00059F 7E 87            [12] 1713 	mov	r6,#0x87
      0005A1                       1714 00108$:
                                   1715 ;	sdcard.h:78: sd_spi_write(crc);	
      0005A1 75*00 00         [24] 1716 	mov	_spi_transfer_PARM_2,#0x00
      0005A4 8E 82            [24] 1717 	mov	dpl,r6
      0005A6 C0 07            [24] 1718 	push	ar7
      0005A8 12r04r61         [24] 1719 	lcall	_spi_transfer
      0005AB D0 07            [24] 1720 	pop	ar7
                                   1721 ;	sdcard.h:81: while(1) 
      0005AD 7E 00            [12] 1722 	mov	r6,#0x00
      0005AF                       1723 00115$:
                                   1724 ;	sdcard.h:83: _resp = sd_spi_write(0xff);
      0005AF 75*00 00         [24] 1725 	mov	_spi_transfer_PARM_2,#0x00
      0005B2 75 82 FF         [24] 1726 	mov	dpl,#0xff
      0005B5 C0 07            [24] 1727 	push	ar7
      0005B7 C0 06            [24] 1728 	push	ar6
      0005B9 12r04r61         [24] 1729 	lcall	_spi_transfer
      0005BC AD 82            [24] 1730 	mov	r5,dpl
      0005BE D0 06            [24] 1731 	pop	ar6
      0005C0 D0 07            [24] 1732 	pop	ar7
                                   1733 ;	sdcard.h:85: if(_resp & 0x80);
      0005C2 ED               [12] 1734 	mov	a,r5
      0005C3 30 E7 0A         [24] 1735 	jnb	acc.7,00116$
                                   1736 ;	sdcard.h:88: if(retries++ == SD_MAX_RETRIES) 
      0005C6 8E 04            [24] 1737 	mov	ar4,r6
      0005C8 0E               [12] 1738 	inc	r6
      0005C9 BC 19 E3         [24] 1739 	cjne	r4,#0x19,00115$
                                   1740 ;	sdcard.h:94: return SD_MAX_RETRIES_FAIL; // 0xff means failed
      0005CC 75 82 FE         [24] 1741 	mov	dpl,#0xfe
      0005CF 22               [24] 1742 	ret
      0005D0                       1743 00116$:
                                   1744 ;	sdcard.h:106: if(cmd==CMD8 || cmd==CMD58)
      0005D0 E4               [12] 1745 	clr	a
      0005D1 BF 08 01         [24] 1746 	cjne	r7,#0x08,00203$
      0005D4 04               [12] 1747 	inc	a
      0005D5                       1748 00203$:
      0005D5 FE               [12] 1749 	mov	r6,a
      0005D6 70 08            [24] 1750 	jnz	00128$
      0005D8 BF 3A 02         [24] 1751 	cjne	r7,#0x3a,00206$
      0005DB 80 03            [24] 1752 	sjmp	00207$
      0005DD                       1753 00206$:
      0005DD 02r06r59         [24] 1754 	ljmp	00129$
      0005E0                       1755 00207$:
      0005E0                       1756 00128$:
                                   1757 ;	sdcard.h:114: if(cmd==CMD8)
      0005E0 EE               [12] 1758 	mov	a,r6
      0005E1 60 33            [24] 1759 	jz	00126$
                                   1760 ;	sdcard.h:116: for(uint8_t i=0;i<3;i++) sd_spi_write(0xff);//waste the 3 bytes
      0005E3 7E 00            [12] 1761 	mov	r6,#0x00
      0005E5                       1762 00132$:
      0005E5 BE 03 00         [24] 1763 	cjne	r6,#0x03,00209$
      0005E8                       1764 00209$:
      0005E8 50 14            [24] 1765 	jnc	00117$
      0005EA 75*00 00         [24] 1766 	mov	_spi_transfer_PARM_2,#0x00
      0005ED 75 82 FF         [24] 1767 	mov	dpl,#0xff
      0005F0 C0 06            [24] 1768 	push	ar6
      0005F2 C0 05            [24] 1769 	push	ar5
      0005F4 12r04r61         [24] 1770 	lcall	_spi_transfer
      0005F7 D0 05            [24] 1771 	pop	ar5
      0005F9 D0 06            [24] 1772 	pop	ar6
      0005FB 0E               [12] 1773 	inc	r6
      0005FC 80 E7            [24] 1774 	sjmp	00132$
      0005FE                       1775 00117$:
                                   1776 ;	sdcard.h:117: if(sd_spi_write(0xff)!=0xAA) return SD_CMD_FAIL;
      0005FE 75*00 00         [24] 1777 	mov	_spi_transfer_PARM_2,#0x00
      000601 75 82 FF         [24] 1778 	mov	dpl,#0xff
      000604 C0 05            [24] 1779 	push	ar5
      000606 12r04r61         [24] 1780 	lcall	_spi_transfer
      000609 AE 82            [24] 1781 	mov	r6,dpl
      00060B D0 05            [24] 1782 	pop	ar5
      00060D BE AA 02         [24] 1783 	cjne	r6,#0xaa,00211$
      000610 80 3A            [24] 1784 	sjmp	00127$
      000612                       1785 00211$:
      000612 75 82 FF         [24] 1786 	mov	dpl,#0xff
      000615 22               [24] 1787 	ret
      000616                       1788 00126$:
                                   1789 ;	sdcard.h:119: else if(cmd==CMD58)
      000616 BF 3A 33         [24] 1790 	cjne	r7,#0x3a,00127$
                                   1791 ;	sdcard.h:121: if(sd_spi_write(0xff)!=0xC0) return SD_CMD_FAIL;
      000619 75*00 00         [24] 1792 	mov	_spi_transfer_PARM_2,#0x00
      00061C 75 82 FF         [24] 1793 	mov	dpl,#0xff
      00061F C0 05            [24] 1794 	push	ar5
      000621 12r04r61         [24] 1795 	lcall	_spi_transfer
      000624 AF 82            [24] 1796 	mov	r7,dpl
      000626 D0 05            [24] 1797 	pop	ar5
      000628 BF C0 02         [24] 1798 	cjne	r7,#0xc0,00214$
      00062B 80 04            [24] 1799 	sjmp	00152$
      00062D                       1800 00214$:
      00062D 75 82 FF         [24] 1801 	mov	dpl,#0xff
                                   1802 ;	sdcard.h:123: for(uint8_t i=0;i<3;i++) sd_spi_write(0xff);//waste the 3 bytes
      000630 22               [24] 1803 	ret
      000631                       1804 00152$:
      000631 7F 00            [12] 1805 	mov	r7,#0x00
      000633                       1806 00135$:
      000633 BF 03 00         [24] 1807 	cjne	r7,#0x03,00215$
      000636                       1808 00215$:
      000636 50 14            [24] 1809 	jnc	00127$
      000638 75*00 00         [24] 1810 	mov	_spi_transfer_PARM_2,#0x00
      00063B 75 82 FF         [24] 1811 	mov	dpl,#0xff
      00063E C0 07            [24] 1812 	push	ar7
      000640 C0 05            [24] 1813 	push	ar5
      000642 12r04r61         [24] 1814 	lcall	_spi_transfer
      000645 D0 05            [24] 1815 	pop	ar5
      000647 D0 07            [24] 1816 	pop	ar7
      000649 0F               [12] 1817 	inc	r7
      00064A 80 E7            [24] 1818 	sjmp	00135$
      00064C                       1819 00127$:
                                   1820 ;	sdcard.h:128: sd_spi_write(0xff);
      00064C 75*00 00         [24] 1821 	mov	_spi_transfer_PARM_2,#0x00
      00064F 75 82 FF         [24] 1822 	mov	dpl,#0xff
      000652 C0 05            [24] 1823 	push	ar5
      000654 12r04r61         [24] 1824 	lcall	_spi_transfer
      000657 D0 05            [24] 1825 	pop	ar5
      000659                       1826 00129$:
                                   1827 ;	sdcard.h:136: return _resp;
      000659 8D 82            [24] 1828 	mov	dpl,r5
                                   1829 ;	sdcard.h:138: }
      00065B 22               [24] 1830 	ret
                                   1831 ;------------------------------------------------------------
                                   1832 ;Allocation info for local variables in function 'sd_acmd'
                                   1833 ;------------------------------------------------------------
                                   1834 ;arg                       Allocated with name '_sd_acmd_PARM_2'
                                   1835 ;cmd                       Allocated to registers r7 
                                   1836 ;_resp                     Allocated to registers 
                                   1837 ;------------------------------------------------------------
                                   1838 ;	sdcard.h:140: uint8_t sd_acmd(uint8_t cmd, uint32_t arg)
                                   1839 ;	-----------------------------------------
                                   1840 ;	 function sd_acmd
                                   1841 ;	-----------------------------------------
      00065C                       1842 _sd_acmd:
      00065C AF 82            [24] 1843 	mov	r7,dpl
                                   1844 ;	sdcard.h:144: _resp=sd_cmd(CMD55,0);
      00065E E4               [12] 1845 	clr	a
      00065F F5*05            [12] 1846 	mov	_sd_cmd_PARM_2,a
      000661 F5*06            [12] 1847 	mov	(_sd_cmd_PARM_2 + 1),a
      000663 F5*07            [12] 1848 	mov	(_sd_cmd_PARM_2 + 2),a
      000665 F5*08            [12] 1849 	mov	(_sd_cmd_PARM_2 + 3),a
      000667 75 82 37         [24] 1850 	mov	dpl,#0x37
      00066A C0 07            [24] 1851 	push	ar7
      00066C 12r05r2C         [24] 1852 	lcall	_sd_cmd
      00066F AE 82            [24] 1853 	mov	r6,dpl
      000671 D0 07            [24] 1854 	pop	ar7
                                   1855 ;	sdcard.h:145: if(_resp!=1) return SD_CMD_FAIL;
      000673 BE 01 02         [24] 1856 	cjne	r6,#0x01,00110$
      000676 80 04            [24] 1857 	sjmp	00102$
      000678                       1858 00110$:
      000678 75 82 FF         [24] 1859 	mov	dpl,#0xff
      00067B 22               [24] 1860 	ret
      00067C                       1861 00102$:
                                   1862 ;	sdcard.h:148: _resp=sd_cmd(cmd,arg);
      00067C 85*09*05         [24] 1863 	mov	_sd_cmd_PARM_2,_sd_acmd_PARM_2
      00067F 85*0A*06         [24] 1864 	mov	(_sd_cmd_PARM_2 + 1),(_sd_acmd_PARM_2 + 1)
      000682 85*0B*07         [24] 1865 	mov	(_sd_cmd_PARM_2 + 2),(_sd_acmd_PARM_2 + 2)
      000685 85*0C*08         [24] 1866 	mov	(_sd_cmd_PARM_2 + 3),(_sd_acmd_PARM_2 + 3)
      000688 8F 82            [24] 1867 	mov	dpl,r7
                                   1868 ;	sdcard.h:149: return _resp;
                                   1869 ;	sdcard.h:151: }
      00068A 02r05r2C         [24] 1870 	ljmp	_sd_cmd
                                   1871 ;------------------------------------------------------------
                                   1872 ;Allocation info for local variables in function 'SDinit'
                                   1873 ;------------------------------------------------------------
                                   1874 ;retries                   Allocated to registers r7 
                                   1875 ;------------------------------------------------------------
                                   1876 ;	sdcard.h:157: uint8_t SDinit()
                                   1877 ;	-----------------------------------------
                                   1878 ;	 function SDinit
                                   1879 ;	-----------------------------------------
      00068D                       1880 _SDinit:
                                   1881 ;	sdcard.h:161: sd_initial_clk(); // 74 minimum clks for initialization
      00068D 12r05r11         [24] 1882 	lcall	_sd_initial_clk
                                   1883 ;	sdcard.h:163: while(1)
      000690 7F 00            [12] 1884 	mov	r7,#0x00
      000692                       1885 00107$:
                                   1886 ;	sdcard.h:165: if(sd_cmd(CMD0,0)==0x01)break; // correct response is 0x01 -> signals card is idling
      000692 E4               [12] 1887 	clr	a
      000693 F5*05            [12] 1888 	mov	_sd_cmd_PARM_2,a
      000695 F5*06            [12] 1889 	mov	(_sd_cmd_PARM_2 + 1),a
      000697 F5*07            [12] 1890 	mov	(_sd_cmd_PARM_2 + 2),a
      000699 F5*08            [12] 1891 	mov	(_sd_cmd_PARM_2 + 3),a
      00069B 75 82 00         [24] 1892 	mov	dpl,#0x00
      00069E C0 07            [24] 1893 	push	ar7
      0006A0 12r05r2C         [24] 1894 	lcall	_sd_cmd
      0006A3 AE 82            [24] 1895 	mov	r6,dpl
      0006A5 D0 07            [24] 1896 	pop	ar7
      0006A7 BE 01 02         [24] 1897 	cjne	r6,#0x01,00155$
      0006AA 80 0A            [24] 1898 	sjmp	00108$
      0006AC                       1899 00155$:
                                   1900 ;	sdcard.h:166: else if(retries++==SD_MAX_RETRIES) return SD_MAX_RETRIES_FAIL;
      0006AC 8F 06            [24] 1901 	mov	ar6,r7
      0006AE 0F               [12] 1902 	inc	r7
      0006AF BE 19 E0         [24] 1903 	cjne	r6,#0x19,00107$
      0006B2 75 82 FE         [24] 1904 	mov	dpl,#0xfe
      0006B5 22               [24] 1905 	ret
      0006B6                       1906 00108$:
                                   1907 ;	sdcard.h:170: if(sd_cmd(CMD8,0x1AA)!=0x01) return SD_CMD_FAIL; // correct response for cmd8 is 0x01
      0006B6 75*05 AA         [24] 1908 	mov	_sd_cmd_PARM_2,#0xaa
      0006B9 75*06 01         [24] 1909 	mov	(_sd_cmd_PARM_2 + 1),#0x01
      0006BC E4               [12] 1910 	clr	a
      0006BD F5*07            [12] 1911 	mov	(_sd_cmd_PARM_2 + 2),a
      0006BF F5*08            [12] 1912 	mov	(_sd_cmd_PARM_2 + 3),a
      0006C1 75 82 08         [24] 1913 	mov	dpl,#0x08
      0006C4 12r05r2C         [24] 1914 	lcall	_sd_cmd
      0006C7 AF 82            [24] 1915 	mov	r7,dpl
      0006C9 BF 01 02         [24] 1916 	cjne	r7,#0x01,00158$
      0006CC 80 04            [24] 1917 	sjmp	00128$
      0006CE                       1918 00158$:
      0006CE 75 82 FF         [24] 1919 	mov	dpl,#0xff
                                   1920 ;	sdcard.h:173: while(1)
      0006D1 22               [24] 1921 	ret
      0006D2                       1922 00128$:
      0006D2 7F 00            [12] 1923 	mov	r7,#0x00
      0006D4                       1924 00117$:
                                   1925 ;	sdcard.h:175: if(sd_acmd(CMD41,0x40000000)==0)break; //correct response
      0006D4 E4               [12] 1926 	clr	a
      0006D5 F5*09            [12] 1927 	mov	_sd_acmd_PARM_2,a
      0006D7 F5*0A            [12] 1928 	mov	(_sd_acmd_PARM_2 + 1),a
      0006D9 F5*0B            [12] 1929 	mov	(_sd_acmd_PARM_2 + 2),a
      0006DB 75*0C 40         [24] 1930 	mov	(_sd_acmd_PARM_2 + 3),#0x40
      0006DE 75 82 29         [24] 1931 	mov	dpl,#0x29
      0006E1 C0 07            [24] 1932 	push	ar7
      0006E3 12r06r5C         [24] 1933 	lcall	_sd_acmd
      0006E6 E5 82            [12] 1934 	mov	a,dpl
      0006E8 D0 07            [24] 1935 	pop	ar7
      0006EA 60 0A            [24] 1936 	jz	00118$
                                   1937 ;	sdcard.h:176: else if(retries++==SD_MAX_RETRIES) return SD_MAX_RETRIES_FAIL;
      0006EC 8F 06            [24] 1938 	mov	ar6,r7
      0006EE 0F               [12] 1939 	inc	r7
      0006EF BE 19 E2         [24] 1940 	cjne	r6,#0x19,00117$
      0006F2 75 82 FE         [24] 1941 	mov	dpl,#0xfe
      0006F5 22               [24] 1942 	ret
      0006F6                       1943 00118$:
                                   1944 ;	sdcard.h:182: if(sd_cmd(CMD58,0)) return SD_CMD_FAIL;  
      0006F6 E4               [12] 1945 	clr	a
      0006F7 F5*05            [12] 1946 	mov	_sd_cmd_PARM_2,a
      0006F9 F5*06            [12] 1947 	mov	(_sd_cmd_PARM_2 + 1),a
      0006FB F5*07            [12] 1948 	mov	(_sd_cmd_PARM_2 + 2),a
      0006FD F5*08            [12] 1949 	mov	(_sd_cmd_PARM_2 + 3),a
      0006FF 75 82 3A         [24] 1950 	mov	dpl,#0x3a
      000702 12r05r2C         [24] 1951 	lcall	_sd_cmd
      000705 E5 82            [12] 1952 	mov	a,dpl
      000707 60 04            [24] 1953 	jz	00120$
      000709 75 82 FF         [24] 1954 	mov	dpl,#0xff
      00070C 22               [24] 1955 	ret
      00070D                       1956 00120$:
                                   1957 ;	sdcard.h:190: return 0; //successful init
      00070D 75 82 00         [24] 1958 	mov	dpl,#0x00
                                   1959 ;	sdcard.h:191: }
      000710 22               [24] 1960 	ret
                                   1961 ;------------------------------------------------------------
                                   1962 ;Allocation info for local variables in function 'SDread'
                                   1963 ;------------------------------------------------------------
                                   1964 ;offset                    Allocated to stack - _bp -4
                                   1965 ;count                     Allocated to stack - _bp -6
                                   1966 ;dst                       Allocated to stack - _bp -9
                                   1967 ;block_addr                Allocated to registers r4 r5 r6 r7 
                                   1968 ;retries                   Allocated to registers r7 
                                   1969 ;response                  Allocated to registers r3 
                                   1970 ;i                         Allocated to registers r4 r5 
                                   1971 ;------------------------------------------------------------
                                   1972 ;	sdcard.h:206: uint8_t SDread(uint32_t block_addr, uint16_t offset, uint16_t count, uint8_t* dst ) __reentrant
                                   1973 ;	-----------------------------------------
                                   1974 ;	 function SDread
                                   1975 ;	-----------------------------------------
      000711                       1976 _SDread:
      000711 C0*00            [24] 1977 	push	_bp
      000713 85 81*00         [24] 1978 	mov	_bp,sp
      000716 AC 82            [24] 1979 	mov	r4,dpl
      000718 AD 83            [24] 1980 	mov	r5,dph
      00071A AE F0            [24] 1981 	mov	r6,b
      00071C FF               [12] 1982 	mov	r7,a
                                   1983 ;	sdcard.h:221: if (count == 0) return 0; //success
      00071D E5*00            [12] 1984 	mov	a,_bp
      00071F 24 FA            [12] 1985 	add	a,#0xfa
      000721 F8               [12] 1986 	mov	r0,a
      000722 E6               [12] 1987 	mov	a,@r0
      000723 08               [12] 1988 	inc	r0
      000724 46               [12] 1989 	orl	a,@r0
      000725 70 05            [24] 1990 	jnz	00102$
      000727 F5 82            [12] 1991 	mov	dpl,a
      000729 02r08r2A         [24] 1992 	ljmp	00131$
      00072C                       1993 00102$:
                                   1994 ;	sdcard.h:222: if ((count + offset) > SD_BLOCK_SIZE) {
      00072C E5*00            [12] 1995 	mov	a,_bp
      00072E 24 FA            [12] 1996 	add	a,#0xfa
      000730 F8               [12] 1997 	mov	r0,a
      000731 E5*00            [12] 1998 	mov	a,_bp
      000733 24 FC            [12] 1999 	add	a,#0xfc
      000735 F9               [12] 2000 	mov	r1,a
      000736 E7               [12] 2001 	mov	a,@r1
      000737 26               [12] 2002 	add	a,@r0
      000738 FA               [12] 2003 	mov	r2,a
      000739 09               [12] 2004 	inc	r1
      00073A E7               [12] 2005 	mov	a,@r1
      00073B 08               [12] 2006 	inc	r0
      00073C 36               [12] 2007 	addc	a,@r0
      00073D FB               [12] 2008 	mov	r3,a
      00073E C3               [12] 2009 	clr	c
      00073F E4               [12] 2010 	clr	a
      000740 9A               [12] 2011 	subb	a,r2
      000741 74 02            [12] 2012 	mov	a,#0x02
      000743 9B               [12] 2013 	subb	a,r3
      000744 50 06            [24] 2014 	jnc	00105$
                                   2015 ;	sdcard.h:223: return 1; //fail
      000746 75 82 01         [24] 2016 	mov	dpl,#0x01
      000749 02r08r2A         [24] 2017 	ljmp	00131$
                                   2018 ;	sdcard.h:231: spi_cs_low();
      00074C                       2019 00105$:
      00074C 53 90 F7         [24] 2020 	anl	_P1,#0xf7
                                   2021 ;	sdcard.h:236: if(sd_cmd(CMD17,block_addr)) return SD_CMD_FAIL; 
      00074F 8C*05            [24] 2022 	mov	_sd_cmd_PARM_2,r4
      000751 8D*06            [24] 2023 	mov	(_sd_cmd_PARM_2 + 1),r5
      000753 8E*07            [24] 2024 	mov	(_sd_cmd_PARM_2 + 2),r6
      000755 8F*08            [24] 2025 	mov	(_sd_cmd_PARM_2 + 3),r7
      000757 75 82 11         [24] 2026 	mov	dpl,#0x11
      00075A 12r05r2C         [24] 2027 	lcall	_sd_cmd
      00075D E5 82            [12] 2028 	mov	a,dpl
      00075F 60 06            [24] 2029 	jz	00138$
      000761 75 82 FF         [24] 2030 	mov	dpl,#0xff
      000764 02r08r2A         [24] 2031 	ljmp	00131$
                                   2032 ;	sdcard.h:240: while(1)
      000767                       2033 00138$:
      000767 7F 00            [12] 2034 	mov	r7,#0x00
      000769                       2035 00119$:
                                   2036 ;	sdcard.h:242: response = sd_spi_write(0xff);
      000769 75*00 00         [24] 2037 	mov	_spi_transfer_PARM_2,#0x00
      00076C 75 82 FF         [24] 2038 	mov	dpl,#0xff
      00076F C0 07            [24] 2039 	push	ar7
      000771 12r04r61         [24] 2040 	lcall	_spi_transfer
      000774 AE 82            [24] 2041 	mov	r6,dpl
      000776 D0 07            [24] 2042 	pop	ar7
                                   2043 ;	sdcard.h:250: if(response==0xff); //pass
      000778 BE FF 02         [24] 2044 	cjne	r6,#0xff,00192$
      00077B 80 0B            [24] 2045 	sjmp	00115$
      00077D                       2046 00192$:
                                   2047 ;	sdcard.h:251: else if(response == DATA_START_BLOCK) break; // if the last response is DATA_START_BLOCK=0xFE, then success, else fail
      00077D BE FE 02         [24] 2048 	cjne	r6,#0xfe,00193$
      000780 80 12            [24] 2049 	sjmp	00143$
      000782                       2050 00193$:
                                   2051 ;	sdcard.h:252: else return DATA_START_BLOCK_FAIL; // if anything other than 0xff or DATA_START_BLOCK=0xFE
      000782 75 82 FD         [24] 2052 	mov	dpl,#0xfd
      000785 02r08r2A         [24] 2053 	ljmp	00131$
      000788                       2054 00115$:
                                   2055 ;	sdcard.h:254: if(retries++==255) return SD_MAX_RETRIES_FAIL;
      000788 8F 06            [24] 2056 	mov	ar6,r7
      00078A 0F               [12] 2057 	inc	r7
      00078B BE FF DB         [24] 2058 	cjne	r6,#0xff,00119$
      00078E 75 82 FE         [24] 2059 	mov	dpl,#0xfe
      000791 02r08r2A         [24] 2060 	ljmp	00131$
                                   2061 ;	sdcard.h:260: for(uint16_t i=0;i<512;i++)
      000794                       2062 00143$:
      000794 E5*00            [12] 2063 	mov	a,_bp
      000796 24 FC            [12] 2064 	add	a,#0xfc
      000798 F8               [12] 2065 	mov	r0,a
      000799 E5*00            [12] 2066 	mov	a,_bp
      00079B 24 FA            [12] 2067 	add	a,#0xfa
      00079D F9               [12] 2068 	mov	r1,a
      00079E E7               [12] 2069 	mov	a,@r1
      00079F 26               [12] 2070 	add	a,@r0
      0007A0 FE               [12] 2071 	mov	r6,a
      0007A1 09               [12] 2072 	inc	r1
      0007A2 E7               [12] 2073 	mov	a,@r1
      0007A3 08               [12] 2074 	inc	r0
      0007A4 36               [12] 2075 	addc	a,@r0
      0007A5 FF               [12] 2076 	mov	r7,a
      0007A6 7C 00            [12] 2077 	mov	r4,#0x00
      0007A8 7D 00            [12] 2078 	mov	r5,#0x00
      0007AA                       2079 00129$:
      0007AA 74 FE            [12] 2080 	mov	a,#0x100 - 0x02
      0007AC 2D               [12] 2081 	add	a,r5
      0007AD 40 63            [24] 2082 	jc	00124$
                                   2083 ;	sdcard.h:262: response = spi_transfer(0xff,0);
      0007AF 75*00 00         [24] 2084 	mov	_spi_transfer_PARM_2,#0x00
      0007B2 75 82 FF         [24] 2085 	mov	dpl,#0xff
      0007B5 C0 07            [24] 2086 	push	ar7
      0007B7 C0 06            [24] 2087 	push	ar6
      0007B9 C0 05            [24] 2088 	push	ar5
      0007BB C0 04            [24] 2089 	push	ar4
      0007BD 12r04r61         [24] 2090 	lcall	_spi_transfer
      0007C0 AB 82            [24] 2091 	mov	r3,dpl
      0007C2 D0 04            [24] 2092 	pop	ar4
      0007C4 D0 05            [24] 2093 	pop	ar5
      0007C6 D0 06            [24] 2094 	pop	ar6
      0007C8 D0 07            [24] 2095 	pop	ar7
                                   2096 ;	sdcard.h:270: if(i>=offset && i<offset+count)
      0007CA E5*00            [12] 2097 	mov	a,_bp
      0007CC 24 FC            [12] 2098 	add	a,#0xfc
      0007CE F8               [12] 2099 	mov	r0,a
      0007CF C3               [12] 2100 	clr	c
      0007D0 EC               [12] 2101 	mov	a,r4
      0007D1 96               [12] 2102 	subb	a,@r0
      0007D2 ED               [12] 2103 	mov	a,r5
      0007D3 08               [12] 2104 	inc	r0
      0007D4 96               [12] 2105 	subb	a,@r0
      0007D5 40 34            [24] 2106 	jc	00130$
      0007D7 EC               [12] 2107 	mov	a,r4
      0007D8 9E               [12] 2108 	subb	a,r6
      0007D9 ED               [12] 2109 	mov	a,r5
      0007DA 9F               [12] 2110 	subb	a,r7
      0007DB 50 2E            [24] 2111 	jnc	00130$
                                   2112 ;	sdcard.h:272: dst[i-offset] = response;
      0007DD C0 06            [24] 2113 	push	ar6
      0007DF C0 07            [24] 2114 	push	ar7
      0007E1 E5*00            [12] 2115 	mov	a,_bp
      0007E3 24 FC            [12] 2116 	add	a,#0xfc
      0007E5 F8               [12] 2117 	mov	r0,a
      0007E6 EC               [12] 2118 	mov	a,r4
      0007E7 C3               [12] 2119 	clr	c
      0007E8 96               [12] 2120 	subb	a,@r0
      0007E9 FA               [12] 2121 	mov	r2,a
      0007EA ED               [12] 2122 	mov	a,r5
      0007EB 08               [12] 2123 	inc	r0
      0007EC 96               [12] 2124 	subb	a,@r0
      0007ED FF               [12] 2125 	mov	r7,a
      0007EE E5*00            [12] 2126 	mov	a,_bp
      0007F0 24 F7            [12] 2127 	add	a,#0xf7
      0007F2 F8               [12] 2128 	mov	r0,a
      0007F3 EA               [12] 2129 	mov	a,r2
      0007F4 26               [12] 2130 	add	a,@r0
      0007F5 FA               [12] 2131 	mov	r2,a
      0007F6 EF               [12] 2132 	mov	a,r7
      0007F7 08               [12] 2133 	inc	r0
      0007F8 36               [12] 2134 	addc	a,@r0
      0007F9 FF               [12] 2135 	mov	r7,a
      0007FA 08               [12] 2136 	inc	r0
      0007FB 86 06            [24] 2137 	mov	ar6,@r0
      0007FD 8A 82            [24] 2138 	mov	dpl,r2
      0007FF 8F 83            [24] 2139 	mov	dph,r7
      000801 8E F0            [24] 2140 	mov	b,r6
      000803 EB               [12] 2141 	mov	a,r3
      000804 12r00r00         [24] 2142 	lcall	__gptrput
                                   2143 ;	sdcard.h:287: return 0; //success
      000807 D0 07            [24] 2144 	pop	ar7
      000809 D0 06            [24] 2145 	pop	ar6
                                   2146 ;	sdcard.h:272: dst[i-offset] = response;
      00080B                       2147 00130$:
                                   2148 ;	sdcard.h:260: for(uint16_t i=0;i<512;i++)
      00080B 0C               [12] 2149 	inc	r4
      00080C BC 00 9B         [24] 2150 	cjne	r4,#0x00,00129$
      00080F 0D               [12] 2151 	inc	r5
      000810 80 98            [24] 2152 	sjmp	00129$
      000812                       2153 00124$:
                                   2154 ;	sdcard.h:280: sd_spi_write(0xff);
      000812 75*00 00         [24] 2155 	mov	_spi_transfer_PARM_2,#0x00
      000815 75 82 FF         [24] 2156 	mov	dpl,#0xff
      000818 12r04r61         [24] 2157 	lcall	_spi_transfer
                                   2158 ;	sdcard.h:281: sd_spi_write(0xff);
      00081B 75*00 00         [24] 2159 	mov	_spi_transfer_PARM_2,#0x00
      00081E 75 82 FF         [24] 2160 	mov	dpl,#0xff
      000821 12r04r61         [24] 2161 	lcall	_spi_transfer
                                   2162 ;	sdcard.h:284: spi_cs_high(); //leave clock high
      000824 43 90 08         [24] 2163 	orl	_P1,#0x08
                                   2164 ;	sdcard.h:287: return 0; //success
      000827 75 82 00         [24] 2165 	mov	dpl,#0x00
      00082A                       2166 00131$:
                                   2167 ;	sdcard.h:289: }
      00082A D0*00            [24] 2168 	pop	_bp
      00082C 22               [24] 2169 	ret
                                   2170 ;------------------------------------------------------------
                                   2171 ;Allocation info for local variables in function 'SDreadBlock'
                                   2172 ;------------------------------------------------------------
                                   2173 ;dst                       Allocated with name '_SDreadBlock_PARM_2'
                                   2174 ;block_addr                Allocated to registers r4 r5 r6 r7 
                                   2175 ;------------------------------------------------------------
                                   2176 ;	sdcard.h:291: uint8_t SDreadBlock(uint32_t block_addr,uint8_t* dst)
                                   2177 ;	-----------------------------------------
                                   2178 ;	 function SDreadBlock
                                   2179 ;	-----------------------------------------
      00082D                       2180 _SDreadBlock:
      00082D AC 82            [24] 2181 	mov	r4,dpl
      00082F AD 83            [24] 2182 	mov	r5,dph
      000831 AE F0            [24] 2183 	mov	r6,b
      000833 FF               [12] 2184 	mov	r7,a
                                   2185 ;	sdcard.h:293: return SDread(block_addr,0,SD_BLOCK_SIZE,dst);
      000834 C0*0D            [24] 2186 	push	_SDreadBlock_PARM_2
      000836 C0*0E            [24] 2187 	push	(_SDreadBlock_PARM_2 + 1)
      000838 C0*0F            [24] 2188 	push	(_SDreadBlock_PARM_2 + 2)
      00083A E4               [12] 2189 	clr	a
      00083B C0 E0            [24] 2190 	push	acc
      00083D 74 02            [12] 2191 	mov	a,#0x02
      00083F C0 E0            [24] 2192 	push	acc
      000841 E4               [12] 2193 	clr	a
      000842 C0 E0            [24] 2194 	push	acc
      000844 C0 E0            [24] 2195 	push	acc
      000846 8C 82            [24] 2196 	mov	dpl,r4
      000848 8D 83            [24] 2197 	mov	dph,r5
      00084A 8E F0            [24] 2198 	mov	b,r6
      00084C EF               [12] 2199 	mov	a,r7
      00084D 12r07r11         [24] 2200 	lcall	_SDread
      000850 E5 81            [12] 2201 	mov	a,sp
      000852 24 F9            [12] 2202 	add	a,#0xf9
      000854 F5 81            [12] 2203 	mov	sp,a
                                   2204 ;	sdcard.h:294: }
      000856 22               [24] 2205 	ret
                                   2206 ;------------------------------------------------------------
                                   2207 ;Allocation info for local variables in function 'HELPER_load_littleendian16'
                                   2208 ;------------------------------------------------------------
                                   2209 ;src                       Allocated to registers r5 r6 r7 
                                   2210 ;val                       Allocated to registers r2 r4 
                                   2211 ;------------------------------------------------------------
                                   2212 ;	fat.h:85: uint16_t HELPER_load_littleendian16(uint8_t *src) __reentrant
                                   2213 ;	-----------------------------------------
                                   2214 ;	 function HELPER_load_littleendian16
                                   2215 ;	-----------------------------------------
      000857                       2216 _HELPER_load_littleendian16:
      000857 AD 82            [24] 2217 	mov	r5,dpl
      000859 AE 83            [24] 2218 	mov	r6,dph
      00085B AF F0            [24] 2219 	mov	r7,b
                                   2220 ;	fat.h:89: val = *(src+1);
      00085D 74 01            [12] 2221 	mov	a,#0x01
      00085F 2D               [12] 2222 	add	a,r5
      000860 FA               [12] 2223 	mov	r2,a
      000861 E4               [12] 2224 	clr	a
      000862 3E               [12] 2225 	addc	a,r6
      000863 FB               [12] 2226 	mov	r3,a
      000864 8F 04            [24] 2227 	mov	ar4,r7
      000866 8A 82            [24] 2228 	mov	dpl,r2
      000868 8B 83            [24] 2229 	mov	dph,r3
      00086A 8C F0            [24] 2230 	mov	b,r4
      00086C 12r00r00         [24] 2231 	lcall	__gptrget
                                   2232 ;	fat.h:90: val <<= 8;
      00086F FC               [12] 2233 	mov	r4,a
      000870 7A 00            [12] 2234 	mov	r2,#0x00
                                   2235 ;	fat.h:91: val |= *src;
      000872 8D 82            [24] 2236 	mov	dpl,r5
      000874 8E 83            [24] 2237 	mov	dph,r6
      000876 8F F0            [24] 2238 	mov	b,r7
      000878 12r00r00         [24] 2239 	lcall	__gptrget
      00087B 7F 00            [12] 2240 	mov	r7,#0x00
      00087D 4A               [12] 2241 	orl	a,r2
      00087E F5 82            [12] 2242 	mov	dpl,a
      000880 EF               [12] 2243 	mov	a,r7
      000881 4C               [12] 2244 	orl	a,r4
      000882 F5 83            [12] 2245 	mov	dph,a
                                   2246 ;	fat.h:93: return val;
                                   2247 ;	fat.h:94: }
      000884 22               [24] 2248 	ret
                                   2249 ;------------------------------------------------------------
                                   2250 ;Allocation info for local variables in function 'HELPER_load_littleendian32'
                                   2251 ;------------------------------------------------------------
                                   2252 ;src                       Allocated to stack - _bp +1
                                   2253 ;val                       Allocated to stack - _bp +8
                                   2254 ;i                         Allocated to stack - _bp +12
                                   2255 ;sloc0                     Allocated to stack - _bp +9
                                   2256 ;sloc1                     Allocated to stack - _bp +4
                                   2257 ;------------------------------------------------------------
                                   2258 ;	fat.h:96: uint32_t HELPER_load_littleendian32(uint8_t *src) __reentrant
                                   2259 ;	-----------------------------------------
                                   2260 ;	 function HELPER_load_littleendian32
                                   2261 ;	-----------------------------------------
      000885                       2262 _HELPER_load_littleendian32:
      000885 C0*00            [24] 2263 	push	_bp
      000887 85 81*00         [24] 2264 	mov	_bp,sp
      00088A C0 82            [24] 2265 	push	dpl
      00088C C0 83            [24] 2266 	push	dph
      00088E C0 F0            [24] 2267 	push	b
      000890 E5 81            [12] 2268 	mov	a,sp
      000892 24 09            [12] 2269 	add	a,#0x09
      000894 F5 81            [12] 2270 	mov	sp,a
                                   2271 ;	fat.h:98: uint32_t val=0;
                                   2272 ;	fat.h:100: for(uint8_t i=0;i<4;i++)
      000896 E4               [12] 2273 	clr	a
      000897 FA               [12] 2274 	mov	r2,a
      000898 FB               [12] 2275 	mov	r3,a
      000899 FC               [12] 2276 	mov	r4,a
      00089A FF               [12] 2277 	mov	r7,a
      00089B E5*00            [12] 2278 	mov	a,_bp
      00089D 24 0C            [12] 2279 	add	a,#0x0c
      00089F F8               [12] 2280 	mov	r0,a
      0008A0 76 00            [12] 2281 	mov	@r0,#0x00
      0008A2                       2282 00103$:
      0008A2 E5*00            [12] 2283 	mov	a,_bp
      0008A4 24 0C            [12] 2284 	add	a,#0x0c
      0008A6 F8               [12] 2285 	mov	r0,a
      0008A7 B6 04 00         [24] 2286 	cjne	@r0,#0x04,00118$
      0008AA                       2287 00118$:
      0008AA 50 6F            [24] 2288 	jnc	00101$
                                   2289 ;	fat.h:102: val <<= 8;
      0008AC E5*00            [12] 2290 	mov	a,_bp
      0008AE 24 08            [12] 2291 	add	a,#0x08
      0008B0 F8               [12] 2292 	mov	r0,a
      0008B1 08               [12] 2293 	inc	r0
      0008B2 08               [12] 2294 	inc	r0
      0008B3 08               [12] 2295 	inc	r0
      0008B4 A6 04            [24] 2296 	mov	@r0,ar4
      0008B6 18               [12] 2297 	dec	r0
      0008B7 A6 03            [24] 2298 	mov	@r0,ar3
      0008B9 18               [12] 2299 	dec	r0
      0008BA A6 02            [24] 2300 	mov	@r0,ar2
      0008BC 18               [12] 2301 	dec	r0
      0008BD 76 00            [12] 2302 	mov	@r0,#0x00
                                   2303 ;	fat.h:103: val |= src[3-i];
      0008BF E5*00            [12] 2304 	mov	a,_bp
      0008C1 24 0C            [12] 2305 	add	a,#0x0c
      0008C3 F8               [12] 2306 	mov	r0,a
      0008C4 86 05            [24] 2307 	mov	ar5,@r0
      0008C6 7E 00            [12] 2308 	mov	r6,#0x00
      0008C8 74 03            [12] 2309 	mov	a,#0x03
      0008CA C3               [12] 2310 	clr	c
      0008CB 9D               [12] 2311 	subb	a,r5
      0008CC FD               [12] 2312 	mov	r5,a
      0008CD E4               [12] 2313 	clr	a
      0008CE 9E               [12] 2314 	subb	a,r6
      0008CF FE               [12] 2315 	mov	r6,a
      0008D0 A8*00            [24] 2316 	mov	r0,_bp
      0008D2 08               [12] 2317 	inc	r0
      0008D3 ED               [12] 2318 	mov	a,r5
      0008D4 26               [12] 2319 	add	a,@r0
      0008D5 FF               [12] 2320 	mov	r7,a
      0008D6 EE               [12] 2321 	mov	a,r6
      0008D7 08               [12] 2322 	inc	r0
      0008D8 36               [12] 2323 	addc	a,@r0
      0008D9 FE               [12] 2324 	mov	r6,a
      0008DA 08               [12] 2325 	inc	r0
      0008DB 86 05            [24] 2326 	mov	ar5,@r0
      0008DD 8F 82            [24] 2327 	mov	dpl,r7
      0008DF 8E 83            [24] 2328 	mov	dph,r6
      0008E1 8D F0            [24] 2329 	mov	b,r5
      0008E3 12r00r00         [24] 2330 	lcall	__gptrget
      0008E6 FE               [12] 2331 	mov	r6,a
      0008E7 E5*00            [12] 2332 	mov	a,_bp
      0008E9 24 04            [12] 2333 	add	a,#0x04
      0008EB F8               [12] 2334 	mov	r0,a
      0008EC A6 06            [24] 2335 	mov	@r0,ar6
      0008EE 08               [12] 2336 	inc	r0
      0008EF 76 00            [12] 2337 	mov	@r0,#0x00
      0008F1 08               [12] 2338 	inc	r0
      0008F2 76 00            [12] 2339 	mov	@r0,#0x00
      0008F4 08               [12] 2340 	inc	r0
      0008F5 76 00            [12] 2341 	mov	@r0,#0x00
      0008F7 E5*00            [12] 2342 	mov	a,_bp
      0008F9 24 08            [12] 2343 	add	a,#0x08
      0008FB F8               [12] 2344 	mov	r0,a
      0008FC E5*00            [12] 2345 	mov	a,_bp
      0008FE 24 04            [12] 2346 	add	a,#0x04
      000900 F9               [12] 2347 	mov	r1,a
      000901 E7               [12] 2348 	mov	a,@r1
      000902 46               [12] 2349 	orl	a,@r0
      000903 FA               [12] 2350 	mov	r2,a
      000904 09               [12] 2351 	inc	r1
      000905 E7               [12] 2352 	mov	a,@r1
      000906 08               [12] 2353 	inc	r0
      000907 46               [12] 2354 	orl	a,@r0
      000908 FB               [12] 2355 	mov	r3,a
      000909 09               [12] 2356 	inc	r1
      00090A E7               [12] 2357 	mov	a,@r1
      00090B 08               [12] 2358 	inc	r0
      00090C 46               [12] 2359 	orl	a,@r0
      00090D FC               [12] 2360 	mov	r4,a
      00090E 09               [12] 2361 	inc	r1
      00090F E7               [12] 2362 	mov	a,@r1
      000910 08               [12] 2363 	inc	r0
      000911 46               [12] 2364 	orl	a,@r0
      000912 FF               [12] 2365 	mov	r7,a
                                   2366 ;	fat.h:100: for(uint8_t i=0;i<4;i++)
      000913 E5*00            [12] 2367 	mov	a,_bp
      000915 24 0C            [12] 2368 	add	a,#0x0c
      000917 F8               [12] 2369 	mov	r0,a
      000918 06               [12] 2370 	inc	@r0
      000919 80 87            [24] 2371 	sjmp	00103$
      00091B                       2372 00101$:
                                   2373 ;	fat.h:106: return val;
      00091B 8A 82            [24] 2374 	mov	dpl,r2
      00091D 8B 83            [24] 2375 	mov	dph,r3
      00091F 8C F0            [24] 2376 	mov	b,r4
      000921 EF               [12] 2377 	mov	a,r7
                                   2378 ;	fat.h:107: }
      000922 85*00 81         [24] 2379 	mov	sp,_bp
      000925 D0*00            [24] 2380 	pop	_bp
      000927 22               [24] 2381 	ret
                                   2382 ;------------------------------------------------------------
                                   2383 ;Allocation info for local variables in function 'HELPER_strcmp'
                                   2384 ;------------------------------------------------------------
                                   2385 ;s2                        Allocated with name '_HELPER_strcmp_PARM_2'
                                   2386 ;s1                        Allocated to registers r5 r6 r7 
                                   2387 ;i                         Allocated to registers r4 
                                   2388 ;------------------------------------------------------------
                                   2389 ;	fat.h:109: uint8_t HELPER_strcmp(char *s1,char* s2)
                                   2390 ;	-----------------------------------------
                                   2391 ;	 function HELPER_strcmp
                                   2392 ;	-----------------------------------------
      000928                       2393 _HELPER_strcmp:
      000928 AD 82            [24] 2394 	mov	r5,dpl
      00092A AE 83            [24] 2395 	mov	r6,dph
      00092C AF F0            [24] 2396 	mov	r7,b
                                   2397 ;	fat.h:112: while(1)
      00092E 7C 00            [12] 2398 	mov	r4,#0x00
      000930                       2399 00107$:
                                   2400 ;	fat.h:114: if(s1[i]==s2[i]);
      000930 EC               [12] 2401 	mov	a,r4
      000931 2D               [12] 2402 	add	a,r5
      000932 F9               [12] 2403 	mov	r1,a
      000933 E4               [12] 2404 	clr	a
      000934 3E               [12] 2405 	addc	a,r6
      000935 FA               [12] 2406 	mov	r2,a
      000936 8F 03            [24] 2407 	mov	ar3,r7
      000938 89 82            [24] 2408 	mov	dpl,r1
      00093A 8A 83            [24] 2409 	mov	dph,r2
      00093C 8B F0            [24] 2410 	mov	b,r3
      00093E 12r00r00         [24] 2411 	lcall	__gptrget
      000941 FB               [12] 2412 	mov	r3,a
      000942 EC               [12] 2413 	mov	a,r4
      000943 25*00            [12] 2414 	add	a,_HELPER_strcmp_PARM_2
      000945 F8               [12] 2415 	mov	r0,a
      000946 E4               [12] 2416 	clr	a
      000947 35*01            [12] 2417 	addc	a,(_HELPER_strcmp_PARM_2 + 1)
      000949 F9               [12] 2418 	mov	r1,a
      00094A AA*02            [24] 2419 	mov	r2,(_HELPER_strcmp_PARM_2 + 2)
      00094C 88 82            [24] 2420 	mov	dpl,r0
      00094E 89 83            [24] 2421 	mov	dph,r1
      000950 8A F0            [24] 2422 	mov	b,r2
      000952 12r00r00         [24] 2423 	lcall	__gptrget
      000955 F8               [12] 2424 	mov	r0,a
      000956 EB               [12] 2425 	mov	a,r3
      000957 B5 00 02         [24] 2426 	cjne	a,ar0,00123$
      00095A 80 04            [24] 2427 	sjmp	00103$
      00095C                       2428 00123$:
                                   2429 ;	fat.h:115: else return 1;
      00095C 75 82 01         [24] 2430 	mov	dpl,#0x01
      00095F 22               [24] 2431 	ret
      000960                       2432 00103$:
                                   2433 ;	fat.h:117: if(s1[i]==0) return 0;
      000960 EB               [12] 2434 	mov	a,r3
      000961 70 03            [24] 2435 	jnz	00105$
      000963 F5 82            [12] 2436 	mov	dpl,a
      000965 22               [24] 2437 	ret
      000966                       2438 00105$:
                                   2439 ;	fat.h:118: i++;
      000966 0C               [12] 2440 	inc	r4
                                   2441 ;	fat.h:120: }
      000967 80 C7            [24] 2442 	sjmp	00107$
                                   2443 ;------------------------------------------------------------
                                   2444 ;Allocation info for local variables in function 'HELPER_strncmp'
                                   2445 ;------------------------------------------------------------
                                   2446 ;s2                        Allocated with name '_HELPER_strncmp_PARM_2'
                                   2447 ;n                         Allocated with name '_HELPER_strncmp_PARM_3'
                                   2448 ;s1                        Allocated to registers r5 r6 r7 
                                   2449 ;i                         Allocated to registers r4 
                                   2450 ;------------------------------------------------------------
                                   2451 ;	fat.h:122: uint8_t HELPER_strncmp(char *s1,char* s2,uint8_t n)
                                   2452 ;	-----------------------------------------
                                   2453 ;	 function HELPER_strncmp
                                   2454 ;	-----------------------------------------
      000969                       2455 _HELPER_strncmp:
      000969 AD 82            [24] 2456 	mov	r5,dpl
      00096B AE 83            [24] 2457 	mov	r6,dph
      00096D AF F0            [24] 2458 	mov	r7,b
                                   2459 ;	fat.h:125: while(1)
      00096F 7C 00            [12] 2460 	mov	r4,#0x00
      000971                       2461 00109$:
                                   2462 ;	fat.h:127: if(i==n) return 0; //done - successful
      000971 EC               [12] 2463 	mov	a,r4
      000972 B5*03 04         [24] 2464 	cjne	a,_HELPER_strncmp_PARM_3,00102$
      000975 75 82 00         [24] 2465 	mov	dpl,#0x00
      000978 22               [24] 2466 	ret
      000979                       2467 00102$:
                                   2468 ;	fat.h:129: if(s1[i]==s2[i]);
      000979 EC               [12] 2469 	mov	a,r4
      00097A 2D               [12] 2470 	add	a,r5
      00097B F9               [12] 2471 	mov	r1,a
      00097C E4               [12] 2472 	clr	a
      00097D 3E               [12] 2473 	addc	a,r6
      00097E FA               [12] 2474 	mov	r2,a
      00097F 8F 03            [24] 2475 	mov	ar3,r7
      000981 89 82            [24] 2476 	mov	dpl,r1
      000983 8A 83            [24] 2477 	mov	dph,r2
      000985 8B F0            [24] 2478 	mov	b,r3
      000987 12r00r00         [24] 2479 	lcall	__gptrget
      00098A FB               [12] 2480 	mov	r3,a
      00098B EC               [12] 2481 	mov	a,r4
      00098C 25*00            [12] 2482 	add	a,_HELPER_strncmp_PARM_2
      00098E F8               [12] 2483 	mov	r0,a
      00098F E4               [12] 2484 	clr	a
      000990 35*01            [12] 2485 	addc	a,(_HELPER_strncmp_PARM_2 + 1)
      000992 F9               [12] 2486 	mov	r1,a
      000993 AA*02            [24] 2487 	mov	r2,(_HELPER_strncmp_PARM_2 + 2)
      000995 88 82            [24] 2488 	mov	dpl,r0
      000997 89 83            [24] 2489 	mov	dph,r1
      000999 8A F0            [24] 2490 	mov	b,r2
      00099B 12r00r00         [24] 2491 	lcall	__gptrget
      00099E F8               [12] 2492 	mov	r0,a
      00099F EB               [12] 2493 	mov	a,r3
      0009A0 B5 00 02         [24] 2494 	cjne	a,ar0,00131$
      0009A3 80 04            [24] 2495 	sjmp	00105$
      0009A5                       2496 00131$:
                                   2497 ;	fat.h:130: else return 1;
      0009A5 75 82 01         [24] 2498 	mov	dpl,#0x01
      0009A8 22               [24] 2499 	ret
      0009A9                       2500 00105$:
                                   2501 ;	fat.h:132: if(s1[i]==0) return 0; //if string length < n, return success as well as we donot want to compare more
      0009A9 EB               [12] 2502 	mov	a,r3
      0009AA 70 03            [24] 2503 	jnz	00107$
      0009AC F5 82            [12] 2504 	mov	dpl,a
      0009AE 22               [24] 2505 	ret
      0009AF                       2506 00107$:
                                   2507 ;	fat.h:133: i++;
      0009AF 0C               [12] 2508 	inc	r4
                                   2509 ;	fat.h:135: }
      0009B0 80 BF            [24] 2510 	sjmp	00109$
                                   2511 ;------------------------------------------------------------
                                   2512 ;Allocation info for local variables in function 'HELPER_strlen'
                                   2513 ;------------------------------------------------------------
                                   2514 ;s                         Allocated to registers r5 r6 r7 
                                   2515 ;i                         Allocated to registers r4 
                                   2516 ;------------------------------------------------------------
                                   2517 ;	fat.h:137: uint8_t HELPER_strlen(char *s)
                                   2518 ;	-----------------------------------------
                                   2519 ;	 function HELPER_strlen
                                   2520 ;	-----------------------------------------
      0009B2                       2521 _HELPER_strlen:
      0009B2 AD 82            [24] 2522 	mov	r5,dpl
      0009B4 AE 83            [24] 2523 	mov	r6,dph
      0009B6 AF F0            [24] 2524 	mov	r7,b
                                   2525 ;	fat.h:139: for(uint8_t i=0;i<255;i++)
      0009B8 7C 00            [12] 2526 	mov	r4,#0x00
      0009BA 7B 00            [12] 2527 	mov	r3,#0x00
      0009BC                       2528 00105$:
      0009BC BB FF 00         [24] 2529 	cjne	r3,#0xff,00121$
      0009BF                       2530 00121$:
      0009BF 50 1B            [24] 2531 	jnc	00103$
                                   2532 ;	fat.h:141: if(s[i]==0) return i;
      0009C1 EB               [12] 2533 	mov	a,r3
      0009C2 2D               [12] 2534 	add	a,r5
      0009C3 F8               [12] 2535 	mov	r0,a
      0009C4 E4               [12] 2536 	clr	a
      0009C5 3E               [12] 2537 	addc	a,r6
      0009C6 F9               [12] 2538 	mov	r1,a
      0009C7 8F 02            [24] 2539 	mov	ar2,r7
      0009C9 88 82            [24] 2540 	mov	dpl,r0
      0009CB 89 83            [24] 2541 	mov	dph,r1
      0009CD 8A F0            [24] 2542 	mov	b,r2
      0009CF 12r00r00         [24] 2543 	lcall	__gptrget
      0009D2 70 03            [24] 2544 	jnz	00106$
      0009D4 8C 82            [24] 2545 	mov	dpl,r4
      0009D6 22               [24] 2546 	ret
      0009D7                       2547 00106$:
                                   2548 ;	fat.h:139: for(uint8_t i=0;i<255;i++)
      0009D7 0B               [12] 2549 	inc	r3
      0009D8 8B 04            [24] 2550 	mov	ar4,r3
      0009DA 80 E0            [24] 2551 	sjmp	00105$
      0009DC                       2552 00103$:
                                   2553 ;	fat.h:144: return 255;
      0009DC 75 82 FF         [24] 2554 	mov	dpl,#0xff
                                   2555 ;	fat.h:145: }
      0009DF 22               [24] 2556 	ret
                                   2557 ;------------------------------------------------------------
                                   2558 ;Allocation info for local variables in function 'HELPER_rootentry_type'
                                   2559 ;------------------------------------------------------------
                                   2560 ;re                        Allocated to registers r5 r6 r7 
                                   2561 ;------------------------------------------------------------
                                   2562 ;	fat.h:147: uint8_t HELPER_rootentry_type(ROOTENTRY *re)
                                   2563 ;	-----------------------------------------
                                   2564 ;	 function HELPER_rootentry_type
                                   2565 ;	-----------------------------------------
      0009E0                       2566 _HELPER_rootentry_type:
      0009E0 AD 82            [24] 2567 	mov	r5,dpl
      0009E2 AE 83            [24] 2568 	mov	r6,dph
      0009E4 AF F0            [24] 2569 	mov	r7,b
                                   2570 ;	fat.h:149: if(re->attributes & 1<<FILETYPE_HIDDEN) return FILETYPE_HIDDEN; //directory entry
      0009E6 74 0B            [12] 2571 	mov	a,#0x0b
      0009E8 2D               [12] 2572 	add	a,r5
      0009E9 FA               [12] 2573 	mov	r2,a
      0009EA E4               [12] 2574 	clr	a
      0009EB 3E               [12] 2575 	addc	a,r6
      0009EC FB               [12] 2576 	mov	r3,a
      0009ED 8F 04            [24] 2577 	mov	ar4,r7
      0009EF 8A 82            [24] 2578 	mov	dpl,r2
      0009F1 8B 83            [24] 2579 	mov	dph,r3
      0009F3 8C F0            [24] 2580 	mov	b,r4
      0009F5 12r00r00         [24] 2581 	lcall	__gptrget
      0009F8 FC               [12] 2582 	mov	r4,a
      0009F9 30 E1 04         [24] 2583 	jnb	acc.1,00102$
      0009FC 75 82 01         [24] 2584 	mov	dpl,#0x01
      0009FF 22               [24] 2585 	ret
      000A00                       2586 00102$:
                                   2587 ;	fat.h:150: if(re->attributes & 1<<FILETYPE_SYSTEM) return FILETYPE_SYSTEM; //directory entry
      000A00 EC               [12] 2588 	mov	a,r4
      000A01 30 E2 04         [24] 2589 	jnb	acc.2,00104$
      000A04 75 82 02         [24] 2590 	mov	dpl,#0x02
      000A07 22               [24] 2591 	ret
      000A08                       2592 00104$:
                                   2593 ;	fat.h:151: if(re->attributes & 1<<FILETYPE_VOLUME) return FILETYPE_VOLUME; //directory entry
      000A08 EC               [12] 2594 	mov	a,r4
      000A09 30 E3 04         [24] 2595 	jnb	acc.3,00106$
      000A0C 75 82 03         [24] 2596 	mov	dpl,#0x03
      000A0F 22               [24] 2597 	ret
      000A10                       2598 00106$:
                                   2599 ;	fat.h:153: if(re->startCluster==0) return FILETYPE_NOFILE; //no file
      000A10 74 0C            [12] 2600 	mov	a,#0x0c
      000A12 2D               [12] 2601 	add	a,r5
      000A13 FA               [12] 2602 	mov	r2,a
      000A14 E4               [12] 2603 	clr	a
      000A15 3E               [12] 2604 	addc	a,r6
      000A16 FB               [12] 2605 	mov	r3,a
      000A17 8F 04            [24] 2606 	mov	ar4,r7
      000A19 8A 82            [24] 2607 	mov	dpl,r2
      000A1B 8B 83            [24] 2608 	mov	dph,r3
      000A1D 8C F0            [24] 2609 	mov	b,r4
      000A1F 12r00r00         [24] 2610 	lcall	__gptrget
      000A22 FA               [12] 2611 	mov	r2,a
      000A23 A3               [24] 2612 	inc	dptr
      000A24 12r00r00         [24] 2613 	lcall	__gptrget
      000A27 4A               [12] 2614 	orl	a,r2
      000A28 70 04            [24] 2615 	jnz	00111$
      000A2A 75 82 FF         [24] 2616 	mov	dpl,#0xff
      000A2D 22               [24] 2617 	ret
      000A2E                       2618 00111$:
                                   2619 ;	fat.h:154: else if(re->size==0) return FILETYPE_EMPTYFILE; //empty file
      000A2E 74 0E            [12] 2620 	mov	a,#0x0e
      000A30 2D               [12] 2621 	add	a,r5
      000A31 FD               [12] 2622 	mov	r5,a
      000A32 E4               [12] 2623 	clr	a
      000A33 3E               [12] 2624 	addc	a,r6
      000A34 FE               [12] 2625 	mov	r6,a
      000A35 8D 82            [24] 2626 	mov	dpl,r5
      000A37 8E 83            [24] 2627 	mov	dph,r6
      000A39 8F F0            [24] 2628 	mov	b,r7
      000A3B 12r00r00         [24] 2629 	lcall	__gptrget
      000A3E FD               [12] 2630 	mov	r5,a
      000A3F A3               [24] 2631 	inc	dptr
      000A40 12r00r00         [24] 2632 	lcall	__gptrget
      000A43 FE               [12] 2633 	mov	r6,a
      000A44 A3               [24] 2634 	inc	dptr
      000A45 12r00r00         [24] 2635 	lcall	__gptrget
      000A48 FF               [12] 2636 	mov	r7,a
      000A49 A3               [24] 2637 	inc	dptr
      000A4A 12r00r00         [24] 2638 	lcall	__gptrget
      000A4D FC               [12] 2639 	mov	r4,a
      000A4E ED               [12] 2640 	mov	a,r5
      000A4F 4E               [12] 2641 	orl	a,r6
      000A50 4F               [12] 2642 	orl	a,r7
      000A51 4C               [12] 2643 	orl	a,r4
      000A52 70 04            [24] 2644 	jnz	00108$
      000A54 75 82 FE         [24] 2645 	mov	dpl,#0xfe
      000A57 22               [24] 2646 	ret
      000A58                       2647 00108$:
                                   2648 ;	fat.h:155: else return 0; // valid non-empty file
      000A58 75 82 00         [24] 2649 	mov	dpl,#0x00
                                   2650 ;	fat.h:157: }
      000A5B 22               [24] 2651 	ret
                                   2652 ;------------------------------------------------------------
                                   2653 ;Allocation info for local variables in function 'HELPER_to_uppercase'
                                   2654 ;------------------------------------------------------------
                                   2655 ;s                         Allocated to registers r5 r6 r7 
                                   2656 ;i                         Allocated to registers r4 
                                   2657 ;------------------------------------------------------------
                                   2658 ;	fat.h:162: void HELPER_to_uppercase(char *s)
                                   2659 ;	-----------------------------------------
                                   2660 ;	 function HELPER_to_uppercase
                                   2661 ;	-----------------------------------------
      000A5C                       2662 _HELPER_to_uppercase:
      000A5C AD 82            [24] 2663 	mov	r5,dpl
      000A5E AE 83            [24] 2664 	mov	r6,dph
      000A60 AF F0            [24] 2665 	mov	r7,b
                                   2666 ;	fat.h:164: for(uint8_t i=0;i<255;i++)
      000A62 7C 00            [12] 2667 	mov	r4,#0x00
      000A64                       2668 00108$:
      000A64 BC FF 00         [24] 2669 	cjne	r4,#0xff,00132$
      000A67                       2670 00132$:
      000A67 50 2F            [24] 2671 	jnc	00110$
                                   2672 ;	fat.h:166: if(s[i]==0) return; //done
      000A69 EC               [12] 2673 	mov	a,r4
      000A6A 2D               [12] 2674 	add	a,r5
      000A6B F9               [12] 2675 	mov	r1,a
      000A6C E4               [12] 2676 	clr	a
      000A6D 3E               [12] 2677 	addc	a,r6
      000A6E FA               [12] 2678 	mov	r2,a
      000A6F 8F 03            [24] 2679 	mov	ar3,r7
      000A71 89 82            [24] 2680 	mov	dpl,r1
      000A73 8A 83            [24] 2681 	mov	dph,r2
      000A75 8B F0            [24] 2682 	mov	b,r3
      000A77 12r00r00         [24] 2683 	lcall	__gptrget
      000A7A F8               [12] 2684 	mov	r0,a
      000A7B 70 01            [24] 2685 	jnz	00102$
      000A7D 22               [24] 2686 	ret
      000A7E                       2687 00102$:
                                   2688 ;	fat.h:167: if('a'<=s[i] && s[i]<='z') s[i] = s[i] - 32;
      000A7E B8 61 00         [24] 2689 	cjne	r0,#0x61,00135$
      000A81                       2690 00135$:
      000A81 40 12            [24] 2691 	jc	00109$
      000A83 E8               [12] 2692 	mov	a,r0
      000A84 24 85            [12] 2693 	add	a,#0xff - 0x7a
      000A86 40 0D            [24] 2694 	jc	00109$
      000A88 E8               [12] 2695 	mov	a,r0
      000A89 24 E0            [12] 2696 	add	a,#0xe0
      000A8B F8               [12] 2697 	mov	r0,a
      000A8C 89 82            [24] 2698 	mov	dpl,r1
      000A8E 8A 83            [24] 2699 	mov	dph,r2
      000A90 8B F0            [24] 2700 	mov	b,r3
      000A92 12r00r00         [24] 2701 	lcall	__gptrput
      000A95                       2702 00109$:
                                   2703 ;	fat.h:164: for(uint8_t i=0;i<255;i++)
      000A95 0C               [12] 2704 	inc	r4
      000A96 80 CC            [24] 2705 	sjmp	00108$
      000A98                       2706 00110$:
                                   2707 ;	fat.h:169: }
      000A98 22               [24] 2708 	ret
                                   2709 ;------------------------------------------------------------
                                   2710 ;Allocation info for local variables in function 'HELPER_filename_to_8dot3filename'
                                   2711 ;------------------------------------------------------------
                                   2712 ;fname83                   Allocated with name '_HELPER_filename_to_8dot3filename_PARM_2'
                                   2713 ;fname                     Allocated with name '_HELPER_filename_to_8dot3filename_fname_65536_125'
                                   2714 ;index                     Allocated to registers r4 
                                   2715 ;i                         Allocated to registers r4 
                                   2716 ;i                         Allocated with name '_HELPER_filename_to_8dot3filename_i_131072_131'
                                   2717 ;------------------------------------------------------------
                                   2718 ;	fat.h:171: uint8_t HELPER_filename_to_8dot3filename( char *fname,  char *fname83)
                                   2719 ;	-----------------------------------------
                                   2720 ;	 function HELPER_filename_to_8dot3filename
                                   2721 ;	-----------------------------------------
      000A99                       2722 _HELPER_filename_to_8dot3filename:
                                   2723 ;	fat.h:176: HELPER_to_uppercase(fname);
      000A99 85 82*13         [24] 2724 	mov	_HELPER_filename_to_8dot3filename_fname_65536_125,dpl
      000A9C 85 83*14         [24] 2725 	mov	(_HELPER_filename_to_8dot3filename_fname_65536_125 + 1),dph
      000A9F 85 F0*15         [24] 2726 	mov	(_HELPER_filename_to_8dot3filename_fname_65536_125 + 2),b
      000AA2 12r0Ar5C         [24] 2727 	lcall	_HELPER_to_uppercase
                                   2728 ;	fat.h:184: for(uint8_t i=0;i<11;i++) fname83[i]=' '; //default fill by empty space
      000AA5 7C 00            [12] 2729 	mov	r4,#0x00
      000AA7                       2730 00120$:
      000AA7 BC 0B 00         [24] 2731 	cjne	r4,#0x0b,00178$
      000AAA                       2732 00178$:
      000AAA 50 18            [24] 2733 	jnc	00101$
      000AAC EC               [12] 2734 	mov	a,r4
      000AAD 25*10            [12] 2735 	add	a,_HELPER_filename_to_8dot3filename_PARM_2
      000AAF F9               [12] 2736 	mov	r1,a
      000AB0 E4               [12] 2737 	clr	a
      000AB1 35*11            [12] 2738 	addc	a,(_HELPER_filename_to_8dot3filename_PARM_2 + 1)
      000AB3 FA               [12] 2739 	mov	r2,a
      000AB4 AB*12            [24] 2740 	mov	r3,(_HELPER_filename_to_8dot3filename_PARM_2 + 2)
      000AB6 89 82            [24] 2741 	mov	dpl,r1
      000AB8 8A 83            [24] 2742 	mov	dph,r2
      000ABA 8B F0            [24] 2743 	mov	b,r3
      000ABC 74 20            [12] 2744 	mov	a,#0x20
      000ABE 12r00r00         [24] 2745 	lcall	__gptrput
      000AC1 0C               [12] 2746 	inc	r4
      000AC2 80 E3            [24] 2747 	sjmp	00120$
      000AC4                       2748 00101$:
                                   2749 ;	fat.h:185: fname83[11]=0; //set last character as 0;
      000AC4 74 0B            [12] 2750 	mov	a,#0x0b
      000AC6 25*10            [12] 2751 	add	a,_HELPER_filename_to_8dot3filename_PARM_2
      000AC8 FA               [12] 2752 	mov	r2,a
      000AC9 E4               [12] 2753 	clr	a
      000ACA 35*11            [12] 2754 	addc	a,(_HELPER_filename_to_8dot3filename_PARM_2 + 1)
      000ACC FB               [12] 2755 	mov	r3,a
      000ACD AC*12            [24] 2756 	mov	r4,(_HELPER_filename_to_8dot3filename_PARM_2 + 2)
      000ACF 8A 82            [24] 2757 	mov	dpl,r2
      000AD1 8B 83            [24] 2758 	mov	dph,r3
      000AD3 8C F0            [24] 2759 	mov	b,r4
      000AD5 E4               [12] 2760 	clr	a
      000AD6 12r00r00         [24] 2761 	lcall	__gptrput
                                   2762 ;	fat.h:188: for(index=0;index<9;index++)
      000AD9 7C 00            [12] 2763 	mov	r4,#0x00
      000ADB 7B 00            [12] 2764 	mov	r3,#0x00
      000ADD                       2765 00122$:
                                   2766 ;	fat.h:191: if(index==8 && fname[index]!='.') 
      000ADD BB 08 1D         [24] 2767 	cjne	r3,#0x08,00103$
      000AE0 EB               [12] 2768 	mov	a,r3
      000AE1 25*13            [12] 2769 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_125
      000AE3 F8               [12] 2770 	mov	r0,a
      000AE4 E4               [12] 2771 	clr	a
      000AE5 35*14            [12] 2772 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 1)
      000AE7 F9               [12] 2773 	mov	r1,a
      000AE8 AA*15            [24] 2774 	mov	r2,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 2)
      000AEA 88 82            [24] 2775 	mov	dpl,r0
      000AEC 89 83            [24] 2776 	mov	dph,r1
      000AEE 8A F0            [24] 2777 	mov	b,r2
      000AF0 12r00r00         [24] 2778 	lcall	__gptrget
      000AF3 F8               [12] 2779 	mov	r0,a
      000AF4 B8 2E 02         [24] 2780 	cjne	r0,#0x2e,00182$
      000AF7 80 04            [24] 2781 	sjmp	00103$
      000AF9                       2782 00182$:
                                   2783 ;	fat.h:196: return 1; //error - invalid filename as dot not found till 9th charcter
      000AF9 75 82 01         [24] 2784 	mov	dpl,#0x01
      000AFC 22               [24] 2785 	ret
      000AFD                       2786 00103$:
                                   2787 ;	fat.h:199: if(fname[index]==0) return 0; // success - we reached the end of the filename string before the dot character - filename has no extension
      000AFD EB               [12] 2788 	mov	a,r3
      000AFE 25*13            [12] 2789 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_125
      000B00 F8               [12] 2790 	mov	r0,a
      000B01 E4               [12] 2791 	clr	a
      000B02 35*14            [12] 2792 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 1)
      000B04 F9               [12] 2793 	mov	r1,a
      000B05 AA*15            [24] 2794 	mov	r2,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 2)
      000B07 88 82            [24] 2795 	mov	dpl,r0
      000B09 89 83            [24] 2796 	mov	dph,r1
      000B0B 8A F0            [24] 2797 	mov	b,r2
      000B0D 12r00r00         [24] 2798 	lcall	__gptrget
      000B10 FA               [12] 2799 	mov	r2,a
      000B11 70 03            [24] 2800 	jnz	00109$
      000B13 F5 82            [12] 2801 	mov	dpl,a
      000B15 22               [24] 2802 	ret
      000B16                       2803 00109$:
                                   2804 ;	fat.h:200: else if(fname[index]=='.') break; //found the dot, break the for loop
      000B16 BA 2E 02         [24] 2805 	cjne	r2,#0x2e,00184$
      000B19 80 1C            [24] 2806 	sjmp	00140$
      000B1B                       2807 00184$:
                                   2808 ;	fat.h:201: else fname83[index]=fname[index];
      000B1B EB               [12] 2809 	mov	a,r3
      000B1C 25*10            [12] 2810 	add	a,_HELPER_filename_to_8dot3filename_PARM_2
      000B1E F8               [12] 2811 	mov	r0,a
      000B1F E4               [12] 2812 	clr	a
      000B20 35*11            [12] 2813 	addc	a,(_HELPER_filename_to_8dot3filename_PARM_2 + 1)
      000B22 F9               [12] 2814 	mov	r1,a
      000B23 AF*12            [24] 2815 	mov	r7,(_HELPER_filename_to_8dot3filename_PARM_2 + 2)
      000B25 88 82            [24] 2816 	mov	dpl,r0
      000B27 89 83            [24] 2817 	mov	dph,r1
      000B29 8F F0            [24] 2818 	mov	b,r7
      000B2B EA               [12] 2819 	mov	a,r2
      000B2C 12r00r00         [24] 2820 	lcall	__gptrput
                                   2821 ;	fat.h:188: for(index=0;index<9;index++)
      000B2F 0B               [12] 2822 	inc	r3
      000B30 8B 04            [24] 2823 	mov	ar4,r3
      000B32 BB 09 00         [24] 2824 	cjne	r3,#0x09,00185$
      000B35                       2825 00185$:
      000B35 40 A6            [24] 2826 	jc	00122$
                                   2827 ;	fat.h:204: for(uint8_t i=0;i<4;i++)
      000B37                       2828 00140$:
      000B37 75*16 00         [24] 2829 	mov	_HELPER_filename_to_8dot3filename_i_131072_131,#0x00
      000B3A                       2830 00125$:
      000B3A 74 FC            [12] 2831 	mov	a,#0x100 - 0x04
      000B3C 25*16            [12] 2832 	add	a,_HELPER_filename_to_8dot3filename_i_131072_131
      000B3E 50 03            [24] 2833 	jnc	00187$
      000B40 02r0BrDD         [24] 2834 	ljmp	00118$
      000B43                       2835 00187$:
                                   2836 ;	fat.h:206: if(i==3 && fname[index+i+1]!=0) 
      000B43 74 03            [12] 2837 	mov	a,#0x03
      000B45 B5*16 2C         [24] 2838 	cjne	a,_HELPER_filename_to_8dot3filename_i_131072_131,00113$
      000B48 8C 05            [24] 2839 	mov	ar5,r4
      000B4A 7E 00            [12] 2840 	mov	r6,#0x00
      000B4C AA*16            [24] 2841 	mov	r2,_HELPER_filename_to_8dot3filename_i_131072_131
      000B4E 7B 00            [12] 2842 	mov	r3,#0x00
      000B50 EA               [12] 2843 	mov	a,r2
      000B51 2D               [12] 2844 	add	a,r5
      000B52 FD               [12] 2845 	mov	r5,a
      000B53 EB               [12] 2846 	mov	a,r3
      000B54 3E               [12] 2847 	addc	a,r6
      000B55 FE               [12] 2848 	mov	r6,a
      000B56 0D               [12] 2849 	inc	r5
      000B57 BD 00 01         [24] 2850 	cjne	r5,#0x00,00190$
      000B5A 0E               [12] 2851 	inc	r6
      000B5B                       2852 00190$:
      000B5B ED               [12] 2853 	mov	a,r5
      000B5C 25*13            [12] 2854 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_125
      000B5E FD               [12] 2855 	mov	r5,a
      000B5F EE               [12] 2856 	mov	a,r6
      000B60 35*14            [12] 2857 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 1)
      000B62 FE               [12] 2858 	mov	r6,a
      000B63 AB*15            [24] 2859 	mov	r3,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 2)
      000B65 8D 82            [24] 2860 	mov	dpl,r5
      000B67 8E 83            [24] 2861 	mov	dph,r6
      000B69 8B F0            [24] 2862 	mov	b,r3
      000B6B 12r00r00         [24] 2863 	lcall	__gptrget
      000B6E 60 04            [24] 2864 	jz	00113$
                                   2865 ;	fat.h:211: return 2; // error - extension has more than 3 characters
      000B70 75 82 02         [24] 2866 	mov	dpl,#0x02
      000B73 22               [24] 2867 	ret
      000B74                       2868 00113$:
                                   2869 ;	fat.h:215: if(fname[index+i+1]==0) 
      000B74 8C 05            [24] 2870 	mov	ar5,r4
      000B76 7E 00            [12] 2871 	mov	r6,#0x00
      000B78 AA*16            [24] 2872 	mov	r2,_HELPER_filename_to_8dot3filename_i_131072_131
      000B7A 7B 00            [12] 2873 	mov	r3,#0x00
      000B7C EA               [12] 2874 	mov	a,r2
      000B7D 2D               [12] 2875 	add	a,r5
      000B7E F8               [12] 2876 	mov	r0,a
      000B7F EB               [12] 2877 	mov	a,r3
      000B80 3E               [12] 2878 	addc	a,r6
      000B81 F9               [12] 2879 	mov	r1,a
      000B82 08               [12] 2880 	inc	r0
      000B83 B8 00 01         [24] 2881 	cjne	r0,#0x00,00192$
      000B86 09               [12] 2882 	inc	r1
      000B87                       2883 00192$:
      000B87 E8               [12] 2884 	mov	a,r0
      000B88 25*13            [12] 2885 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_125
      000B8A F8               [12] 2886 	mov	r0,a
      000B8B E9               [12] 2887 	mov	a,r1
      000B8C 35*14            [12] 2888 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 1)
      000B8E F9               [12] 2889 	mov	r1,a
      000B8F AF*15            [24] 2890 	mov	r7,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 2)
      000B91 88 82            [24] 2891 	mov	dpl,r0
      000B93 89 83            [24] 2892 	mov	dph,r1
      000B95 8F F0            [24] 2893 	mov	b,r7
      000B97 12r00r00         [24] 2894 	lcall	__gptrget
                                   2895 ;	fat.h:224: return 0; 
      000B9A 70 03            [24] 2896 	jnz	00116$
      000B9C F5 82            [12] 2897 	mov	dpl,a
      000B9E 22               [24] 2898 	ret
      000B9F                       2899 00116$:
                                   2900 ;	fat.h:226: else fname83[8+i]=fname[index+i+1]; // in a valid fname, there is just an extra dot in fname than in fname83
      000B9F 74 08            [12] 2901 	mov	a,#0x08
      000BA1 2A               [12] 2902 	add	a,r2
      000BA2 F9               [12] 2903 	mov	r1,a
      000BA3 E4               [12] 2904 	clr	a
      000BA4 3B               [12] 2905 	addc	a,r3
      000BA5 FF               [12] 2906 	mov	r7,a
      000BA6 E9               [12] 2907 	mov	a,r1
      000BA7 25*10            [12] 2908 	add	a,_HELPER_filename_to_8dot3filename_PARM_2
      000BA9 F9               [12] 2909 	mov	r1,a
      000BAA EF               [12] 2910 	mov	a,r7
      000BAB 35*11            [12] 2911 	addc	a,(_HELPER_filename_to_8dot3filename_PARM_2 + 1)
      000BAD F8               [12] 2912 	mov	r0,a
      000BAE AF*12            [24] 2913 	mov	r7,(_HELPER_filename_to_8dot3filename_PARM_2 + 2)
      000BB0 EA               [12] 2914 	mov	a,r2
      000BB1 2D               [12] 2915 	add	a,r5
      000BB2 FD               [12] 2916 	mov	r5,a
      000BB3 EB               [12] 2917 	mov	a,r3
      000BB4 3E               [12] 2918 	addc	a,r6
      000BB5 FE               [12] 2919 	mov	r6,a
      000BB6 0D               [12] 2920 	inc	r5
      000BB7 BD 00 01         [24] 2921 	cjne	r5,#0x00,00194$
      000BBA 0E               [12] 2922 	inc	r6
      000BBB                       2923 00194$:
      000BBB ED               [12] 2924 	mov	a,r5
      000BBC 25*13            [12] 2925 	add	a,_HELPER_filename_to_8dot3filename_fname_65536_125
      000BBE FD               [12] 2926 	mov	r5,a
      000BBF EE               [12] 2927 	mov	a,r6
      000BC0 35*14            [12] 2928 	addc	a,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 1)
      000BC2 FE               [12] 2929 	mov	r6,a
      000BC3 AB*15            [24] 2930 	mov	r3,(_HELPER_filename_to_8dot3filename_fname_65536_125 + 2)
      000BC5 8D 82            [24] 2931 	mov	dpl,r5
      000BC7 8E 83            [24] 2932 	mov	dph,r6
      000BC9 8B F0            [24] 2933 	mov	b,r3
      000BCB 12r00r00         [24] 2934 	lcall	__gptrget
      000BCE FD               [12] 2935 	mov	r5,a
      000BCF 89 82            [24] 2936 	mov	dpl,r1
      000BD1 88 83            [24] 2937 	mov	dph,r0
      000BD3 8F F0            [24] 2938 	mov	b,r7
      000BD5 12r00r00         [24] 2939 	lcall	__gptrput
                                   2940 ;	fat.h:204: for(uint8_t i=0;i<4;i++)
      000BD8 05*16            [12] 2941 	inc	_HELPER_filename_to_8dot3filename_i_131072_131
      000BDA 02r0Br3A         [24] 2942 	ljmp	00125$
      000BDD                       2943 00118$:
                                   2944 ;	fat.h:229: return 3;// if reached here, then it is an error
      000BDD 75 82 03         [24] 2945 	mov	dpl,#0x03
                                   2946 ;	fat.h:230: }
      000BE0 22               [24] 2947 	ret
                                   2948 ;------------------------------------------------------------
                                   2949 ;Allocation info for local variables in function 'MBR_CHECK__SIGNATURE'
                                   2950 ;------------------------------------------------------------
                                   2951 ;signature                 Allocated to stack - _bp +1
                                   2952 ;------------------------------------------------------------
                                   2953 ;	fat.h:244: uint8_t MBR_CHECK__SIGNATURE() __reentrant
                                   2954 ;	-----------------------------------------
                                   2955 ;	 function MBR_CHECK__SIGNATURE
                                   2956 ;	-----------------------------------------
      000BE1                       2957 _MBR_CHECK__SIGNATURE:
      000BE1 C0*00            [24] 2958 	push	_bp
      000BE3 85 81*00         [24] 2959 	mov	_bp,sp
      000BE6 05 81            [12] 2960 	inc	sp
      000BE8 05 81            [12] 2961 	inc	sp
                                   2962 ;	fat.h:247: SDread(0,510,2,signature);
      000BEA A9*00            [24] 2963 	mov	r1,_bp
      000BEC 09               [12] 2964 	inc	r1
      000BED 89 05            [24] 2965 	mov	ar5,r1
      000BEF 7E 00            [12] 2966 	mov	r6,#0x00
      000BF1 7F 40            [12] 2967 	mov	r7,#0x40
      000BF3 C0 01            [24] 2968 	push	ar1
      000BF5 C0 05            [24] 2969 	push	ar5
      000BF7 C0 06            [24] 2970 	push	ar6
      000BF9 C0 07            [24] 2971 	push	ar7
      000BFB 74 02            [12] 2972 	mov	a,#0x02
      000BFD C0 E0            [24] 2973 	push	acc
      000BFF E4               [12] 2974 	clr	a
      000C00 C0 E0            [24] 2975 	push	acc
      000C02 74 FE            [12] 2976 	mov	a,#0xfe
      000C04 C0 E0            [24] 2977 	push	acc
      000C06 F4               [12] 2978 	cpl	a
      000C07 C0 E0            [24] 2979 	push	acc
      000C09 90 00 00         [24] 2980 	mov	dptr,#(0x00&0x00ff)
      000C0C E4               [12] 2981 	clr	a
      000C0D F5 F0            [12] 2982 	mov	b,a
      000C0F 12r07r11         [24] 2983 	lcall	_SDread
      000C12 E5 81            [12] 2984 	mov	a,sp
      000C14 24 F9            [12] 2985 	add	a,#0xf9
      000C16 F5 81            [12] 2986 	mov	sp,a
      000C18 D0 01            [24] 2987 	pop	ar1
                                   2988 ;	fat.h:256: if(signature[0]==0x55 && signature[1]==0xAA) return 0;
      000C1A 87 07            [24] 2989 	mov	ar7,@r1
      000C1C BF 55 0B         [24] 2990 	cjne	r7,#0x55,00102$
      000C1F 09               [12] 2991 	inc	r1
      000C20 87 07            [24] 2992 	mov	ar7,@r1
      000C22 BF AA 05         [24] 2993 	cjne	r7,#0xaa,00102$
      000C25 75 82 00         [24] 2994 	mov	dpl,#0x00
      000C28 80 03            [24] 2995 	sjmp	00105$
      000C2A                       2996 00102$:
                                   2997 ;	fat.h:257: else return 1;
      000C2A 75 82 01         [24] 2998 	mov	dpl,#0x01
      000C2D                       2999 00105$:
                                   3000 ;	fat.h:258: }
      000C2D 85*00 81         [24] 3001 	mov	sp,_bp
      000C30 D0*00            [24] 3002 	pop	_bp
      000C32 22               [24] 3003 	ret
                                   3004 ;------------------------------------------------------------
                                   3005 ;Allocation info for local variables in function 'MBR_LOAD_PARTITION_TABLE_ENTRY'
                                   3006 ;------------------------------------------------------------
                                   3007 ;partition_number          Allocated to registers r7 
                                   3008 ;temp                      Allocated with name '_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_137'
                                   3009 ;offset                    Allocated to registers r5 r6 
                                   3010 ;------------------------------------------------------------
                                   3011 ;	fat.h:260: uint8_t MBR_LOAD_PARTITION_TABLE_ENTRY(uint8_t partition_number)
                                   3012 ;	-----------------------------------------
                                   3013 ;	 function MBR_LOAD_PARTITION_TABLE_ENTRY
                                   3014 ;	-----------------------------------------
      000C33                       3015 _MBR_LOAD_PARTITION_TABLE_ENTRY:
      000C33 AF 82            [24] 3016 	mov	r7,dpl
                                   3017 ;	fat.h:263: __idata uint16_t offset= 446 + partition_number*16; // get to the nth partition entry out of 0,1,2,3
      000C35 8F 05            [24] 3018 	mov	ar5,r7
      000C37 E4               [12] 3019 	clr	a
      000C38 CD               [12] 3020 	xch	a,r5
      000C39 C4               [12] 3021 	swap	a
      000C3A CD               [12] 3022 	xch	a,r5
      000C3B 6D               [12] 3023 	xrl	a,r5
      000C3C CD               [12] 3024 	xch	a,r5
      000C3D 54 F0            [12] 3025 	anl	a,#0xf0
      000C3F CD               [12] 3026 	xch	a,r5
      000C40 6D               [12] 3027 	xrl	a,r5
      000C41 FE               [12] 3028 	mov	r6,a
      000C42 74 BE            [12] 3029 	mov	a,#0xbe
      000C44 2D               [12] 3030 	add	a,r5
      000C45 FD               [12] 3031 	mov	r5,a
      000C46 74 01            [12] 3032 	mov	a,#0x01
      000C48 3E               [12] 3033 	addc	a,r6
      000C49 FE               [12] 3034 	mov	r6,a
                                   3035 ;	fat.h:265: if(partition_number>4) 
      000C4A EF               [12] 3036 	mov	a,r7
      000C4B 24 FB            [12] 3037 	add	a,#0xff - 0x04
      000C4D 50 04            [24] 3038 	jnc	00102$
                                   3039 ;	fat.h:272: return 1; //error
      000C4F 75 82 01         [24] 3040 	mov	dpl,#0x01
      000C52 22               [24] 3041 	ret
      000C53                       3042 00102$:
                                   3043 ;	fat.h:275: SDread(0,offset,16,temp);
      000C53 74r41            [12] 3044 	mov	a,#_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_137
      000C55 C0 E0            [24] 3045 	push	acc
      000C57 74s00            [12] 3046 	mov	a,#(_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_137 >> 8)
      000C59 C0 E0            [24] 3047 	push	acc
      000C5B 74 40            [12] 3048 	mov	a,#0x40
      000C5D C0 E0            [24] 3049 	push	acc
      000C5F 74 10            [12] 3050 	mov	a,#0x10
      000C61 C0 E0            [24] 3051 	push	acc
      000C63 E4               [12] 3052 	clr	a
      000C64 C0 E0            [24] 3053 	push	acc
      000C66 C0 05            [24] 3054 	push	ar5
      000C68 C0 06            [24] 3055 	push	ar6
      000C6A 90 00 00         [24] 3056 	mov	dptr,#(0x00&0x00ff)
      000C6D E4               [12] 3057 	clr	a
      000C6E F5 F0            [12] 3058 	mov	b,a
      000C70 12r07r11         [24] 3059 	lcall	_SDread
      000C73 E5 81            [12] 3060 	mov	a,sp
      000C75 24 F9            [12] 3061 	add	a,#0xf9
      000C77 F5 81            [12] 3062 	mov	sp,a
                                   3063 ;	fat.h:277: __global_partitionTableEntry.type = temp[4]; // type offset is 4
      000C79 78r45            [12] 3064 	mov	r0,#(_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_137 + 0x0004)
      000C7B 86 07            [24] 3065 	mov	ar7,@r0
      000C7D 78r00            [12] 3066 	mov	r0,#___global_partitionTableEntry
      000C7F A6 07            [24] 3067 	mov	@r0,ar7
                                   3068 ;	fat.h:278: __global_partitionTableEntry.start=HELPER_load_littleendian32(&temp[8]); //partition start LBA offset is 8
      000C81 90r00r49         [24] 3069 	mov	dptr,#(_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_137 + 0x0008)
      000C84 75 F0 40         [24] 3070 	mov	b,#0x40
      000C87 12r08r85         [24] 3071 	lcall	_HELPER_load_littleendian32
      000C8A AC 82            [24] 3072 	mov	r4,dpl
      000C8C AD 83            [24] 3073 	mov	r5,dph
      000C8E AE F0            [24] 3074 	mov	r6,b
      000C90 FF               [12] 3075 	mov	r7,a
      000C91 78r01            [12] 3076 	mov	r0,#(___global_partitionTableEntry + 0x0001)
      000C93 A6 04            [24] 3077 	mov	@r0,ar4
      000C95 08               [12] 3078 	inc	r0
      000C96 A6 05            [24] 3079 	mov	@r0,ar5
      000C98 08               [12] 3080 	inc	r0
      000C99 A6 06            [24] 3081 	mov	@r0,ar6
      000C9B 08               [12] 3082 	inc	r0
      000C9C A6 07            [24] 3083 	mov	@r0,ar7
                                   3084 ;	fat.h:279: __global_partitionTableEntry.size=HELPER_load_littleendian32(&temp[12]); //partiiton size offset is 12
      000C9E 90r00r4D         [24] 3085 	mov	dptr,#(_MBR_LOAD_PARTITION_TABLE_ENTRY_temp_65536_137 + 0x000c)
      000CA1 75 F0 40         [24] 3086 	mov	b,#0x40
      000CA4 12r08r85         [24] 3087 	lcall	_HELPER_load_littleendian32
      000CA7 AC 82            [24] 3088 	mov	r4,dpl
      000CA9 AD 83            [24] 3089 	mov	r5,dph
      000CAB AE F0            [24] 3090 	mov	r6,b
      000CAD FF               [12] 3091 	mov	r7,a
      000CAE 78r05            [12] 3092 	mov	r0,#(___global_partitionTableEntry + 0x0005)
      000CB0 A6 04            [24] 3093 	mov	@r0,ar4
      000CB2 08               [12] 3094 	inc	r0
      000CB3 A6 05            [24] 3095 	mov	@r0,ar5
      000CB5 08               [12] 3096 	inc	r0
      000CB6 A6 06            [24] 3097 	mov	@r0,ar6
      000CB8 08               [12] 3098 	inc	r0
      000CB9 A6 07            [24] 3099 	mov	@r0,ar7
                                   3100 ;	fat.h:281: return 0;
      000CBB 75 82 00         [24] 3101 	mov	dpl,#0x00
                                   3102 ;	fat.h:283: }
      000CBE 22               [24] 3103 	ret
                                   3104 ;------------------------------------------------------------
                                   3105 ;Allocation info for local variables in function 'MBR_DETECT_FAT16'
                                   3106 ;------------------------------------------------------------
                                   3107 ;result                    Allocated to registers r7 
                                   3108 ;i                         Allocated to registers r6 
                                   3109 ;------------------------------------------------------------
                                   3110 ;	fat.h:285: uint8_t MBR_DETECT_FAT16()
                                   3111 ;	-----------------------------------------
                                   3112 ;	 function MBR_DETECT_FAT16
                                   3113 ;	-----------------------------------------
      000CBF                       3114 _MBR_DETECT_FAT16:
                                   3115 ;	fat.h:290: uint8_t result=0;
      000CBF 7F 00            [12] 3116 	mov	r7,#0x00
                                   3117 ;	fat.h:292: for(uint8_t i=0;i<4;i++) 
      000CC1 7E 00            [12] 3118 	mov	r6,#0x00
      000CC3                       3119 00105$:
      000CC3 BE 04 00         [24] 3120 	cjne	r6,#0x04,00122$
      000CC6                       3121 00122$:
      000CC6 50 2B            [24] 3122 	jnc	00103$
                                   3123 ;	fat.h:294: MBR_LOAD_PARTITION_TABLE_ENTRY(i);
      000CC8 8E 82            [24] 3124 	mov	dpl,r6
      000CCA C0 07            [24] 3125 	push	ar7
      000CCC C0 06            [24] 3126 	push	ar6
      000CCE 12r0Cr33         [24] 3127 	lcall	_MBR_LOAD_PARTITION_TABLE_ENTRY
      000CD1 D0 06            [24] 3128 	pop	ar6
      000CD3 D0 07            [24] 3129 	pop	ar7
                                   3130 ;	fat.h:295: if(__global_partitionTableEntry.type==FAT16_PARTITION_TYPE_ID) result |= (1<<i); //set corresponding bit
      000CD5 78r00            [12] 3131 	mov	r0,#___global_partitionTableEntry
      000CD7 86 05            [24] 3132 	mov	ar5,@r0
      000CD9 BD 06 14         [24] 3133 	cjne	r5,#0x06,00106$
      000CDC 8E 05            [24] 3134 	mov	ar5,r6
      000CDE 8D F0            [24] 3135 	mov	b,r5
      000CE0 05 F0            [12] 3136 	inc	b
      000CE2 74 01            [12] 3137 	mov	a,#0x01
      000CE4 80 02            [24] 3138 	sjmp	00128$
      000CE6                       3139 00126$:
      000CE6 25 E0            [12] 3140 	add	a,acc
      000CE8                       3141 00128$:
      000CE8 D5 F0 FB         [24] 3142 	djnz	b,00126$
      000CEB FD               [12] 3143 	mov	r5,a
      000CEC 8F 04            [24] 3144 	mov	ar4,r7
      000CEE 4C               [12] 3145 	orl	a,r4
      000CEF FF               [12] 3146 	mov	r7,a
      000CF0                       3147 00106$:
                                   3148 ;	fat.h:292: for(uint8_t i=0;i<4;i++) 
      000CF0 0E               [12] 3149 	inc	r6
      000CF1 80 D0            [24] 3150 	sjmp	00105$
      000CF3                       3151 00103$:
                                   3152 ;	fat.h:304: return result;
      000CF3 8F 82            [24] 3153 	mov	dpl,r7
                                   3154 ;	fat.h:305: }
      000CF5 22               [24] 3155 	ret
                                   3156 ;------------------------------------------------------------
                                   3157 ;Allocation info for local variables in function 'VBR_DUMP'
                                   3158 ;------------------------------------------------------------
                                   3159 ;	fat.h:312: void VBR_DUMP() __reentrant
                                   3160 ;	-----------------------------------------
                                   3161 ;	 function VBR_DUMP
                                   3162 ;	-----------------------------------------
      000CF6                       3163 _VBR_DUMP:
                                   3164 ;	fat.h:314: UartPrint("VBR: start,bps,spc,reservedSectors,nfat,nroote,spf,fat_start,roote_start,data_start\n"); 
      000CF6 90r00r1D         [24] 3165 	mov	dptr,#___str_1
      000CF9 75 F0 80         [24] 3166 	mov	b,#0x80
      000CFC 12r01r1B         [24] 3167 	lcall	_UartPrint
                                   3168 ;	fat.h:315: UartPrintNumber(__global_vbr.volumeStartSector);UartWrite(',');
      000CFF 78r09            [12] 3169 	mov	r0,#___global_vbr
      000D01 86 04            [24] 3170 	mov	ar4,@r0
      000D03 08               [12] 3171 	inc	r0
      000D04 86 05            [24] 3172 	mov	ar5,@r0
      000D06 08               [12] 3173 	inc	r0
      000D07 86 06            [24] 3174 	mov	ar6,@r0
      000D09 08               [12] 3175 	inc	r0
      000D0A 86 07            [24] 3176 	mov	ar7,@r0
      000D0C 8C 82            [24] 3177 	mov	dpl,r4
      000D0E 8D 83            [24] 3178 	mov	dph,r5
      000D10 8E F0            [24] 3179 	mov	b,r6
      000D12 EF               [12] 3180 	mov	a,r7
      000D13 12r02r61         [24] 3181 	lcall	_UartPrintNumber
      000D16 75 82 2C         [24] 3182 	mov	dpl,#0x2c
      000D19 12r00r95         [24] 3183 	lcall	_UartWrite
                                   3184 ;	fat.h:316: UartPrintNumber(__global_vbr.bps);UartWrite(',');
      000D1C 78r0F            [12] 3185 	mov	r0,#(___global_vbr + 0x0006)
      000D1E 86 06            [24] 3186 	mov	ar6,@r0
      000D20 08               [12] 3187 	inc	r0
      000D21 86 07            [24] 3188 	mov	ar7,@r0
      000D23 7D 00            [12] 3189 	mov	r5,#0x00
      000D25 7C 00            [12] 3190 	mov	r4,#0x00
      000D27 8E 82            [24] 3191 	mov	dpl,r6
      000D29 8F 83            [24] 3192 	mov	dph,r7
      000D2B 8D F0            [24] 3193 	mov	b,r5
      000D2D EC               [12] 3194 	mov	a,r4
      000D2E 12r02r61         [24] 3195 	lcall	_UartPrintNumber
      000D31 75 82 2C         [24] 3196 	mov	dpl,#0x2c
      000D34 12r00r95         [24] 3197 	lcall	_UartWrite
                                   3198 ;	fat.h:317: UartPrintNumber(__global_vbr.spc);UartWrite(',');
      000D37 78r11            [12] 3199 	mov	r0,#(___global_vbr + 0x0008)
      000D39 86 07            [24] 3200 	mov	ar7,@r0
      000D3B 7E 00            [12] 3201 	mov	r6,#0x00
      000D3D 7D 00            [12] 3202 	mov	r5,#0x00
      000D3F 7C 00            [12] 3203 	mov	r4,#0x00
      000D41 8F 82            [24] 3204 	mov	dpl,r7
      000D43 8E 83            [24] 3205 	mov	dph,r6
      000D45 8D F0            [24] 3206 	mov	b,r5
      000D47 EC               [12] 3207 	mov	a,r4
      000D48 12r02r61         [24] 3208 	lcall	_UartPrintNumber
      000D4B 75 82 2C         [24] 3209 	mov	dpl,#0x2c
      000D4E 12r00r95         [24] 3210 	lcall	_UartWrite
                                   3211 ;	fat.h:318: UartPrintNumber(__global_vbr.reservedSectors);UartWrite(',');
      000D51 78r0D            [12] 3212 	mov	r0,#(___global_vbr + 0x0004)
      000D53 86 06            [24] 3213 	mov	ar6,@r0
      000D55 08               [12] 3214 	inc	r0
      000D56 86 07            [24] 3215 	mov	ar7,@r0
      000D58 7D 00            [12] 3216 	mov	r5,#0x00
      000D5A 7C 00            [12] 3217 	mov	r4,#0x00
      000D5C 8E 82            [24] 3218 	mov	dpl,r6
      000D5E 8F 83            [24] 3219 	mov	dph,r7
      000D60 8D F0            [24] 3220 	mov	b,r5
      000D62 EC               [12] 3221 	mov	a,r4
      000D63 12r02r61         [24] 3222 	lcall	_UartPrintNumber
      000D66 75 82 2C         [24] 3223 	mov	dpl,#0x2c
      000D69 12r00r95         [24] 3224 	lcall	_UartWrite
                                   3225 ;	fat.h:319: UartPrintNumber(__global_vbr.nfat);UartWrite(',');
      000D6C 78r12            [12] 3226 	mov	r0,#(___global_vbr + 0x0009)
      000D6E 86 06            [24] 3227 	mov	ar6,@r0
      000D70 08               [12] 3228 	inc	r0
      000D71 86 07            [24] 3229 	mov	ar7,@r0
      000D73 7D 00            [12] 3230 	mov	r5,#0x00
      000D75 7C 00            [12] 3231 	mov	r4,#0x00
      000D77 8E 82            [24] 3232 	mov	dpl,r6
      000D79 8F 83            [24] 3233 	mov	dph,r7
      000D7B 8D F0            [24] 3234 	mov	b,r5
      000D7D EC               [12] 3235 	mov	a,r4
      000D7E 12r02r61         [24] 3236 	lcall	_UartPrintNumber
      000D81 75 82 2C         [24] 3237 	mov	dpl,#0x2c
      000D84 12r00r95         [24] 3238 	lcall	_UartWrite
                                   3239 ;	fat.h:320: UartPrintNumber(__global_vbr.nroote);UartWrite(',');
      000D87 78r16            [12] 3240 	mov	r0,#(___global_vbr + 0x000d)
      000D89 86 06            [24] 3241 	mov	ar6,@r0
      000D8B 08               [12] 3242 	inc	r0
      000D8C 86 07            [24] 3243 	mov	ar7,@r0
      000D8E 7D 00            [12] 3244 	mov	r5,#0x00
      000D90 7C 00            [12] 3245 	mov	r4,#0x00
      000D92 8E 82            [24] 3246 	mov	dpl,r6
      000D94 8F 83            [24] 3247 	mov	dph,r7
      000D96 8D F0            [24] 3248 	mov	b,r5
      000D98 EC               [12] 3249 	mov	a,r4
      000D99 12r02r61         [24] 3250 	lcall	_UartPrintNumber
      000D9C 75 82 2C         [24] 3251 	mov	dpl,#0x2c
      000D9F 12r00r95         [24] 3252 	lcall	_UartWrite
                                   3253 ;	fat.h:321: UartPrintNumber(__global_vbr.spf);UartWrite(',');
      000DA2 78r14            [12] 3254 	mov	r0,#(___global_vbr + 0x000b)
      000DA4 86 06            [24] 3255 	mov	ar6,@r0
      000DA6 08               [12] 3256 	inc	r0
      000DA7 86 07            [24] 3257 	mov	ar7,@r0
      000DA9 7D 00            [12] 3258 	mov	r5,#0x00
      000DAB 7C 00            [12] 3259 	mov	r4,#0x00
      000DAD 8E 82            [24] 3260 	mov	dpl,r6
      000DAF 8F 83            [24] 3261 	mov	dph,r7
      000DB1 8D F0            [24] 3262 	mov	b,r5
      000DB3 EC               [12] 3263 	mov	a,r4
      000DB4 12r02r61         [24] 3264 	lcall	_UartPrintNumber
      000DB7 75 82 2C         [24] 3265 	mov	dpl,#0x2c
      000DBA 12r00r95         [24] 3266 	lcall	_UartWrite
                                   3267 ;	fat.h:323: UartPrintNumber(__global_vbr.addr_fat_start);UartWrite(',');
      000DBD 78r1C            [12] 3268 	mov	r0,#(___global_vbr + 0x0013)
      000DBF 86 04            [24] 3269 	mov	ar4,@r0
      000DC1 08               [12] 3270 	inc	r0
      000DC2 86 05            [24] 3271 	mov	ar5,@r0
      000DC4 08               [12] 3272 	inc	r0
      000DC5 86 06            [24] 3273 	mov	ar6,@r0
      000DC7 08               [12] 3274 	inc	r0
      000DC8 86 07            [24] 3275 	mov	ar7,@r0
      000DCA 8C 82            [24] 3276 	mov	dpl,r4
      000DCC 8D 83            [24] 3277 	mov	dph,r5
      000DCE 8E F0            [24] 3278 	mov	b,r6
      000DD0 EF               [12] 3279 	mov	a,r7
      000DD1 12r02r61         [24] 3280 	lcall	_UartPrintNumber
      000DD4 75 82 2C         [24] 3281 	mov	dpl,#0x2c
      000DD7 12r00r95         [24] 3282 	lcall	_UartWrite
                                   3283 ;	fat.h:324: UartPrintNumber(__global_vbr.addr_roote_start);UartWrite(',');
      000DDA 78r20            [12] 3284 	mov	r0,#(___global_vbr + 0x0017)
      000DDC 86 04            [24] 3285 	mov	ar4,@r0
      000DDE 08               [12] 3286 	inc	r0
      000DDF 86 05            [24] 3287 	mov	ar5,@r0
      000DE1 08               [12] 3288 	inc	r0
      000DE2 86 06            [24] 3289 	mov	ar6,@r0
      000DE4 08               [12] 3290 	inc	r0
      000DE5 86 07            [24] 3291 	mov	ar7,@r0
      000DE7 8C 82            [24] 3292 	mov	dpl,r4
      000DE9 8D 83            [24] 3293 	mov	dph,r5
      000DEB 8E F0            [24] 3294 	mov	b,r6
      000DED EF               [12] 3295 	mov	a,r7
      000DEE 12r02r61         [24] 3296 	lcall	_UartPrintNumber
      000DF1 75 82 2C         [24] 3297 	mov	dpl,#0x2c
      000DF4 12r00r95         [24] 3298 	lcall	_UartWrite
                                   3299 ;	fat.h:325: UartPrintNumber(__global_vbr.addr_data_start);UartWrite(',');
      000DF7 78r24            [12] 3300 	mov	r0,#(___global_vbr + 0x001b)
      000DF9 86 04            [24] 3301 	mov	ar4,@r0
      000DFB 08               [12] 3302 	inc	r0
      000DFC 86 05            [24] 3303 	mov	ar5,@r0
      000DFE 08               [12] 3304 	inc	r0
      000DFF 86 06            [24] 3305 	mov	ar6,@r0
      000E01 08               [12] 3306 	inc	r0
      000E02 86 07            [24] 3307 	mov	ar7,@r0
      000E04 8C 82            [24] 3308 	mov	dpl,r4
      000E06 8D 83            [24] 3309 	mov	dph,r5
      000E08 8E F0            [24] 3310 	mov	b,r6
      000E0A EF               [12] 3311 	mov	a,r7
      000E0B 12r02r61         [24] 3312 	lcall	_UartPrintNumber
      000E0E 75 82 2C         [24] 3313 	mov	dpl,#0x2c
      000E11 12r00r95         [24] 3314 	lcall	_UartWrite
                                   3315 ;	fat.h:326: UartWrite('\n');
      000E14 75 82 0A         [24] 3316 	mov	dpl,#0x0a
                                   3317 ;	fat.h:327: }
      000E17 02r00r95         [24] 3318 	ljmp	_UartWrite
                                   3319 ;------------------------------------------------------------
                                   3320 ;Allocation info for local variables in function 'VBR_MOUNT_VBR'
                                   3321 ;------------------------------------------------------------
                                   3322 ;partition_number          Allocated to registers r7 
                                   3323 ;sloc0                     Allocated with name '_VBR_MOUNT_VBR_sloc0_1_0'
                                   3324 ;temp                      Allocated with name '_VBR_MOUNT_VBR_temp_65536_144'
                                   3325 ;------------------------------------------------------------
                                   3326 ;	fat.h:330: uint8_t VBR_MOUNT_VBR(uint8_t partition_number)
                                   3327 ;	-----------------------------------------
                                   3328 ;	 function VBR_MOUNT_VBR
                                   3329 ;	-----------------------------------------
      000E1A                       3330 _VBR_MOUNT_VBR:
      000E1A AF 82            [24] 3331 	mov	r7,dpl
                                   3332 ;	fat.h:336: if(__global_nthPartitionVBRmounted == partition_number ) 
      000E1C 78r28            [12] 3333 	mov	r0,#___global_nthPartitionVBRmounted
      000E1E E6               [12] 3334 	mov	a,@r0
      000E1F B5 07 04         [24] 3335 	cjne	a,ar7,00102$
                                   3336 ;	fat.h:344: return 0; //return if already loaded, else continue;
      000E22 75 82 00         [24] 3337 	mov	dpl,#0x00
      000E25 22               [24] 3338 	ret
      000E26                       3339 00102$:
                                   3340 ;	fat.h:355: __global_nthPartitionVBRmounted=partition_number; //set global variable
      000E26 78r28            [12] 3341 	mov	r0,#___global_nthPartitionVBRmounted
      000E28 A6 07            [24] 3342 	mov	@r0,ar7
                                   3343 ;	fat.h:358: if(MBR_LOAD_PARTITION_TABLE_ENTRY(partition_number))  //if error, 0 is success
      000E2A 8F 82            [24] 3344 	mov	dpl,r7
      000E2C 12r0Cr33         [24] 3345 	lcall	_MBR_LOAD_PARTITION_TABLE_ENTRY
      000E2F E5 82            [12] 3346 	mov	a,dpl
      000E31 60 04            [24] 3347 	jz	00104$
                                   3348 ;	fat.h:360: return 1; //return error
      000E33 75 82 01         [24] 3349 	mov	dpl,#0x01
      000E36 22               [24] 3350 	ret
      000E37                       3351 00104$:
                                   3352 ;	fat.h:364: SDread(__global_partitionTableEntry.start,0,16,temp);
      000E37 78r01            [12] 3353 	mov	r0,#(___global_partitionTableEntry + 0x0001)
      000E39 86 04            [24] 3354 	mov	ar4,@r0
      000E3B 08               [12] 3355 	inc	r0
      000E3C 86 05            [24] 3356 	mov	ar5,@r0
      000E3E 08               [12] 3357 	inc	r0
      000E3F 86 06            [24] 3358 	mov	ar6,@r0
      000E41 08               [12] 3359 	inc	r0
      000E42 86 07            [24] 3360 	mov	ar7,@r0
      000E44 74r51            [12] 3361 	mov	a,#_VBR_MOUNT_VBR_temp_65536_144
      000E46 C0 E0            [24] 3362 	push	acc
      000E48 74s00            [12] 3363 	mov	a,#(_VBR_MOUNT_VBR_temp_65536_144 >> 8)
      000E4A C0 E0            [24] 3364 	push	acc
      000E4C 74 40            [12] 3365 	mov	a,#0x40
      000E4E C0 E0            [24] 3366 	push	acc
      000E50 74 10            [12] 3367 	mov	a,#0x10
      000E52 C0 E0            [24] 3368 	push	acc
      000E54 E4               [12] 3369 	clr	a
      000E55 C0 E0            [24] 3370 	push	acc
      000E57 C0 E0            [24] 3371 	push	acc
      000E59 C0 E0            [24] 3372 	push	acc
      000E5B 8C 82            [24] 3373 	mov	dpl,r4
      000E5D 8D 83            [24] 3374 	mov	dph,r5
      000E5F 8E F0            [24] 3375 	mov	b,r6
      000E61 EF               [12] 3376 	mov	a,r7
      000E62 12r07r11         [24] 3377 	lcall	_SDread
      000E65 E5 81            [12] 3378 	mov	a,sp
      000E67 24 F9            [12] 3379 	add	a,#0xf9
      000E69 F5 81            [12] 3380 	mov	sp,a
                                   3381 ;	fat.h:373: __global_vbr.volumeStartSector = __global_partitionTableEntry.start;
      000E6B 78r01            [12] 3382 	mov	r0,#(___global_partitionTableEntry + 0x0001)
      000E6D 86 04            [24] 3383 	mov	ar4,@r0
      000E6F 08               [12] 3384 	inc	r0
      000E70 86 05            [24] 3385 	mov	ar5,@r0
      000E72 08               [12] 3386 	inc	r0
      000E73 86 06            [24] 3387 	mov	ar6,@r0
      000E75 08               [12] 3388 	inc	r0
      000E76 86 07            [24] 3389 	mov	ar7,@r0
      000E78 78r09            [12] 3390 	mov	r0,#___global_vbr
      000E7A A6 04            [24] 3391 	mov	@r0,ar4
      000E7C 08               [12] 3392 	inc	r0
      000E7D A6 05            [24] 3393 	mov	@r0,ar5
      000E7F 08               [12] 3394 	inc	r0
      000E80 A6 06            [24] 3395 	mov	@r0,ar6
      000E82 08               [12] 3396 	inc	r0
      000E83 A6 07            [24] 3397 	mov	@r0,ar7
                                   3398 ;	fat.h:375: __global_vbr.bps = HELPER_load_littleendian16(&temp[0x0b]); // bps starts at offset 0x0b
      000E85 90r00r5C         [24] 3399 	mov	dptr,#(_VBR_MOUNT_VBR_temp_65536_144 + 0x000b)
      000E88 75 F0 40         [24] 3400 	mov	b,#0x40
      000E8B 12r08r57         [24] 3401 	lcall	_HELPER_load_littleendian16
      000E8E E5 82            [12] 3402 	mov	a,dpl
      000E90 85 83 F0         [24] 3403 	mov	b,dph
      000E93 78r0F            [12] 3404 	mov	r0,#(___global_vbr + 0x0006)
      000E95 F6               [12] 3405 	mov	@r0,a
      000E96 08               [12] 3406 	inc	r0
      000E97 A6 F0            [24] 3407 	mov	@r0,b
                                   3408 ;	fat.h:376: __global_vbr.spc = temp[0x0d]; //spc offset 0x0d
      000E99 78r5E            [12] 3409 	mov	r0,#(_VBR_MOUNT_VBR_temp_65536_144 + 0x000d)
      000E9B 86 07            [24] 3410 	mov	ar7,@r0
      000E9D 78r11            [12] 3411 	mov	r0,#(___global_vbr + 0x0008)
      000E9F A6 07            [24] 3412 	mov	@r0,ar7
                                   3413 ;	fat.h:377: __global_vbr.reservedSectors = HELPER_load_littleendian16(&temp[0x0e]);
      000EA1 90r00r5F         [24] 3414 	mov	dptr,#(_VBR_MOUNT_VBR_temp_65536_144 + 0x000e)
      000EA4 75 F0 40         [24] 3415 	mov	b,#0x40
      000EA7 12r08r57         [24] 3416 	lcall	_HELPER_load_littleendian16
      000EAA E5 82            [12] 3417 	mov	a,dpl
      000EAC 85 83 F0         [24] 3418 	mov	b,dph
      000EAF 78r0D            [12] 3419 	mov	r0,#(___global_vbr + 0x0004)
      000EB1 F6               [12] 3420 	mov	@r0,a
      000EB2 08               [12] 3421 	inc	r0
      000EB3 A6 F0            [24] 3422 	mov	@r0,b
                                   3423 ;	fat.h:381: SDread(__global_partitionTableEntry.start,16,16,temp);
      000EB5 78r01            [12] 3424 	mov	r0,#(___global_partitionTableEntry + 0x0001)
      000EB7 86 04            [24] 3425 	mov	ar4,@r0
      000EB9 08               [12] 3426 	inc	r0
      000EBA 86 05            [24] 3427 	mov	ar5,@r0
      000EBC 08               [12] 3428 	inc	r0
      000EBD 86 06            [24] 3429 	mov	ar6,@r0
      000EBF 08               [12] 3430 	inc	r0
      000EC0 86 07            [24] 3431 	mov	ar7,@r0
      000EC2 74r51            [12] 3432 	mov	a,#_VBR_MOUNT_VBR_temp_65536_144
      000EC4 C0 E0            [24] 3433 	push	acc
      000EC6 74s00            [12] 3434 	mov	a,#(_VBR_MOUNT_VBR_temp_65536_144 >> 8)
      000EC8 C0 E0            [24] 3435 	push	acc
      000ECA 74 40            [12] 3436 	mov	a,#0x40
      000ECC C0 E0            [24] 3437 	push	acc
      000ECE 74 10            [12] 3438 	mov	a,#0x10
      000ED0 C0 E0            [24] 3439 	push	acc
      000ED2 E4               [12] 3440 	clr	a
      000ED3 C0 E0            [24] 3441 	push	acc
      000ED5 74 10            [12] 3442 	mov	a,#0x10
      000ED7 C0 E0            [24] 3443 	push	acc
      000ED9 E4               [12] 3444 	clr	a
      000EDA C0 E0            [24] 3445 	push	acc
      000EDC 8C 82            [24] 3446 	mov	dpl,r4
      000EDE 8D 83            [24] 3447 	mov	dph,r5
      000EE0 8E F0            [24] 3448 	mov	b,r6
      000EE2 EF               [12] 3449 	mov	a,r7
      000EE3 12r07r11         [24] 3450 	lcall	_SDread
      000EE6 E5 81            [12] 3451 	mov	a,sp
      000EE8 24 F9            [12] 3452 	add	a,#0xf9
      000EEA F5 81            [12] 3453 	mov	sp,a
                                   3454 ;	fat.h:390: __global_vbr.nfat = HELPER_load_littleendian16(&temp[0x10-16]); //offset of nfat is 0x01, but we subtract 16 as we have read from 16 offset in SDread
      000EEC 90r00r51         [24] 3455 	mov	dptr,#_VBR_MOUNT_VBR_temp_65536_144
      000EEF 75 F0 40         [24] 3456 	mov	b,#0x40
      000EF2 12r08r57         [24] 3457 	lcall	_HELPER_load_littleendian16
      000EF5 E5 82            [12] 3458 	mov	a,dpl
      000EF7 85 83 F0         [24] 3459 	mov	b,dph
      000EFA 78r12            [12] 3460 	mov	r0,#(___global_vbr + 0x0009)
      000EFC F6               [12] 3461 	mov	@r0,a
      000EFD 08               [12] 3462 	inc	r0
      000EFE A6 F0            [24] 3463 	mov	@r0,b
                                   3464 ;	fat.h:391: __global_vbr.nroote = HELPER_load_littleendian16(&temp[0x11-16]); //offset of number_root_entrie is 0x11
      000F00 90r00r52         [24] 3465 	mov	dptr,#(_VBR_MOUNT_VBR_temp_65536_144 + 0x0001)
      000F03 75 F0 40         [24] 3466 	mov	b,#0x40
      000F06 12r08r57         [24] 3467 	lcall	_HELPER_load_littleendian16
      000F09 E5 82            [12] 3468 	mov	a,dpl
      000F0B 85 83 F0         [24] 3469 	mov	b,dph
      000F0E 78r16            [12] 3470 	mov	r0,#(___global_vbr + 0x000d)
      000F10 F6               [12] 3471 	mov	@r0,a
      000F11 08               [12] 3472 	inc	r0
      000F12 A6 F0            [24] 3473 	mov	@r0,b
                                   3474 ;	fat.h:392: __global_vbr.spf = HELPER_load_littleendian16(&temp[0x16-16]); //offset of sectors_per_fat is 0x16
      000F14 90r00r57         [24] 3475 	mov	dptr,#(_VBR_MOUNT_VBR_temp_65536_144 + 0x0006)
      000F17 75 F0 40         [24] 3476 	mov	b,#0x40
      000F1A 12r08r57         [24] 3477 	lcall	_HELPER_load_littleendian16
      000F1D AE 82            [24] 3478 	mov	r6,dpl
      000F1F AF 83            [24] 3479 	mov	r7,dph
      000F21 78r14            [12] 3480 	mov	r0,#(___global_vbr + 0x000b)
      000F23 A6 06            [24] 3481 	mov	@r0,ar6
      000F25 08               [12] 3482 	inc	r0
      000F26 A6 07            [24] 3483 	mov	@r0,ar7
                                   3484 ;	fat.h:401: __global_vbr.bpc =  (uint32_t)__global_vbr.bps * (uint32_t)__global_vbr.spc; 
      000F28 78r0F            [12] 3485 	mov	r0,#(___global_vbr + 0x0006)
      000F2A 86 04            [24] 3486 	mov	ar4,@r0
      000F2C 08               [12] 3487 	inc	r0
      000F2D 86 05            [24] 3488 	mov	ar5,@r0
      000F2F 8C*17            [24] 3489 	mov	_VBR_MOUNT_VBR_sloc0_1_0,r4
      000F31 8D*18            [24] 3490 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 1),r5
      000F33 75*19 00         [24] 3491 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 2),#0x00
      000F36 75*1A 00         [24] 3492 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 3),#0x00
      000F39 78r11            [12] 3493 	mov	r0,#(___global_vbr + 0x0008)
      000F3B 86 05            [24] 3494 	mov	ar5,@r0
      000F3D 8D*00            [24] 3495 	mov	__mullong_PARM_2,r5
      000F3F 75*01 00         [24] 3496 	mov	(__mullong_PARM_2 + 1),#0x00
      000F42 75*02 00         [24] 3497 	mov	(__mullong_PARM_2 + 2),#0x00
      000F45 75*03 00         [24] 3498 	mov	(__mullong_PARM_2 + 3),#0x00
      000F48 85*17 82         [24] 3499 	mov	dpl,_VBR_MOUNT_VBR_sloc0_1_0
      000F4B 85*18 83         [24] 3500 	mov	dph,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000F4E 85*19 F0         [24] 3501 	mov	b,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000F51 E5*1A            [12] 3502 	mov	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
      000F53 C0 07            [24] 3503 	push	ar7
      000F55 C0 06            [24] 3504 	push	ar6
      000F57 12r00r00         [24] 3505 	lcall	__mullong
      000F5A AA 82            [24] 3506 	mov	r2,dpl
      000F5C AB 83            [24] 3507 	mov	r3,dph
      000F5E AC F0            [24] 3508 	mov	r4,b
      000F60 FD               [12] 3509 	mov	r5,a
      000F61 D0 06            [24] 3510 	pop	ar6
      000F63 D0 07            [24] 3511 	pop	ar7
      000F65 78r18            [12] 3512 	mov	r0,#(___global_vbr + 0x000f)
      000F67 A6 02            [24] 3513 	mov	@r0,ar2
      000F69 08               [12] 3514 	inc	r0
      000F6A A6 03            [24] 3515 	mov	@r0,ar3
      000F6C 08               [12] 3516 	inc	r0
      000F6D A6 04            [24] 3517 	mov	@r0,ar4
      000F6F 08               [12] 3518 	inc	r0
      000F70 A6 05            [24] 3519 	mov	@r0,ar5
                                   3520 ;	fat.h:404: __global_vbr.addr_fat_start = __global_vbr.volumeStartSector + __global_vbr.reservedSectors;
      000F72 78r09            [12] 3521 	mov	r0,#___global_vbr
      000F74 86*17            [24] 3522 	mov	_VBR_MOUNT_VBR_sloc0_1_0,@r0
      000F76 08               [12] 3523 	inc	r0
      000F77 86*18            [24] 3524 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 1),@r0
      000F79 08               [12] 3525 	inc	r0
      000F7A 86*19            [24] 3526 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 2),@r0
      000F7C 08               [12] 3527 	inc	r0
      000F7D 86*1A            [24] 3528 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 3),@r0
      000F7F 78r0D            [12] 3529 	mov	r0,#(___global_vbr + 0x0004)
      000F81 86 04            [24] 3530 	mov	ar4,@r0
      000F83 08               [12] 3531 	inc	r0
      000F84 86 05            [24] 3532 	mov	ar5,@r0
      000F86 E4               [12] 3533 	clr	a
      000F87 FB               [12] 3534 	mov	r3,a
      000F88 FA               [12] 3535 	mov	r2,a
      000F89 EC               [12] 3536 	mov	a,r4
      000F8A 25*17            [12] 3537 	add	a,_VBR_MOUNT_VBR_sloc0_1_0
      000F8C F5*17            [12] 3538 	mov	_VBR_MOUNT_VBR_sloc0_1_0,a
      000F8E ED               [12] 3539 	mov	a,r5
      000F8F 35*18            [12] 3540 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000F91 F5*18            [12] 3541 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 1),a
      000F93 EB               [12] 3542 	mov	a,r3
      000F94 35*19            [12] 3543 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000F96 F5*19            [12] 3544 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 2),a
      000F98 EA               [12] 3545 	mov	a,r2
      000F99 35*1A            [12] 3546 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
      000F9B F5*1A            [12] 3547 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 3),a
      000F9D 78r1C            [12] 3548 	mov	r0,#(___global_vbr + 0x0013)
      000F9F A6*17            [24] 3549 	mov	@r0,_VBR_MOUNT_VBR_sloc0_1_0
      000FA1 08               [12] 3550 	inc	r0
      000FA2 A6*18            [24] 3551 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000FA4 08               [12] 3552 	inc	r0
      000FA5 A6*19            [24] 3553 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000FA7 08               [12] 3554 	inc	r0
      000FA8 A6*1A            [24] 3555 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
                                   3556 ;	fat.h:405: __global_vbr.addr_roote_start = __global_vbr.addr_fat_start + __global_vbr.nfat * __global_vbr.spf;
      000FAA 78r12            [12] 3557 	mov	r0,#(___global_vbr + 0x0009)
      000FAC 86 82            [24] 3558 	mov	dpl,@r0
      000FAE 08               [12] 3559 	inc	r0
      000FAF 86 83            [24] 3560 	mov	dph,@r0
      000FB1 8E*00            [24] 3561 	mov	__mulint_PARM_2,r6
      000FB3 8F*01            [24] 3562 	mov	(__mulint_PARM_2 + 1),r7
      000FB5 12r00r00         [24] 3563 	lcall	__mulint
      000FB8 AE 82            [24] 3564 	mov	r6,dpl
      000FBA AF 83            [24] 3565 	mov	r7,dph
      000FBC 8E 04            [24] 3566 	mov	ar4,r6
      000FBE 8F 05            [24] 3567 	mov	ar5,r7
      000FC0 E4               [12] 3568 	clr	a
      000FC1 FE               [12] 3569 	mov	r6,a
      000FC2 FF               [12] 3570 	mov	r7,a
      000FC3 EC               [12] 3571 	mov	a,r4
      000FC4 25*17            [12] 3572 	add	a,_VBR_MOUNT_VBR_sloc0_1_0
      000FC6 F5*17            [12] 3573 	mov	_VBR_MOUNT_VBR_sloc0_1_0,a
      000FC8 ED               [12] 3574 	mov	a,r5
      000FC9 35*18            [12] 3575 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000FCB F5*18            [12] 3576 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 1),a
      000FCD EE               [12] 3577 	mov	a,r6
      000FCE 35*19            [12] 3578 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000FD0 F5*19            [12] 3579 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 2),a
      000FD2 EF               [12] 3580 	mov	a,r7
      000FD3 35*1A            [12] 3581 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
      000FD5 F5*1A            [12] 3582 	mov	(_VBR_MOUNT_VBR_sloc0_1_0 + 3),a
      000FD7 78r20            [12] 3583 	mov	r0,#(___global_vbr + 0x0017)
      000FD9 A6*17            [24] 3584 	mov	@r0,_VBR_MOUNT_VBR_sloc0_1_0
      000FDB 08               [12] 3585 	inc	r0
      000FDC A6*18            [24] 3586 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      000FDE 08               [12] 3587 	inc	r0
      000FDF A6*19            [24] 3588 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      000FE1 08               [12] 3589 	inc	r0
      000FE2 A6*1A            [24] 3590 	mov	@r0,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
                                   3591 ;	fat.h:406: __global_vbr.addr_data_start = __global_vbr.addr_roote_start + (__global_vbr.nroote*32)/__global_vbr.bps;
      000FE4 78r16            [12] 3592 	mov	r0,#(___global_vbr + 0x000d)
      000FE6 86 02            [24] 3593 	mov	ar2,@r0
      000FE8 08               [12] 3594 	inc	r0
      000FE9 86 03            [24] 3595 	mov	ar3,@r0
      000FEB 8A 82            [24] 3596 	mov	dpl,r2
      000FED EB               [12] 3597 	mov	a,r3
      000FEE C4               [12] 3598 	swap	a
      000FEF 23               [12] 3599 	rl	a
      000FF0 54 E0            [12] 3600 	anl	a,#0xe0
      000FF2 C5 82            [12] 3601 	xch	a,dpl
      000FF4 C4               [12] 3602 	swap	a
      000FF5 23               [12] 3603 	rl	a
      000FF6 C5 82            [12] 3604 	xch	a,dpl
      000FF8 65 82            [12] 3605 	xrl	a,dpl
      000FFA C5 82            [12] 3606 	xch	a,dpl
      000FFC 54 E0            [12] 3607 	anl	a,#0xe0
      000FFE C5 82            [12] 3608 	xch	a,dpl
      001000 65 82            [12] 3609 	xrl	a,dpl
      001002 F5 83            [12] 3610 	mov	dph,a
      001004 78r0F            [12] 3611 	mov	r0,#(___global_vbr + 0x0006)
      001006 86*00            [24] 3612 	mov	__divuint_PARM_2,@r0
      001008 08               [12] 3613 	inc	r0
      001009 86*01            [24] 3614 	mov	(__divuint_PARM_2 + 1),@r0
      00100B 12r00r00         [24] 3615 	lcall	__divuint
      00100E AA 82            [24] 3616 	mov	r2,dpl
      001010 AB 83            [24] 3617 	mov	r3,dph
      001012 E4               [12] 3618 	clr	a
      001013 FE               [12] 3619 	mov	r6,a
      001014 FF               [12] 3620 	mov	r7,a
      001015 EA               [12] 3621 	mov	a,r2
      001016 25*17            [12] 3622 	add	a,_VBR_MOUNT_VBR_sloc0_1_0
      001018 FA               [12] 3623 	mov	r2,a
      001019 EB               [12] 3624 	mov	a,r3
      00101A 35*18            [12] 3625 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 1)
      00101C FB               [12] 3626 	mov	r3,a
      00101D EE               [12] 3627 	mov	a,r6
      00101E 35*19            [12] 3628 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 2)
      001020 FE               [12] 3629 	mov	r6,a
      001021 EF               [12] 3630 	mov	a,r7
      001022 35*1A            [12] 3631 	addc	a,(_VBR_MOUNT_VBR_sloc0_1_0 + 3)
      001024 FF               [12] 3632 	mov	r7,a
      001025 78r24            [12] 3633 	mov	r0,#(___global_vbr + 0x001b)
      001027 A6 02            [24] 3634 	mov	@r0,ar2
      001029 08               [12] 3635 	inc	r0
      00102A A6 03            [24] 3636 	mov	@r0,ar3
      00102C 08               [12] 3637 	inc	r0
      00102D A6 06            [24] 3638 	mov	@r0,ar6
      00102F 08               [12] 3639 	inc	r0
      001030 A6 07            [24] 3640 	mov	@r0,ar7
                                   3641 ;	fat.h:414: return 0;
      001032 75 82 00         [24] 3642 	mov	dpl,#0x00
                                   3643 ;	fat.h:416: }
      001035 22               [24] 3644 	ret
                                   3645 ;------------------------------------------------------------
                                   3646 ;Allocation info for local variables in function 'VBR_FAT16_CHECK_COMPATIBILITY'
                                   3647 ;------------------------------------------------------------
                                   3648 ;partition_number          Allocated to registers r7 
                                   3649 ;------------------------------------------------------------
                                   3650 ;	fat.h:418: uint8_t VBR_FAT16_CHECK_COMPATIBILITY(uint8_t partition_number)
                                   3651 ;	-----------------------------------------
                                   3652 ;	 function VBR_FAT16_CHECK_COMPATIBILITY
                                   3653 ;	-----------------------------------------
      001036                       3654 _VBR_FAT16_CHECK_COMPATIBILITY:
                                   3655 ;	fat.h:424: if(VBR_MOUNT_VBR(partition_number))
      001036 12r0Er1A         [24] 3656 	lcall	_VBR_MOUNT_VBR
      001039 E5 82            [12] 3657 	mov	a,dpl
      00103B 60 04            [24] 3658 	jz	00102$
                                   3659 ;	fat.h:426: return 1; //error
      00103D 75 82 01         [24] 3660 	mov	dpl,#0x01
      001040 22               [24] 3661 	ret
      001041                       3662 00102$:
                                   3663 ;	fat.h:429: if(__global_vbr.bps!=SD_BLOCK_SIZE) 
      001041 78r0F            [12] 3664 	mov	r0,#(___global_vbr + 0x0006)
      001043 86 06            [24] 3665 	mov	ar6,@r0
      001045 08               [12] 3666 	inc	r0
      001046 86 07            [24] 3667 	mov	ar7,@r0
      001048 BE 00 05         [24] 3668 	cjne	r6,#0x00,00116$
      00104B BF 02 02         [24] 3669 	cjne	r7,#0x02,00116$
      00104E 80 04            [24] 3670 	sjmp	00104$
      001050                       3671 00116$:
                                   3672 ;	fat.h:434: return 2; //error - not supported fat16
      001050 75 82 02         [24] 3673 	mov	dpl,#0x02
      001053 22               [24] 3674 	ret
      001054                       3675 00104$:
                                   3676 ;	fat.h:437: return 0;
      001054 75 82 00         [24] 3677 	mov	dpl,#0x00
                                   3678 ;	fat.h:438: }
      001057 22               [24] 3679 	ret
                                   3680 ;------------------------------------------------------------
                                   3681 ;Allocation info for local variables in function 'FAT16_ROOTENTRY_DUMP'
                                   3682 ;------------------------------------------------------------
                                   3683 ;i                         Allocated to registers r7 
                                   3684 ;i                         Allocated to registers r7 
                                   3685 ;------------------------------------------------------------
                                   3686 ;	fat.h:441: void FAT16_ROOTENTRY_DUMP()
                                   3687 ;	-----------------------------------------
                                   3688 ;	 function FAT16_ROOTENTRY_DUMP
                                   3689 ;	-----------------------------------------
      001058                       3690 _FAT16_ROOTENTRY_DUMP:
                                   3691 ;	fat.h:443: UartPrint("\nROOT_ENTRY_INDEX:");
      001058 90r00r72         [24] 3692 	mov	dptr,#___str_2
      00105B 75 F0 80         [24] 3693 	mov	b,#0x80
      00105E 12r01r1B         [24] 3694 	lcall	_UartPrint
                                   3695 ;	fat.h:444: UartPrintNumber(__global_rootEntry.entry_index);
      001061 78r3B            [12] 3696 	mov	r0,#(___global_rootEntry + 0x0012)
      001063 86 06            [24] 3697 	mov	ar6,@r0
      001065 08               [12] 3698 	inc	r0
      001066 86 07            [24] 3699 	mov	ar7,@r0
      001068 7D 00            [12] 3700 	mov	r5,#0x00
      00106A 7C 00            [12] 3701 	mov	r4,#0x00
      00106C 8E 82            [24] 3702 	mov	dpl,r6
      00106E 8F 83            [24] 3703 	mov	dph,r7
      001070 8D F0            [24] 3704 	mov	b,r5
      001072 EC               [12] 3705 	mov	a,r4
      001073 12r02r61         [24] 3706 	lcall	_UartPrintNumber
                                   3707 ;	fat.h:445: UartPrint("\nFILE: ");
      001076 90r00r85         [24] 3708 	mov	dptr,#___str_3
      001079 75 F0 80         [24] 3709 	mov	b,#0x80
      00107C 12r01r1B         [24] 3710 	lcall	_UartPrint
                                   3711 ;	fat.h:446: for(uint8_t i=0;i<8;i++)UartWrite(__global_rootEntry.name[i]);
      00107F 7F 00            [12] 3712 	mov	r7,#0x00
      001081                       3713 00104$:
      001081 BF 08 00         [24] 3714 	cjne	r7,#0x08,00129$
      001084                       3715 00129$:
      001084 50 10            [24] 3716 	jnc	00101$
      001086 EF               [12] 3717 	mov	a,r7
      001087 24r29            [12] 3718 	add	a,#___global_rootEntry
      001089 F9               [12] 3719 	mov	r1,a
      00108A 87 82            [24] 3720 	mov	dpl,@r1
      00108C C0 07            [24] 3721 	push	ar7
      00108E 12r00r95         [24] 3722 	lcall	_UartWrite
      001091 D0 07            [24] 3723 	pop	ar7
      001093 0F               [12] 3724 	inc	r7
      001094 80 EB            [24] 3725 	sjmp	00104$
      001096                       3726 00101$:
                                   3727 ;	fat.h:447: for(uint8_t i=0;i<3;i++)UartWrite(__global_rootEntry.extension[i]);
      001096 7F 00            [12] 3728 	mov	r7,#0x00
      001098                       3729 00107$:
      001098 BF 03 00         [24] 3730 	cjne	r7,#0x03,00131$
      00109B                       3731 00131$:
      00109B 50 10            [24] 3732 	jnc	00102$
      00109D EF               [12] 3733 	mov	a,r7
      00109E 24r31            [12] 3734 	add	a,#(___global_rootEntry + 0x0008)
      0010A0 F9               [12] 3735 	mov	r1,a
      0010A1 87 82            [24] 3736 	mov	dpl,@r1
      0010A3 C0 07            [24] 3737 	push	ar7
      0010A5 12r00r95         [24] 3738 	lcall	_UartWrite
      0010A8 D0 07            [24] 3739 	pop	ar7
      0010AA 0F               [12] 3740 	inc	r7
      0010AB 80 EB            [24] 3741 	sjmp	00107$
      0010AD                       3742 00102$:
                                   3743 ;	fat.h:448: UartPrint("\nSTART: ");
      0010AD 90r00r8D         [24] 3744 	mov	dptr,#___str_4
      0010B0 75 F0 80         [24] 3745 	mov	b,#0x80
      0010B3 12r01r1B         [24] 3746 	lcall	_UartPrint
                                   3747 ;	fat.h:449: UartPrintNumber(__global_rootEntry.startCluster);
      0010B6 78r35            [12] 3748 	mov	r0,#(___global_rootEntry + 0x000c)
      0010B8 86 06            [24] 3749 	mov	ar6,@r0
      0010BA 08               [12] 3750 	inc	r0
      0010BB 86 07            [24] 3751 	mov	ar7,@r0
      0010BD 7D 00            [12] 3752 	mov	r5,#0x00
      0010BF 7C 00            [12] 3753 	mov	r4,#0x00
      0010C1 8E 82            [24] 3754 	mov	dpl,r6
      0010C3 8F 83            [24] 3755 	mov	dph,r7
      0010C5 8D F0            [24] 3756 	mov	b,r5
      0010C7 EC               [12] 3757 	mov	a,r4
      0010C8 12r02r61         [24] 3758 	lcall	_UartPrintNumber
                                   3759 ;	fat.h:450: UartPrint("\nSIZE: ");
      0010CB 90r00r96         [24] 3760 	mov	dptr,#___str_5
      0010CE 75 F0 80         [24] 3761 	mov	b,#0x80
      0010D1 12r01r1B         [24] 3762 	lcall	_UartPrint
                                   3763 ;	fat.h:451: UartPrintNumber(__global_rootEntry.size);			
      0010D4 78r37            [12] 3764 	mov	r0,#(___global_rootEntry + 0x000e)
      0010D6 86 04            [24] 3765 	mov	ar4,@r0
      0010D8 08               [12] 3766 	inc	r0
      0010D9 86 05            [24] 3767 	mov	ar5,@r0
      0010DB 08               [12] 3768 	inc	r0
      0010DC 86 06            [24] 3769 	mov	ar6,@r0
      0010DE 08               [12] 3770 	inc	r0
      0010DF 86 07            [24] 3771 	mov	ar7,@r0
      0010E1 8C 82            [24] 3772 	mov	dpl,r4
      0010E3 8D 83            [24] 3773 	mov	dph,r5
      0010E5 8E F0            [24] 3774 	mov	b,r6
      0010E7 EF               [12] 3775 	mov	a,r7
      0010E8 12r02r61         [24] 3776 	lcall	_UartPrintNumber
                                   3777 ;	fat.h:452: UartPrint("\nATTR: 0x");
      0010EB 90r00r9E         [24] 3778 	mov	dptr,#___str_6
      0010EE 75 F0 80         [24] 3779 	mov	b,#0x80
      0010F1 12r01r1B         [24] 3780 	lcall	_UartPrint
                                   3781 ;	fat.h:453: UartWriteNumber(__global_rootEntry.attributes,HEX);			
      0010F4 78r34            [12] 3782 	mov	r0,#(___global_rootEntry + 0x000b)
      0010F6 86 82            [24] 3783 	mov	dpl,@r0
      0010F8 E4               [12] 3784 	clr	a
      0010F9 C0 E0            [24] 3785 	push	acc
      0010FB 12r01r4D         [24] 3786 	lcall	_UartWriteNumber
      0010FE 15 81            [12] 3787 	dec	sp
                                   3788 ;	fat.h:454: UartWrite('\n\n');
      001100 75 82 0A         [24] 3789 	mov	dpl,#0x0a
                                   3790 ;	fat.h:455: }
      001103 02r00r95         [24] 3791 	ljmp	_UartWrite
                                   3792 ;------------------------------------------------------------
                                   3793 ;Allocation info for local variables in function 'FAT16_LOAD_ROOTENTRY'
                                   3794 ;------------------------------------------------------------
                                   3795 ;roote_number              Allocated with name '_FAT16_LOAD_ROOTENTRY_roote_number_65536_155'
                                   3796 ;i                         Allocated to registers r7 
                                   3797 ;i                         Allocated to registers r7 
                                   3798 ;sloc0                     Allocated with name '_FAT16_LOAD_ROOTENTRY_sloc0_1_0'
                                   3799 ;sloc1                     Allocated with name '_FAT16_LOAD_ROOTENTRY_sloc1_1_0'
                                   3800 ;temp                      Allocated with name '_FAT16_LOAD_ROOTENTRY_temp_65536_156'
                                   3801 ;sector_of_given_roote     Allocated to registers r2 r3 r4 r5 
                                   3802 ;offset_in_this_sector     Allocated to registers r6 r7 
                                   3803 ;------------------------------------------------------------
                                   3804 ;	fat.h:465: uint8_t FAT16_LOAD_ROOTENTRY(uint16_t roote_number)
                                   3805 ;	-----------------------------------------
                                   3806 ;	 function FAT16_LOAD_ROOTENTRY
                                   3807 ;	-----------------------------------------
      001106                       3808 _FAT16_LOAD_ROOTENTRY:
      001106 85 82*1B         [24] 3809 	mov	_FAT16_LOAD_ROOTENTRY_roote_number_65536_155,dpl
      001109 85 83*1C         [24] 3810 	mov	(_FAT16_LOAD_ROOTENTRY_roote_number_65536_155 + 1),dph
                                   3811 ;	fat.h:474: if(roote_number < __global_vbr.nroote);//pass
      00110C 78r16            [12] 3812 	mov	r0,#(___global_vbr + 0x000d)
      00110E 86 04            [24] 3813 	mov	ar4,@r0
      001110 08               [12] 3814 	inc	r0
      001111 86 05            [24] 3815 	mov	ar5,@r0
      001113 C3               [12] 3816 	clr	c
      001114 E5*1B            [12] 3817 	mov	a,_FAT16_LOAD_ROOTENTRY_roote_number_65536_155
      001116 9C               [12] 3818 	subb	a,r4
      001117 E5*1C            [12] 3819 	mov	a,(_FAT16_LOAD_ROOTENTRY_roote_number_65536_155 + 1)
      001119 9D               [12] 3820 	subb	a,r5
      00111A 40 04            [24] 3821 	jc	00103$
                                   3822 ;	fat.h:475: else return 1; // error as roote_number is more than number of root entries present in rootentry table 
      00111C 75 82 01         [24] 3823 	mov	dpl,#0x01
      00111F 22               [24] 3824 	ret
      001120                       3825 00103$:
                                   3826 ;	fat.h:477: VBR_MOUNT_VBR(__global_nthPartitionVBRmounted);
      001120 78r28            [12] 3827 	mov	r0,#___global_nthPartitionVBRmounted
      001122 86 82            [24] 3828 	mov	dpl,@r0
      001124 12r0Er1A         [24] 3829 	lcall	_VBR_MOUNT_VBR
                                   3830 ;	fat.h:480: sector_of_given_roote = __global_vbr.addr_roote_start + (roote_number*32)/__global_vbr.bps;
      001127 78r20            [12] 3831 	mov	r0,#(___global_vbr + 0x0017)
      001129 86*1D            [24] 3832 	mov	_FAT16_LOAD_ROOTENTRY_sloc0_1_0,@r0
      00112B 08               [12] 3833 	inc	r0
      00112C 86*1E            [24] 3834 	mov	(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 1),@r0
      00112E 08               [12] 3835 	inc	r0
      00112F 86*1F            [24] 3836 	mov	(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 2),@r0
      001131 08               [12] 3837 	inc	r0
      001132 86*20            [24] 3838 	mov	(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 3),@r0
      001134 AE*1B            [24] 3839 	mov	r6,_FAT16_LOAD_ROOTENTRY_roote_number_65536_155
      001136 E5*1C            [12] 3840 	mov	a,(_FAT16_LOAD_ROOTENTRY_roote_number_65536_155 + 1)
      001138 C4               [12] 3841 	swap	a
      001139 23               [12] 3842 	rl	a
      00113A 54 E0            [12] 3843 	anl	a,#0xe0
      00113C CE               [12] 3844 	xch	a,r6
      00113D C4               [12] 3845 	swap	a
      00113E 23               [12] 3846 	rl	a
      00113F CE               [12] 3847 	xch	a,r6
      001140 6E               [12] 3848 	xrl	a,r6
      001141 CE               [12] 3849 	xch	a,r6
      001142 54 E0            [12] 3850 	anl	a,#0xe0
      001144 CE               [12] 3851 	xch	a,r6
      001145 6E               [12] 3852 	xrl	a,r6
      001146 FF               [12] 3853 	mov	r7,a
      001147 78r0F            [12] 3854 	mov	r0,#(___global_vbr + 0x0006)
      001149 86*21            [24] 3855 	mov	_FAT16_LOAD_ROOTENTRY_sloc1_1_0,@r0
      00114B 08               [12] 3856 	inc	r0
      00114C 86*22            [24] 3857 	mov	(_FAT16_LOAD_ROOTENTRY_sloc1_1_0 + 1),@r0
      00114E 85*21*00         [24] 3858 	mov	__divuint_PARM_2,_FAT16_LOAD_ROOTENTRY_sloc1_1_0
      001151 85*22*01         [24] 3859 	mov	(__divuint_PARM_2 + 1),(_FAT16_LOAD_ROOTENTRY_sloc1_1_0 + 1)
      001154 8E 82            [24] 3860 	mov	dpl,r6
      001156 8F 83            [24] 3861 	mov	dph,r7
      001158 C0 07            [24] 3862 	push	ar7
      00115A C0 06            [24] 3863 	push	ar6
      00115C 12r00r00         [24] 3864 	lcall	__divuint
      00115F AA 82            [24] 3865 	mov	r2,dpl
      001161 AB 83            [24] 3866 	mov	r3,dph
      001163 D0 06            [24] 3867 	pop	ar6
      001165 D0 07            [24] 3868 	pop	ar7
      001167 E4               [12] 3869 	clr	a
      001168 FC               [12] 3870 	mov	r4,a
      001169 FD               [12] 3871 	mov	r5,a
      00116A EA               [12] 3872 	mov	a,r2
      00116B 25*1D            [12] 3873 	add	a,_FAT16_LOAD_ROOTENTRY_sloc0_1_0
      00116D FA               [12] 3874 	mov	r2,a
      00116E EB               [12] 3875 	mov	a,r3
      00116F 35*1E            [12] 3876 	addc	a,(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 1)
      001171 FB               [12] 3877 	mov	r3,a
      001172 EC               [12] 3878 	mov	a,r4
      001173 35*1F            [12] 3879 	addc	a,(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 2)
      001175 FC               [12] 3880 	mov	r4,a
      001176 ED               [12] 3881 	mov	a,r5
      001177 35*20            [12] 3882 	addc	a,(_FAT16_LOAD_ROOTENTRY_sloc0_1_0 + 3)
      001179 FD               [12] 3883 	mov	r5,a
                                   3884 ;	fat.h:481: offset_in_this_sector = (roote_number*32)%__global_vbr.bps;
      00117A 85*21*00         [24] 3885 	mov	__moduint_PARM_2,_FAT16_LOAD_ROOTENTRY_sloc1_1_0
      00117D 85*22*01         [24] 3886 	mov	(__moduint_PARM_2 + 1),(_FAT16_LOAD_ROOTENTRY_sloc1_1_0 + 1)
      001180 8E 82            [24] 3887 	mov	dpl,r6
      001182 8F 83            [24] 3888 	mov	dph,r7
      001184 C0 05            [24] 3889 	push	ar5
      001186 C0 04            [24] 3890 	push	ar4
      001188 C0 03            [24] 3891 	push	ar3
      00118A C0 02            [24] 3892 	push	ar2
      00118C 12r00r00         [24] 3893 	lcall	__moduint
      00118F AE 82            [24] 3894 	mov	r6,dpl
      001191 AF 83            [24] 3895 	mov	r7,dph
      001193 D0 02            [24] 3896 	pop	ar2
      001195 D0 03            [24] 3897 	pop	ar3
      001197 D0 04            [24] 3898 	pop	ar4
      001199 D0 05            [24] 3899 	pop	ar5
                                   3900 ;	fat.h:483: SDread(sector_of_given_roote,offset_in_this_sector,32,temp);
      00119B 74r61            [12] 3901 	mov	a,#_FAT16_LOAD_ROOTENTRY_temp_65536_156
      00119D C0 E0            [24] 3902 	push	acc
      00119F 74s00            [12] 3903 	mov	a,#(_FAT16_LOAD_ROOTENTRY_temp_65536_156 >> 8)
      0011A1 C0 E0            [24] 3904 	push	acc
      0011A3 74 40            [12] 3905 	mov	a,#0x40
      0011A5 C0 E0            [24] 3906 	push	acc
      0011A7 03               [12] 3907 	rr	a
      0011A8 C0 E0            [24] 3908 	push	acc
      0011AA E4               [12] 3909 	clr	a
      0011AB C0 E0            [24] 3910 	push	acc
      0011AD C0 06            [24] 3911 	push	ar6
      0011AF C0 07            [24] 3912 	push	ar7
      0011B1 8A 82            [24] 3913 	mov	dpl,r2
      0011B3 8B 83            [24] 3914 	mov	dph,r3
      0011B5 8C F0            [24] 3915 	mov	b,r4
      0011B7 ED               [12] 3916 	mov	a,r5
      0011B8 12r07r11         [24] 3917 	lcall	_SDread
      0011BB E5 81            [12] 3918 	mov	a,sp
      0011BD 24 F9            [12] 3919 	add	a,#0xf9
      0011BF F5 81            [12] 3920 	mov	sp,a
                                   3921 ;	fat.h:485: __global_rootEntry.entry_index = roote_number; //save the index of the root_entry
      0011C1 78r3B            [12] 3922 	mov	r0,#(___global_rootEntry + 0x0012)
      0011C3 A6*1B            [24] 3923 	mov	@r0,_FAT16_LOAD_ROOTENTRY_roote_number_65536_155
      0011C5 08               [12] 3924 	inc	r0
      0011C6 A6*1C            [24] 3925 	mov	@r0,(_FAT16_LOAD_ROOTENTRY_roote_number_65536_155 + 1)
                                   3926 ;	fat.h:486: __global_rootEntry.bytes_read = 0; //no bytes has been read so far by FAT16_FILE_READ as we have just loaded the rootentry
      0011C8 78r3D            [12] 3927 	mov	r0,#(___global_rootEntry + 0x0014)
      0011CA 76 00            [12] 3928 	mov	@r0,#0x00
      0011CC 08               [12] 3929 	inc	r0
      0011CD 76 00            [12] 3930 	mov	@r0,#0x00
      0011CF 08               [12] 3931 	inc	r0
      0011D0 76 00            [12] 3932 	mov	@r0,#0x00
      0011D2 08               [12] 3933 	inc	r0
      0011D3 76 00            [12] 3934 	mov	@r0,#0x00
                                   3935 ;	fat.h:488: for(uint8_t i=0;i<8;i++) __global_rootEntry.name[i] = temp[i];
      0011D5 7F 00            [12] 3936 	mov	r7,#0x00
      0011D7                       3937 00107$:
      0011D7 BF 08 00         [24] 3938 	cjne	r7,#0x08,00137$
      0011DA                       3939 00137$:
      0011DA 50 0F            [24] 3940 	jnc	00104$
      0011DC EF               [12] 3941 	mov	a,r7
      0011DD 24r29            [12] 3942 	add	a,#___global_rootEntry
      0011DF F9               [12] 3943 	mov	r1,a
      0011E0 EF               [12] 3944 	mov	a,r7
      0011E1 24r61            [12] 3945 	add	a,#_FAT16_LOAD_ROOTENTRY_temp_65536_156
      0011E3 F8               [12] 3946 	mov	r0,a
      0011E4 86 06            [24] 3947 	mov	ar6,@r0
      0011E6 A7 06            [24] 3948 	mov	@r1,ar6
      0011E8 0F               [12] 3949 	inc	r7
      0011E9 80 EC            [24] 3950 	sjmp	00107$
      0011EB                       3951 00104$:
                                   3952 ;	fat.h:489: for(uint8_t i=8;i<11;i++) __global_rootEntry.extension[i-8] = temp[i];
      0011EB 7F 08            [12] 3953 	mov	r7,#0x08
      0011ED                       3954 00110$:
      0011ED BF 0B 00         [24] 3955 	cjne	r7,#0x0b,00139$
      0011F0                       3956 00139$:
      0011F0 50 13            [24] 3957 	jnc	00105$
      0011F2 8F 06            [24] 3958 	mov	ar6,r7
      0011F4 EE               [12] 3959 	mov	a,r6
      0011F5 24 F8            [12] 3960 	add	a,#0xf8
      0011F7 24r31            [12] 3961 	add	a,#(___global_rootEntry + 0x0008)
      0011F9 F9               [12] 3962 	mov	r1,a
      0011FA EF               [12] 3963 	mov	a,r7
      0011FB 24r61            [12] 3964 	add	a,#_FAT16_LOAD_ROOTENTRY_temp_65536_156
      0011FD F8               [12] 3965 	mov	r0,a
      0011FE 86 06            [24] 3966 	mov	ar6,@r0
      001200 A7 06            [24] 3967 	mov	@r1,ar6
      001202 0F               [12] 3968 	inc	r7
      001203 80 E8            [24] 3969 	sjmp	00110$
      001205                       3970 00105$:
                                   3971 ;	fat.h:491: __global_rootEntry.attributes = temp[0x0b];
      001205 78r6C            [12] 3972 	mov	r0,#(_FAT16_LOAD_ROOTENTRY_temp_65536_156 + 0x000b)
      001207 86 07            [24] 3973 	mov	ar7,@r0
      001209 78r34            [12] 3974 	mov	r0,#(___global_rootEntry + 0x000b)
      00120B A6 07            [24] 3975 	mov	@r0,ar7
                                   3976 ;	fat.h:492: __global_rootEntry.startCluster = HELPER_load_littleendian16(&temp[0x1a]);
      00120D 90r00r7B         [24] 3977 	mov	dptr,#(_FAT16_LOAD_ROOTENTRY_temp_65536_156 + 0x001a)
      001210 75 F0 40         [24] 3978 	mov	b,#0x40
      001213 12r08r57         [24] 3979 	lcall	_HELPER_load_littleendian16
      001216 E5 82            [12] 3980 	mov	a,dpl
      001218 85 83 F0         [24] 3981 	mov	b,dph
      00121B 78r35            [12] 3982 	mov	r0,#(___global_rootEntry + 0x000c)
      00121D F6               [12] 3983 	mov	@r0,a
      00121E 08               [12] 3984 	inc	r0
      00121F A6 F0            [24] 3985 	mov	@r0,b
                                   3986 ;	fat.h:493: __global_rootEntry.size = HELPER_load_littleendian32(&temp[0x1c]);
      001221 90r00r7D         [24] 3987 	mov	dptr,#(_FAT16_LOAD_ROOTENTRY_temp_65536_156 + 0x001c)
      001224 75 F0 40         [24] 3988 	mov	b,#0x40
      001227 12r08r85         [24] 3989 	lcall	_HELPER_load_littleendian32
      00122A AC 82            [24] 3990 	mov	r4,dpl
      00122C AD 83            [24] 3991 	mov	r5,dph
      00122E AE F0            [24] 3992 	mov	r6,b
      001230 FF               [12] 3993 	mov	r7,a
      001231 78r37            [12] 3994 	mov	r0,#(___global_rootEntry + 0x000e)
      001233 A6 04            [24] 3995 	mov	@r0,ar4
      001235 08               [12] 3996 	inc	r0
      001236 A6 05            [24] 3997 	mov	@r0,ar5
      001238 08               [12] 3998 	inc	r0
      001239 A6 06            [24] 3999 	mov	@r0,ar6
      00123B 08               [12] 4000 	inc	r0
      00123C A6 07            [24] 4001 	mov	@r0,ar7
                                   4002 ;	fat.h:495: return 0;
      00123E 75 82 00         [24] 4003 	mov	dpl,#0x00
                                   4004 ;	fat.h:496: }
      001241 22               [24] 4005 	ret
                                   4006 ;------------------------------------------------------------
                                   4007 ;Allocation info for local variables in function 'FAT16_IS_ROOTENTRY_VALID_FILE'
                                   4008 ;------------------------------------------------------------
                                   4009 ;	fat.h:497: uint8_t FAT16_IS_ROOTENTRY_VALID_FILE()
                                   4010 ;	-----------------------------------------
                                   4011 ;	 function FAT16_IS_ROOTENTRY_VALID_FILE
                                   4012 ;	-----------------------------------------
      001242                       4013 _FAT16_IS_ROOTENTRY_VALID_FILE:
                                   4014 ;	fat.h:500: if(__global_rootEntry.name[0]==FAT16_ROOTENTRY_AVAILABLE)
      001242 78r29            [12] 4015 	mov	r0,#___global_rootEntry
      001244 E6               [12] 4016 	mov	a,@r0
      001245 FF               [12] 4017 	mov	r7,a
      001246 70 04            [24] 4018 	jnz	00112$
                                   4019 ;	fat.h:505: return 255; //no more entries, stop scanning
      001248 75 82 FF         [24] 4020 	mov	dpl,#0xff
      00124B 22               [24] 4021 	ret
      00124C                       4022 00112$:
                                   4023 ;	fat.h:507: else if(__global_rootEntry.name[0]==FAT16_ROOTENTRY_DELETED)
      00124C BF E5 04         [24] 4024 	cjne	r7,#0xe5,00109$
                                   4025 ;	fat.h:513: return FAT16_ROOTENTRY_DELETED; //deleted and available
      00124F 75 82 E5         [24] 4026 	mov	dpl,#0xe5
      001252 22               [24] 4027 	ret
      001253                       4028 00109$:
                                   4029 ;	fat.h:515: else if(__global_rootEntry.name[0]==FAT16_ROOTENTRY_DOT)
      001253 BF 2E 04         [24] 4030 	cjne	r7,#0x2e,00106$
                                   4031 ;	fat.h:520: return FAT16_ROOTENTRY_DOT; //this is the entry to self
      001256 75 82 2E         [24] 4032 	mov	dpl,#0x2e
      001259 22               [24] 4033 	ret
      00125A                       4034 00106$:
                                   4035 ;	fat.h:525: HELPER_rootentry_type(&__global_rootEntry)==FILETYPE_HIDDEN ||
      00125A 90r00r29         [24] 4036 	mov	dptr,#___global_rootEntry
      00125D 75 F0 40         [24] 4037 	mov	b,#0x40
      001260 12r09rE0         [24] 4038 	lcall	_HELPER_rootentry_type
      001263 AF 82            [24] 4039 	mov	r7,dpl
      001265 BF 01 02         [24] 4040 	cjne	r7,#0x01,00141$
      001268 80 1E            [24] 4041 	sjmp	00101$
      00126A                       4042 00141$:
                                   4043 ;	fat.h:526: HELPER_rootentry_type(&__global_rootEntry)==FILETYPE_SYSTEM ||
      00126A 90r00r29         [24] 4044 	mov	dptr,#___global_rootEntry
      00126D 75 F0 40         [24] 4045 	mov	b,#0x40
      001270 12r09rE0         [24] 4046 	lcall	_HELPER_rootentry_type
      001273 AF 82            [24] 4047 	mov	r7,dpl
      001275 BF 02 02         [24] 4048 	cjne	r7,#0x02,00142$
      001278 80 0E            [24] 4049 	sjmp	00101$
      00127A                       4050 00142$:
                                   4051 ;	fat.h:527: HELPER_rootentry_type(&__global_rootEntry)==FILETYPE_VOLUME
      00127A 90r00r29         [24] 4052 	mov	dptr,#___global_rootEntry
      00127D 75 F0 40         [24] 4053 	mov	b,#0x40
      001280 12r09rE0         [24] 4054 	lcall	_HELPER_rootentry_type
      001283 AF 82            [24] 4055 	mov	r7,dpl
      001285 BF 03 04         [24] 4056 	cjne	r7,#0x03,00110$
      001288                       4057 00101$:
                                   4058 ;	fat.h:534: return 254;
      001288 75 82 FE         [24] 4059 	mov	dpl,#0xfe
      00128B 22               [24] 4060 	ret
      00128C                       4061 00110$:
                                   4062 ;	fat.h:537: return 0;
      00128C 75 82 00         [24] 4063 	mov	dpl,#0x00
                                   4064 ;	fat.h:538: }
      00128F 22               [24] 4065 	ret
                                   4066 ;------------------------------------------------------------
                                   4067 ;Allocation info for local variables in function 'FAT16_ROOTENTRY_READ'
                                   4068 ;------------------------------------------------------------
                                   4069 ;roote_index               Allocated to registers r6 r7 
                                   4070 ;file_validity             Allocated to registers r7 
                                   4071 ;------------------------------------------------------------
                                   4072 ;	fat.h:541: uint8_t FAT16_ROOTENTRY_READ(uint16_t roote_index)
                                   4073 ;	-----------------------------------------
                                   4074 ;	 function FAT16_ROOTENTRY_READ
                                   4075 ;	-----------------------------------------
      001290                       4076 _FAT16_ROOTENTRY_READ:
                                   4077 ;	fat.h:551: if(FAT16_LOAD_ROOTENTRY(roote_index)) // if returns 1, then we have reached the end of the rootentry table
      001290 12r11r06         [24] 4078 	lcall	_FAT16_LOAD_ROOTENTRY
      001293 E5 82            [12] 4079 	mov	a,dpl
      001295 60 04            [24] 4080 	jz	00102$
                                   4081 ;	fat.h:553: return 0xff; //end of scan
      001297 75 82 FF         [24] 4082 	mov	dpl,#0xff
      00129A 22               [24] 4083 	ret
      00129B                       4084 00102$:
                                   4085 ;	fat.h:557: file_validity=FAT16_IS_ROOTENTRY_VALID_FILE(); //check validity
      00129B 12r12r42         [24] 4086 	lcall	_FAT16_IS_ROOTENTRY_VALID_FILE
      00129E AF 82            [24] 4087 	mov	r7,dpl
                                   4088 ;	fat.h:559: if(file_validity==255)return 0xff; //end of scan
      0012A0 BF FF 04         [24] 4089 	cjne	r7,#0xff,00106$
      0012A3 75 82 FF         [24] 4090 	mov	dpl,#0xff
      0012A6 22               [24] 4091 	ret
      0012A7                       4092 00106$:
                                   4093 ;	fat.h:560: else if(file_validity==0)
      0012A7 EF               [12] 4094 	mov	a,r7
                                   4095 ;	fat.h:566: return 0;
      0012A8 70 03            [24] 4096 	jnz	00107$
      0012AA F5 82            [12] 4097 	mov	dpl,a
      0012AC 22               [24] 4098 	ret
      0012AD                       4099 00107$:
                                   4100 ;	fat.h:569: return 1; //invalid file if context reaches here
      0012AD 75 82 01         [24] 4101 	mov	dpl,#0x01
                                   4102 ;	fat.h:572: }
      0012B0 22               [24] 4103 	ret
                                   4104 ;------------------------------------------------------------
                                   4105 ;Allocation info for local variables in function 'FAT16_ROOTENTRY_SCAN_RESET'
                                   4106 ;------------------------------------------------------------
                                   4107 ;	fat.h:574: void FAT16_ROOTENTRY_SCAN_RESET()
                                   4108 ;	-----------------------------------------
                                   4109 ;	 function FAT16_ROOTENTRY_SCAN_RESET
                                   4110 ;	-----------------------------------------
      0012B1                       4111 _FAT16_ROOTENTRY_SCAN_RESET:
                                   4112 ;	fat.h:576: __global_rootEntry.entry_index=0xffff; // in FAT16, maximum number of root entries can never reach 0xffff.
      0012B1 78r3B            [12] 4113 	mov	r0,#(___global_rootEntry + 0x0012)
      0012B3 76 FF            [12] 4114 	mov	@r0,#0xff
      0012B5 08               [12] 4115 	inc	r0
      0012B6 76 FF            [12] 4116 	mov	@r0,#0xff
                                   4117 ;	fat.h:582: __global_rootEntry.attributes |= 1<<FILETYPE_SYSTEM;
      0012B8 78r34            [12] 4118 	mov	r0,#(___global_rootEntry + 0x000b)
      0012BA 86 07            [24] 4119 	mov	ar7,@r0
      0012BC 74 04            [12] 4120 	mov	a,#0x04
      0012BE 4F               [12] 4121 	orl	a,r7
      0012BF 78r34            [12] 4122 	mov	r0,#(___global_rootEntry + 0x000b)
      0012C1 F6               [12] 4123 	mov	@r0,a
                                   4124 ;	fat.h:583: }
      0012C2 22               [24] 4125 	ret
                                   4126 ;------------------------------------------------------------
                                   4127 ;Allocation info for local variables in function 'FAT16_ROOTENTRY_SCAN'
                                   4128 ;------------------------------------------------------------
                                   4129 ;validity                  Allocated to registers r7 
                                   4130 ;------------------------------------------------------------
                                   4131 ;	fat.h:585: uint8_t FAT16_ROOTENTRY_SCAN() __reentrant
                                   4132 ;	-----------------------------------------
                                   4133 ;	 function FAT16_ROOTENTRY_SCAN
                                   4134 ;	-----------------------------------------
      0012C3                       4135 _FAT16_ROOTENTRY_SCAN:
                                   4136 ;	fat.h:590: while(1)
      0012C3                       4137 00110$:
                                   4138 ;	fat.h:598: validity=FAT16_ROOTENTRY_READ(__global_rootEntry.entry_index+1); //read the next entry
      0012C3 78r3B            [12] 4139 	mov	r0,#(___global_rootEntry + 0x0012)
      0012C5 86 06            [24] 4140 	mov	ar6,@r0
      0012C7 08               [12] 4141 	inc	r0
      0012C8 86 07            [24] 4142 	mov	ar7,@r0
      0012CA 8E 82            [24] 4143 	mov	dpl,r6
      0012CC 8F 83            [24] 4144 	mov	dph,r7
      0012CE A3               [24] 4145 	inc	dptr
      0012CF 12r12r90         [24] 4146 	lcall	_FAT16_ROOTENTRY_READ
      0012D2 AF 82            [24] 4147 	mov	r7,dpl
                                   4148 ;	fat.h:600: if ( validity == 255 )
      0012D4 BF FF 04         [24] 4149 	cjne	r7,#0xff,00107$
                                   4150 ;	fat.h:606: return 255; //end scan
      0012D7 75 82 FF         [24] 4151 	mov	dpl,#0xff
      0012DA 22               [24] 4152 	ret
      0012DB                       4153 00107$:
                                   4154 ;	fat.h:608: else if (validity == 1) 
      0012DB BF 01 02         [24] 4155 	cjne	r7,#0x01,00132$
      0012DE 80 E3            [24] 4156 	sjmp	00110$
      0012E0                       4157 00132$:
                                   4158 ;	fat.h:616: else if(validity == 0)
      0012E0 EF               [12] 4159 	mov	a,r7
                                   4160 ;	fat.h:623: return 0; // found a valid file,break out of the loop
      0012E1 70 E0            [24] 4161 	jnz	00110$
      0012E3 F5 82            [12] 4162 	mov	dpl,a
                                   4163 ;	fat.h:630: }
      0012E5 22               [24] 4164 	ret
                                   4165 ;------------------------------------------------------------
                                   4166 ;Allocation info for local variables in function 'FAT16_FILE_OPEN'
                                   4167 ;------------------------------------------------------------
                                   4168 ;filename                  Allocated to registers r5 r6 r7 
                                   4169 ;filename83                Allocated to stack - _bp +1
                                   4170 ;------------------------------------------------------------
                                   4171 ;	fat.h:632: uint8_t FAT16_FILE_OPEN(char *filename) __reentrant
                                   4172 ;	-----------------------------------------
                                   4173 ;	 function FAT16_FILE_OPEN
                                   4174 ;	-----------------------------------------
      0012E6                       4175 _FAT16_FILE_OPEN:
      0012E6 C0*00            [24] 4176 	push	_bp
      0012E8 E5 81            [12] 4177 	mov	a,sp
      0012EA F5*00            [12] 4178 	mov	_bp,a
      0012EC 24 0C            [12] 4179 	add	a,#0x0c
      0012EE F5 81            [12] 4180 	mov	sp,a
      0012F0 AD 82            [24] 4181 	mov	r5,dpl
      0012F2 AE 83            [24] 4182 	mov	r6,dph
      0012F4 AF F0            [24] 4183 	mov	r7,b
                                   4184 ;	fat.h:638: if(HELPER_filename_to_8dot3filename(filename,filename83)) 
      0012F6 AC*00            [24] 4185 	mov	r4,_bp
      0012F8 0C               [12] 4186 	inc	r4
      0012F9 8C*10            [24] 4187 	mov	_HELPER_filename_to_8dot3filename_PARM_2,r4
      0012FB 75*11 00         [24] 4188 	mov	(_HELPER_filename_to_8dot3filename_PARM_2 + 1),#0x00
      0012FE 75*12 40         [24] 4189 	mov	(_HELPER_filename_to_8dot3filename_PARM_2 + 2),#0x40
      001301 8D 82            [24] 4190 	mov	dpl,r5
      001303 8E 83            [24] 4191 	mov	dph,r6
      001305 8F F0            [24] 4192 	mov	b,r7
      001307 C0 04            [24] 4193 	push	ar4
      001309 12r0Ar99         [24] 4194 	lcall	_HELPER_filename_to_8dot3filename
      00130C E5 82            [12] 4195 	mov	a,dpl
      00130E D0 04            [24] 4196 	pop	ar4
      001310 60 05            [24] 4197 	jz	00102$
                                   4198 ;	fat.h:643: return 1; //invalid filename
      001312 75 82 01         [24] 4199 	mov	dpl,#0x01
      001315 80 61            [24] 4200 	sjmp	00109$
      001317                       4201 00102$:
                                   4202 ;	fat.h:646: FAT16_ROOTENTRY_SCAN_RESET();
      001317 C0 04            [24] 4203 	push	ar4
      001319 12r12rB1         [24] 4204 	lcall	_FAT16_ROOTENTRY_SCAN_RESET
      00131C D0 04            [24] 4205 	pop	ar4
                                   4206 ;	fat.h:647: while(FAT16_ROOTENTRY_SCAN()==0)
      00131E 8C 07            [24] 4207 	mov	ar7,r4
      001320 74 08            [12] 4208 	mov	a,#0x08
      001322 2C               [12] 4209 	add	a,r4
      001323 FE               [12] 4210 	mov	r6,a
      001324                       4211 00106$:
      001324 C0 07            [24] 4212 	push	ar7
      001326 C0 06            [24] 4213 	push	ar6
      001328 12r12rC3         [24] 4214 	lcall	_FAT16_ROOTENTRY_SCAN
      00132B E5 82            [12] 4215 	mov	a,dpl
      00132D D0 06            [24] 4216 	pop	ar6
      00132F D0 07            [24] 4217 	pop	ar7
                                   4218 ;	fat.h:649: if( HELPER_strncmp(__global_rootEntry.name,filename83,8)==0 && 
      001331 70 42            [24] 4219 	jnz	00108$
      001333 8F*00            [24] 4220 	mov	_HELPER_strncmp_PARM_2,r7
      001335 F5*01            [12] 4221 	mov	(_HELPER_strncmp_PARM_2 + 1),a
      001337 75*02 40         [24] 4222 	mov	(_HELPER_strncmp_PARM_2 + 2),#0x40
      00133A 75*03 08         [24] 4223 	mov	_HELPER_strncmp_PARM_3,#0x08
      00133D 90r00r29         [24] 4224 	mov	dptr,#___global_rootEntry
      001340 75 F0 40         [24] 4225 	mov	b,#0x40
      001343 C0 07            [24] 4226 	push	ar7
      001345 C0 06            [24] 4227 	push	ar6
      001347 12r09r69         [24] 4228 	lcall	_HELPER_strncmp
      00134A E5 82            [12] 4229 	mov	a,dpl
      00134C D0 06            [24] 4230 	pop	ar6
      00134E D0 07            [24] 4231 	pop	ar7
                                   4232 ;	fat.h:650: HELPER_strncmp(__global_rootEntry.extension,&filename83[8],3)==0 )
      001350 70 D2            [24] 4233 	jnz	00106$
      001352 8E*00            [24] 4234 	mov	_HELPER_strncmp_PARM_2,r6
      001354 F5*01            [12] 4235 	mov	(_HELPER_strncmp_PARM_2 + 1),a
      001356 75*02 40         [24] 4236 	mov	(_HELPER_strncmp_PARM_2 + 2),#0x40
      001359 75*03 03         [24] 4237 	mov	_HELPER_strncmp_PARM_3,#0x03
      00135C 90r00r31         [24] 4238 	mov	dptr,#(___global_rootEntry + 0x0008)
      00135F 75 F0 40         [24] 4239 	mov	b,#0x40
      001362 C0 07            [24] 4240 	push	ar7
      001364 C0 06            [24] 4241 	push	ar6
      001366 12r09r69         [24] 4242 	lcall	_HELPER_strncmp
      001369 E5 82            [12] 4243 	mov	a,dpl
      00136B D0 06            [24] 4244 	pop	ar6
      00136D D0 07            [24] 4245 	pop	ar7
                                   4246 ;	fat.h:656: return 0; //file found
      00136F 70 B3            [24] 4247 	jnz	00106$
      001371 F5 82            [12] 4248 	mov	dpl,a
      001373 80 03            [24] 4249 	sjmp	00109$
      001375                       4250 00108$:
                                   4251 ;	fat.h:663: return 2; // file not found
      001375 75 82 02         [24] 4252 	mov	dpl,#0x02
      001378                       4253 00109$:
                                   4254 ;	fat.h:665: }
      001378 85*00 81         [24] 4255 	mov	sp,_bp
      00137B D0*00            [24] 4256 	pop	_bp
      00137D 22               [24] 4257 	ret
                                   4258 ;------------------------------------------------------------
                                   4259 ;Allocation info for local variables in function 'FAT16_GET_NEXT_CLUSTER'
                                   4260 ;------------------------------------------------------------
                                   4261 ;current_cluster           Allocated to registers r6 r7 
                                   4262 ;temp                      Allocated to stack - _bp +8
                                   4263 ;sloc0                     Allocated to stack - _bp +1
                                   4264 ;sloc1                     Allocated to stack - _bp +8
                                   4265 ;sloc2                     Allocated to stack - _bp +10
                                   4266 ;sloc3                     Allocated to stack - _bp +4
                                   4267 ;------------------------------------------------------------
                                   4268 ;	fat.h:668: uint16_t FAT16_GET_NEXT_CLUSTER(uint16_t current_cluster) __reentrant
                                   4269 ;	-----------------------------------------
                                   4270 ;	 function FAT16_GET_NEXT_CLUSTER
                                   4271 ;	-----------------------------------------
      00137E                       4272 _FAT16_GET_NEXT_CLUSTER:
      00137E C0*00            [24] 4273 	push	_bp
      001380 E5 81            [12] 4274 	mov	a,sp
      001382 F5*00            [12] 4275 	mov	_bp,a
      001384 24 09            [12] 4276 	add	a,#0x09
      001386 F5 81            [12] 4277 	mov	sp,a
      001388 AE 82            [24] 4278 	mov	r6,dpl
      00138A AF 83            [24] 4279 	mov	r7,dph
                                   4280 ;	fat.h:677: SDread(__global_vbr.addr_fat_start + (current_cluster*2)/__global_vbr.bps, (current_cluster*2) % __global_vbr.bps, 2, temp);
      00138C E5*00            [12] 4281 	mov	a,_bp
      00138E 24 08            [12] 4282 	add	a,#0x08
      001390 F9               [12] 4283 	mov	r1,a
      001391 A8*00            [24] 4284 	mov	r0,_bp
      001393 08               [12] 4285 	inc	r0
      001394 A6 01            [24] 4286 	mov	@r0,ar1
      001396 08               [12] 4287 	inc	r0
      001397 76 00            [12] 4288 	mov	@r0,#0x00
      001399 08               [12] 4289 	inc	r0
      00139A 76 40            [12] 4290 	mov	@r0,#0x40
      00139C EE               [12] 4291 	mov	a,r6
      00139D 2E               [12] 4292 	add	a,r6
      00139E FE               [12] 4293 	mov	r6,a
      00139F EF               [12] 4294 	mov	a,r7
      0013A0 33               [12] 4295 	rlc	a
      0013A1 FF               [12] 4296 	mov	r7,a
      0013A2 78r0F            [12] 4297 	mov	r0,#(___global_vbr + 0x0006)
      0013A4 86 05            [24] 4298 	mov	ar5,@r0
      0013A6 08               [12] 4299 	inc	r0
      0013A7 86 04            [24] 4300 	mov	ar4,@r0
      0013A9 8D*00            [24] 4301 	mov	__moduint_PARM_2,r5
      0013AB 8C*01            [24] 4302 	mov	(__moduint_PARM_2 + 1),r4
      0013AD 8E 82            [24] 4303 	mov	dpl,r6
      0013AF 8F 83            [24] 4304 	mov	dph,r7
      0013B1 C0 07            [24] 4305 	push	ar7
      0013B3 C0 06            [24] 4306 	push	ar6
      0013B5 C0 05            [24] 4307 	push	ar5
      0013B7 C0 04            [24] 4308 	push	ar4
      0013B9 C0 01            [24] 4309 	push	ar1
      0013BB 12r00r00         [24] 4310 	lcall	__moduint
      0013BE AB 82            [24] 4311 	mov	r3,dpl
      0013C0 AA 83            [24] 4312 	mov	r2,dph
      0013C2 D0 01            [24] 4313 	pop	ar1
      0013C4 D0 04            [24] 4314 	pop	ar4
      0013C6 D0 05            [24] 4315 	pop	ar5
      0013C8 D0 06            [24] 4316 	pop	ar6
      0013CA D0 07            [24] 4317 	pop	ar7
      0013CC E5*00            [12] 4318 	mov	a,_bp
      0013CE 24 04            [12] 4319 	add	a,#0x04
      0013D0 F8               [12] 4320 	mov	r0,a
      0013D1 C0 01            [24] 4321 	push	ar1
      0013D3 79r1C            [12] 4322 	mov	r1,#(___global_vbr + 0x0013)
      0013D5 E7               [12] 4323 	mov	a,@r1
      0013D6 F6               [12] 4324 	mov	@r0,a
      0013D7 09               [12] 4325 	inc	r1
      0013D8 E7               [12] 4326 	mov	a,@r1
      0013D9 08               [12] 4327 	inc	r0
      0013DA F6               [12] 4328 	mov	@r0,a
      0013DB 09               [12] 4329 	inc	r1
      0013DC E7               [12] 4330 	mov	a,@r1
      0013DD 08               [12] 4331 	inc	r0
      0013DE F6               [12] 4332 	mov	@r0,a
      0013DF 09               [12] 4333 	inc	r1
      0013E0 E7               [12] 4334 	mov	a,@r1
      0013E1 08               [12] 4335 	inc	r0
      0013E2 F6               [12] 4336 	mov	@r0,a
      0013E3 D0 01            [24] 4337 	pop	ar1
      0013E5 8D*00            [24] 4338 	mov	__divuint_PARM_2,r5
      0013E7 8C*01            [24] 4339 	mov	(__divuint_PARM_2 + 1),r4
      0013E9 8E 82            [24] 4340 	mov	dpl,r6
      0013EB 8F 83            [24] 4341 	mov	dph,r7
      0013ED C0 03            [24] 4342 	push	ar3
      0013EF C0 02            [24] 4343 	push	ar2
      0013F1 C0 01            [24] 4344 	push	ar1
      0013F3 12r00r00         [24] 4345 	lcall	__divuint
      0013F6 AE 82            [24] 4346 	mov	r6,dpl
      0013F8 AF 83            [24] 4347 	mov	r7,dph
      0013FA D0 01            [24] 4348 	pop	ar1
      0013FC D0 02            [24] 4349 	pop	ar2
      0013FE D0 03            [24] 4350 	pop	ar3
      001400 8E 04            [24] 4351 	mov	ar4,r6
      001402 8F 05            [24] 4352 	mov	ar5,r7
      001404 E4               [12] 4353 	clr	a
      001405 FE               [12] 4354 	mov	r6,a
      001406 FF               [12] 4355 	mov	r7,a
      001407 E5*00            [12] 4356 	mov	a,_bp
      001409 24 04            [12] 4357 	add	a,#0x04
      00140B F8               [12] 4358 	mov	r0,a
      00140C EC               [12] 4359 	mov	a,r4
      00140D 26               [12] 4360 	add	a,@r0
      00140E FC               [12] 4361 	mov	r4,a
      00140F ED               [12] 4362 	mov	a,r5
      001410 08               [12] 4363 	inc	r0
      001411 36               [12] 4364 	addc	a,@r0
      001412 FD               [12] 4365 	mov	r5,a
      001413 EE               [12] 4366 	mov	a,r6
      001414 08               [12] 4367 	inc	r0
      001415 36               [12] 4368 	addc	a,@r0
      001416 FE               [12] 4369 	mov	r6,a
      001417 EF               [12] 4370 	mov	a,r7
      001418 08               [12] 4371 	inc	r0
      001419 36               [12] 4372 	addc	a,@r0
      00141A FF               [12] 4373 	mov	r7,a
      00141B C0 01            [24] 4374 	push	ar1
      00141D A8*00            [24] 4375 	mov	r0,_bp
      00141F 08               [12] 4376 	inc	r0
      001420 E6               [12] 4377 	mov	a,@r0
      001421 C0 E0            [24] 4378 	push	acc
      001423 08               [12] 4379 	inc	r0
      001424 E6               [12] 4380 	mov	a,@r0
      001425 C0 E0            [24] 4381 	push	acc
      001427 08               [12] 4382 	inc	r0
      001428 E6               [12] 4383 	mov	a,@r0
      001429 C0 E0            [24] 4384 	push	acc
      00142B 74 02            [12] 4385 	mov	a,#0x02
      00142D C0 E0            [24] 4386 	push	acc
      00142F E4               [12] 4387 	clr	a
      001430 C0 E0            [24] 4388 	push	acc
      001432 C0 03            [24] 4389 	push	ar3
      001434 C0 02            [24] 4390 	push	ar2
      001436 8C 82            [24] 4391 	mov	dpl,r4
      001438 8D 83            [24] 4392 	mov	dph,r5
      00143A 8E F0            [24] 4393 	mov	b,r6
      00143C EF               [12] 4394 	mov	a,r7
      00143D 12r07r11         [24] 4395 	lcall	_SDread
      001440 E5 81            [12] 4396 	mov	a,sp
      001442 24 F9            [12] 4397 	add	a,#0xf9
      001444 F5 81            [12] 4398 	mov	sp,a
      001446 D0 01            [24] 4399 	pop	ar1
                                   4400 ;	fat.h:678: return (uint16_t)temp[1] << 8 | temp[0]; 
      001448 E9               [12] 4401 	mov	a,r1
      001449 04               [12] 4402 	inc	a
      00144A F8               [12] 4403 	mov	r0,a
      00144B 86 07            [24] 4404 	mov	ar7,@r0
      00144D 8F 06            [24] 4405 	mov	ar6,r7
      00144F 7F 00            [12] 4406 	mov	r7,#0x00
      001451 87 05            [24] 4407 	mov	ar5,@r1
      001453 7C 00            [12] 4408 	mov	r4,#0x00
      001455 ED               [12] 4409 	mov	a,r5
      001456 4F               [12] 4410 	orl	a,r7
      001457 F5 82            [12] 4411 	mov	dpl,a
      001459 EC               [12] 4412 	mov	a,r4
      00145A 4E               [12] 4413 	orl	a,r6
      00145B F5 83            [12] 4414 	mov	dph,a
                                   4415 ;	fat.h:684: }
      00145D 85*00 81         [24] 4416 	mov	sp,_bp
      001460 D0*00            [24] 4417 	pop	_bp
      001462 22               [24] 4418 	ret
                                   4419 ;------------------------------------------------------------
                                   4420 ;Allocation info for local variables in function 'FAT16_FILE_READ'
                                   4421 ;------------------------------------------------------------
                                   4422 ;dst                       Allocated to stack - _bp -5
                                   4423 ;nbytes                    Allocated to stack - _bp +1
                                   4424 ;current_cluster           Allocated to registers r7 r6 
                                   4425 ;bytes_read_in_current_cluster Allocated to stack - _bp +10
                                   4426 ;bytes_read_in_current_sector Allocated to stack - _bp +12
                                   4427 ;current_sector            Allocated to stack - _bp +14
                                   4428 ;sloc0                     Allocated to stack - _bp +2
                                   4429 ;sloc1                     Allocated to stack - _bp +6
                                   4430 ;------------------------------------------------------------
                                   4431 ;	fat.h:705: uint8_t FAT16_FILE_READ(uint8_t nbytes, uint8_t *dst) __reentrant
                                   4432 ;	-----------------------------------------
                                   4433 ;	 function FAT16_FILE_READ
                                   4434 ;	-----------------------------------------
      001463                       4435 _FAT16_FILE_READ:
      001463 C0*00            [24] 4436 	push	_bp
      001465 85 81*00         [24] 4437 	mov	_bp,sp
      001468 C0 82            [24] 4438 	push	dpl
      00146A E5 81            [12] 4439 	mov	a,sp
      00146C 24 10            [12] 4440 	add	a,#0x10
      00146E F5 81            [12] 4441 	mov	sp,a
                                   4442 ;	fat.h:714: if(nbytes==0)
      001470 A8*00            [24] 4443 	mov	r0,_bp
      001472 08               [12] 4444 	inc	r0
      001473 E6               [12] 4445 	mov	a,@r0
                                   4446 ;	fat.h:716: return 0; //read 0 bytes
      001474 70 05            [24] 4447 	jnz	00102$
      001476 F5 82            [12] 4448 	mov	dpl,a
      001478 02r16rC6         [24] 4449 	ljmp	00113$
      00147B                       4450 00102$:
                                   4451 ;	fat.h:719: if(nbytes & (nbytes-1))
      00147B A8*00            [24] 4452 	mov	r0,_bp
      00147D 08               [12] 4453 	inc	r0
      00147E 86 05            [24] 4454 	mov	ar5,@r0
      001480 7E 00            [12] 4455 	mov	r6,#0x00
      001482 ED               [12] 4456 	mov	a,r5
      001483 24 FF            [12] 4457 	add	a,#0xff
      001485 FB               [12] 4458 	mov	r3,a
      001486 EE               [12] 4459 	mov	a,r6
      001487 34 FF            [12] 4460 	addc	a,#0xff
      001489 FC               [12] 4461 	mov	r4,a
      00148A EB               [12] 4462 	mov	a,r3
      00148B 52 05            [12] 4463 	anl	ar5,a
      00148D EC               [12] 4464 	mov	a,r4
      00148E 52 06            [12] 4465 	anl	ar6,a
      001490 ED               [12] 4466 	mov	a,r5
      001491 4E               [12] 4467 	orl	a,r6
      001492 60 06            [24] 4468 	jz	00104$
                                   4469 ;	fat.h:724: return 255; //error
      001494 75 82 FF         [24] 4470 	mov	dpl,#0xff
      001497 02r16rC6         [24] 4471 	ljmp	00113$
      00149A                       4472 00104$:
                                   4473 ;	fat.h:727: if(__global_rootEntry.bytes_read == __global_rootEntry.size)
      00149A A8*00            [24] 4474 	mov	r0,_bp
      00149C 08               [12] 4475 	inc	r0
      00149D 08               [12] 4476 	inc	r0
      00149E 79r3D            [12] 4477 	mov	r1,#(___global_rootEntry + 0x0014)
      0014A0 E7               [12] 4478 	mov	a,@r1
      0014A1 F6               [12] 4479 	mov	@r0,a
      0014A2 09               [12] 4480 	inc	r1
      0014A3 E7               [12] 4481 	mov	a,@r1
      0014A4 08               [12] 4482 	inc	r0
      0014A5 F6               [12] 4483 	mov	@r0,a
      0014A6 09               [12] 4484 	inc	r1
      0014A7 E7               [12] 4485 	mov	a,@r1
      0014A8 08               [12] 4486 	inc	r0
      0014A9 F6               [12] 4487 	mov	@r0,a
      0014AA 09               [12] 4488 	inc	r1
      0014AB E7               [12] 4489 	mov	a,@r1
      0014AC 08               [12] 4490 	inc	r0
      0014AD F6               [12] 4491 	mov	@r0,a
      0014AE 78r37            [12] 4492 	mov	r0,#(___global_rootEntry + 0x000e)
      0014B0 86 02            [24] 4493 	mov	ar2,@r0
      0014B2 08               [12] 4494 	inc	r0
      0014B3 86 05            [24] 4495 	mov	ar5,@r0
      0014B5 08               [12] 4496 	inc	r0
      0014B6 86 06            [24] 4497 	mov	ar6,@r0
      0014B8 08               [12] 4498 	inc	r0
      0014B9 86 07            [24] 4499 	mov	ar7,@r0
      0014BB A8*00            [24] 4500 	mov	r0,_bp
      0014BD 08               [12] 4501 	inc	r0
      0014BE 08               [12] 4502 	inc	r0
      0014BF E6               [12] 4503 	mov	a,@r0
      0014C0 B5 02 11         [24] 4504 	cjne	a,ar2,00141$
      0014C3 08               [12] 4505 	inc	r0
      0014C4 E6               [12] 4506 	mov	a,@r0
      0014C5 B5 05 0C         [24] 4507 	cjne	a,ar5,00141$
      0014C8 08               [12] 4508 	inc	r0
      0014C9 E6               [12] 4509 	mov	a,@r0
      0014CA B5 06 07         [24] 4510 	cjne	a,ar6,00141$
      0014CD 08               [12] 4511 	inc	r0
      0014CE E6               [12] 4512 	mov	a,@r0
      0014CF B5 07 02         [24] 4513 	cjne	a,ar7,00141$
      0014D2 80 02            [24] 4514 	sjmp	00142$
      0014D4                       4515 00141$:
      0014D4 80 06            [24] 4516 	sjmp	00111$
      0014D6                       4517 00142$:
                                   4518 ;	fat.h:729: return 0; //end of file - return number of bytes read
      0014D6 75 82 00         [24] 4519 	mov	dpl,#0x00
      0014D9 02r16rC6         [24] 4520 	ljmp	00113$
      0014DC                       4521 00111$:
                                   4522 ;	fat.h:734: bytes_read_in_current_cluster = __global_rootEntry.bytes_read % __global_vbr.bpc;
      0014DC 78r18            [12] 4523 	mov	r0,#(___global_vbr + 0x000f)
      0014DE 86*00            [24] 4524 	mov	__modulong_PARM_2,@r0
      0014E0 08               [12] 4525 	inc	r0
      0014E1 86*01            [24] 4526 	mov	(__modulong_PARM_2 + 1),@r0
      0014E3 08               [12] 4527 	inc	r0
      0014E4 86*02            [24] 4528 	mov	(__modulong_PARM_2 + 2),@r0
      0014E6 08               [12] 4529 	inc	r0
      0014E7 86*03            [24] 4530 	mov	(__modulong_PARM_2 + 3),@r0
      0014E9 A8*00            [24] 4531 	mov	r0,_bp
      0014EB 08               [12] 4532 	inc	r0
      0014EC 08               [12] 4533 	inc	r0
      0014ED 86 82            [24] 4534 	mov	dpl,@r0
      0014EF 08               [12] 4535 	inc	r0
      0014F0 86 83            [24] 4536 	mov	dph,@r0
      0014F2 08               [12] 4537 	inc	r0
      0014F3 86 F0            [24] 4538 	mov	b,@r0
      0014F5 08               [12] 4539 	inc	r0
      0014F6 E6               [12] 4540 	mov	a,@r0
      0014F7 12r00r00         [24] 4541 	lcall	__modulong
      0014FA AB 82            [24] 4542 	mov	r3,dpl
      0014FC AC 83            [24] 4543 	mov	r4,dph
      0014FE E5*00            [12] 4544 	mov	a,_bp
      001500 24 0A            [12] 4545 	add	a,#0x0a
      001502 F8               [12] 4546 	mov	r0,a
      001503 A6 03            [24] 4547 	mov	@r0,ar3
      001505 08               [12] 4548 	inc	r0
      001506 A6 04            [24] 4549 	mov	@r0,ar4
                                   4550 ;	fat.h:778: if(__global_rootEntry.bytes_read!=0 && bytes_read_in_current_cluster==0)
      001508 A8*00            [24] 4551 	mov	r0,_bp
      00150A 08               [12] 4552 	inc	r0
      00150B 08               [12] 4553 	inc	r0
      00150C E6               [12] 4554 	mov	a,@r0
      00150D 08               [12] 4555 	inc	r0
      00150E 46               [12] 4556 	orl	a,@r0
      00150F 08               [12] 4557 	inc	r0
      001510 46               [12] 4558 	orl	a,@r0
      001511 08               [12] 4559 	inc	r0
      001512 46               [12] 4560 	orl	a,@r0
      001513 60 1F            [24] 4561 	jz	00106$
      001515 E5*00            [12] 4562 	mov	a,_bp
      001517 24 0A            [12] 4563 	add	a,#0x0a
      001519 F8               [12] 4564 	mov	r0,a
      00151A E6               [12] 4565 	mov	a,@r0
      00151B 08               [12] 4566 	inc	r0
      00151C 46               [12] 4567 	orl	a,@r0
      00151D 70 15            [24] 4568 	jnz	00106$
                                   4569 ;	fat.h:780: __global_rootEntry.startCluster = FAT16_GET_NEXT_CLUSTER(__global_rootEntry.startCluster);
      00151F 78r35            [12] 4570 	mov	r0,#(___global_rootEntry + 0x000c)
      001521 86 82            [24] 4571 	mov	dpl,@r0
      001523 08               [12] 4572 	inc	r0
      001524 86 83            [24] 4573 	mov	dph,@r0
      001526 12r13r7E         [24] 4574 	lcall	_FAT16_GET_NEXT_CLUSTER
      001529 E5 82            [12] 4575 	mov	a,dpl
      00152B 85 83 F0         [24] 4576 	mov	b,dph
      00152E 78r35            [12] 4577 	mov	r0,#(___global_rootEntry + 0x000c)
      001530 F6               [12] 4578 	mov	@r0,a
      001531 08               [12] 4579 	inc	r0
      001532 A6 F0            [24] 4580 	mov	@r0,b
      001534                       4581 00106$:
                                   4582 ;	fat.h:784: current_cluster = __global_rootEntry.startCluster;
      001534 78r35            [12] 4583 	mov	r0,#(___global_rootEntry + 0x000c)
      001536 86 07            [24] 4584 	mov	ar7,@r0
      001538 08               [12] 4585 	inc	r0
      001539 86 06            [24] 4586 	mov	ar6,@r0
                                   4587 ;	fat.h:789: current_sector =    __global_vbr.addr_data_start 						//start of data
      00153B A8*00            [24] 4588 	mov	r0,_bp
      00153D 08               [12] 4589 	inc	r0
      00153E 08               [12] 4590 	inc	r0
      00153F 79r24            [12] 4591 	mov	r1,#(___global_vbr + 0x001b)
      001541 E7               [12] 4592 	mov	a,@r1
      001542 F6               [12] 4593 	mov	@r0,a
      001543 09               [12] 4594 	inc	r1
      001544 E7               [12] 4595 	mov	a,@r1
      001545 08               [12] 4596 	inc	r0
      001546 F6               [12] 4597 	mov	@r0,a
      001547 09               [12] 4598 	inc	r1
      001548 E7               [12] 4599 	mov	a,@r1
      001549 08               [12] 4600 	inc	r0
      00154A F6               [12] 4601 	mov	@r0,a
      00154B 09               [12] 4602 	inc	r1
      00154C E7               [12] 4603 	mov	a,@r1
      00154D 08               [12] 4604 	inc	r0
      00154E F6               [12] 4605 	mov	@r0,a
                                   4606 ;	fat.h:790: + (current_cluster-2) * __global_vbr.spc 				//skip to the start of current cluster
      00154F EF               [12] 4607 	mov	a,r7
      001550 24 FE            [12] 4608 	add	a,#0xfe
      001552 F5 82            [12] 4609 	mov	dpl,a
      001554 EE               [12] 4610 	mov	a,r6
      001555 34 FF            [12] 4611 	addc	a,#0xff
      001557 F5 83            [12] 4612 	mov	dph,a
      001559 78r11            [12] 4613 	mov	r0,#(___global_vbr + 0x0008)
      00155B 86 03            [24] 4614 	mov	ar3,@r0
      00155D 8B*00            [24] 4615 	mov	__mulint_PARM_2,r3
      00155F 75*01 00         [24] 4616 	mov	(__mulint_PARM_2 + 1),#0x00
      001562 12r00r00         [24] 4617 	lcall	__mulint
      001565 AB 82            [24] 4618 	mov	r3,dpl
      001567 AF 83            [24] 4619 	mov	r7,dph
      001569 8F 05            [24] 4620 	mov	ar5,r7
      00156B 7E 00            [12] 4621 	mov	r6,#0x00
      00156D 7F 00            [12] 4622 	mov	r7,#0x00
      00156F A8*00            [24] 4623 	mov	r0,_bp
      001571 08               [12] 4624 	inc	r0
      001572 08               [12] 4625 	inc	r0
      001573 EB               [12] 4626 	mov	a,r3
      001574 26               [12] 4627 	add	a,@r0
      001575 F6               [12] 4628 	mov	@r0,a
      001576 ED               [12] 4629 	mov	a,r5
      001577 08               [12] 4630 	inc	r0
      001578 36               [12] 4631 	addc	a,@r0
      001579 F6               [12] 4632 	mov	@r0,a
      00157A EE               [12] 4633 	mov	a,r6
      00157B 08               [12] 4634 	inc	r0
      00157C 36               [12] 4635 	addc	a,@r0
      00157D F6               [12] 4636 	mov	@r0,a
      00157E EF               [12] 4637 	mov	a,r7
      00157F 08               [12] 4638 	inc	r0
      001580 36               [12] 4639 	addc	a,@r0
      001581 F6               [12] 4640 	mov	@r0,a
                                   4641 ;	fat.h:791: + bytes_read_in_current_cluster/__global_vbr.bps;	//skip sectors already read in current cluster
      001582 78r0F            [12] 4642 	mov	r0,#(___global_vbr + 0x0006)
      001584 86 02            [24] 4643 	mov	ar2,@r0
      001586 08               [12] 4644 	inc	r0
      001587 86 04            [24] 4645 	mov	ar4,@r0
      001589 8A*00            [24] 4646 	mov	__divuint_PARM_2,r2
      00158B 8C*01            [24] 4647 	mov	(__divuint_PARM_2 + 1),r4
      00158D E5*00            [12] 4648 	mov	a,_bp
      00158F 24 0A            [12] 4649 	add	a,#0x0a
      001591 F8               [12] 4650 	mov	r0,a
      001592 86 82            [24] 4651 	mov	dpl,@r0
      001594 08               [12] 4652 	inc	r0
      001595 86 83            [24] 4653 	mov	dph,@r0
      001597 C0 04            [24] 4654 	push	ar4
      001599 C0 02            [24] 4655 	push	ar2
      00159B 12r00r00         [24] 4656 	lcall	__divuint
      00159E AE 82            [24] 4657 	mov	r6,dpl
      0015A0 AF 83            [24] 4658 	mov	r7,dph
      0015A2 D0 02            [24] 4659 	pop	ar2
      0015A4 D0 04            [24] 4660 	pop	ar4
      0015A6 7D 00            [12] 4661 	mov	r5,#0x00
      0015A8 7B 00            [12] 4662 	mov	r3,#0x00
      0015AA A8*00            [24] 4663 	mov	r0,_bp
      0015AC 08               [12] 4664 	inc	r0
      0015AD 08               [12] 4665 	inc	r0
      0015AE EE               [12] 4666 	mov	a,r6
      0015AF 26               [12] 4667 	add	a,@r0
      0015B0 FE               [12] 4668 	mov	r6,a
      0015B1 EF               [12] 4669 	mov	a,r7
      0015B2 08               [12] 4670 	inc	r0
      0015B3 36               [12] 4671 	addc	a,@r0
      0015B4 FF               [12] 4672 	mov	r7,a
      0015B5 ED               [12] 4673 	mov	a,r5
      0015B6 08               [12] 4674 	inc	r0
      0015B7 36               [12] 4675 	addc	a,@r0
      0015B8 FD               [12] 4676 	mov	r5,a
      0015B9 EB               [12] 4677 	mov	a,r3
      0015BA 08               [12] 4678 	inc	r0
      0015BB 36               [12] 4679 	addc	a,@r0
      0015BC FB               [12] 4680 	mov	r3,a
      0015BD E5*00            [12] 4681 	mov	a,_bp
      0015BF 24 0E            [12] 4682 	add	a,#0x0e
      0015C1 F8               [12] 4683 	mov	r0,a
      0015C2 A6 06            [24] 4684 	mov	@r0,ar6
      0015C4 08               [12] 4685 	inc	r0
      0015C5 A6 07            [24] 4686 	mov	@r0,ar7
      0015C7 08               [12] 4687 	inc	r0
      0015C8 A6 05            [24] 4688 	mov	@r0,ar5
      0015CA 08               [12] 4689 	inc	r0
      0015CB A6 03            [24] 4690 	mov	@r0,ar3
                                   4691 ;	fat.h:794: bytes_read_in_current_sector = bytes_read_in_current_cluster % __global_vbr.bps;
      0015CD 8A*00            [24] 4692 	mov	__moduint_PARM_2,r2
      0015CF 8C*01            [24] 4693 	mov	(__moduint_PARM_2 + 1),r4
      0015D1 E5*00            [12] 4694 	mov	a,_bp
      0015D3 24 0A            [12] 4695 	add	a,#0x0a
      0015D5 F8               [12] 4696 	mov	r0,a
      0015D6 86 82            [24] 4697 	mov	dpl,@r0
      0015D8 08               [12] 4698 	inc	r0
      0015D9 86 83            [24] 4699 	mov	dph,@r0
      0015DB 12r00r00         [24] 4700 	lcall	__moduint
      0015DE C8               [12] 4701 	xch	a,r0
      0015DF E5*00            [12] 4702 	mov	a,_bp
      0015E1 24 0C            [12] 4703 	add	a,#0x0c
      0015E3 C8               [12] 4704 	xch	a,r0
      0015E4 A6 82            [24] 4705 	mov	@r0,dpl
      0015E6 08               [12] 4706 	inc	r0
      0015E7 A6 83            [24] 4707 	mov	@r0,dph
                                   4708 ;	fat.h:798: if(__global_rootEntry.bytes_read + nbytes > __global_rootEntry.size )
      0015E9 A8*00            [24] 4709 	mov	r0,_bp
      0015EB 08               [12] 4710 	inc	r0
      0015EC 08               [12] 4711 	inc	r0
      0015ED 79r3D            [12] 4712 	mov	r1,#(___global_rootEntry + 0x0014)
      0015EF E7               [12] 4713 	mov	a,@r1
      0015F0 F6               [12] 4714 	mov	@r0,a
      0015F1 09               [12] 4715 	inc	r1
      0015F2 E7               [12] 4716 	mov	a,@r1
      0015F3 08               [12] 4717 	inc	r0
      0015F4 F6               [12] 4718 	mov	@r0,a
      0015F5 09               [12] 4719 	inc	r1
      0015F6 E7               [12] 4720 	mov	a,@r1
      0015F7 08               [12] 4721 	inc	r0
      0015F8 F6               [12] 4722 	mov	@r0,a
      0015F9 09               [12] 4723 	inc	r1
      0015FA E7               [12] 4724 	mov	a,@r1
      0015FB 08               [12] 4725 	inc	r0
      0015FC F6               [12] 4726 	mov	@r0,a
      0015FD A8*00            [24] 4727 	mov	r0,_bp
      0015FF 08               [12] 4728 	inc	r0
      001600 86 03            [24] 4729 	mov	ar3,@r0
      001602 7D 00            [12] 4730 	mov	r5,#0x00
      001604 7E 00            [12] 4731 	mov	r6,#0x00
      001606 7F 00            [12] 4732 	mov	r7,#0x00
      001608 A8*00            [24] 4733 	mov	r0,_bp
      00160A 08               [12] 4734 	inc	r0
      00160B 08               [12] 4735 	inc	r0
      00160C EB               [12] 4736 	mov	a,r3
      00160D 26               [12] 4737 	add	a,@r0
      00160E FB               [12] 4738 	mov	r3,a
      00160F ED               [12] 4739 	mov	a,r5
      001610 08               [12] 4740 	inc	r0
      001611 36               [12] 4741 	addc	a,@r0
      001612 FD               [12] 4742 	mov	r5,a
      001613 EE               [12] 4743 	mov	a,r6
      001614 08               [12] 4744 	inc	r0
      001615 36               [12] 4745 	addc	a,@r0
      001616 FE               [12] 4746 	mov	r6,a
      001617 EF               [12] 4747 	mov	a,r7
      001618 08               [12] 4748 	inc	r0
      001619 36               [12] 4749 	addc	a,@r0
      00161A FF               [12] 4750 	mov	r7,a
      00161B E5*00            [12] 4751 	mov	a,_bp
      00161D 24 06            [12] 4752 	add	a,#0x06
      00161F F8               [12] 4753 	mov	r0,a
      001620 79r37            [12] 4754 	mov	r1,#(___global_rootEntry + 0x000e)
      001622 E7               [12] 4755 	mov	a,@r1
      001623 F6               [12] 4756 	mov	@r0,a
      001624 09               [12] 4757 	inc	r1
      001625 E7               [12] 4758 	mov	a,@r1
      001626 08               [12] 4759 	inc	r0
      001627 F6               [12] 4760 	mov	@r0,a
      001628 09               [12] 4761 	inc	r1
      001629 E7               [12] 4762 	mov	a,@r1
      00162A 08               [12] 4763 	inc	r0
      00162B F6               [12] 4764 	mov	@r0,a
      00162C 09               [12] 4765 	inc	r1
      00162D E7               [12] 4766 	mov	a,@r1
      00162E 08               [12] 4767 	inc	r0
      00162F F6               [12] 4768 	mov	@r0,a
      001630 E5*00            [12] 4769 	mov	a,_bp
      001632 24 06            [12] 4770 	add	a,#0x06
      001634 F8               [12] 4771 	mov	r0,a
      001635 C3               [12] 4772 	clr	c
      001636 E6               [12] 4773 	mov	a,@r0
      001637 9B               [12] 4774 	subb	a,r3
      001638 08               [12] 4775 	inc	r0
      001639 E6               [12] 4776 	mov	a,@r0
      00163A 9D               [12] 4777 	subb	a,r5
      00163B 08               [12] 4778 	inc	r0
      00163C E6               [12] 4779 	mov	a,@r0
      00163D 9E               [12] 4780 	subb	a,r6
      00163E 08               [12] 4781 	inc	r0
      00163F E6               [12] 4782 	mov	a,@r0
      001640 9F               [12] 4783 	subb	a,r7
      001641 50 14            [24] 4784 	jnc	00109$
                                   4785 ;	fat.h:800: nbytes = __global_rootEntry.size - __global_rootEntry.bytes_read;//;
      001643 E5*00            [12] 4786 	mov	a,_bp
      001645 24 06            [12] 4787 	add	a,#0x06
      001647 F8               [12] 4788 	mov	r0,a
      001648 86 07            [24] 4789 	mov	ar7,@r0
      00164A A8*00            [24] 4790 	mov	r0,_bp
      00164C 08               [12] 4791 	inc	r0
      00164D 08               [12] 4792 	inc	r0
      00164E 86 02            [24] 4793 	mov	ar2,@r0
      001650 A8*00            [24] 4794 	mov	r0,_bp
      001652 08               [12] 4795 	inc	r0
      001653 EF               [12] 4796 	mov	a,r7
      001654 C3               [12] 4797 	clr	c
      001655 9A               [12] 4798 	subb	a,r2
      001656 F6               [12] 4799 	mov	@r0,a
      001657                       4800 00109$:
                                   4801 ;	fat.h:819: __global_rootEntry.bytes_read += nbytes;
      001657 A8*00            [24] 4802 	mov	r0,_bp
      001659 08               [12] 4803 	inc	r0
      00165A 86 04            [24] 4804 	mov	ar4,@r0
      00165C 7D 00            [12] 4805 	mov	r5,#0x00
      00165E 7E 00            [12] 4806 	mov	r6,#0x00
      001660 7F 00            [12] 4807 	mov	r7,#0x00
      001662 A8*00            [24] 4808 	mov	r0,_bp
      001664 08               [12] 4809 	inc	r0
      001665 08               [12] 4810 	inc	r0
      001666 EC               [12] 4811 	mov	a,r4
      001667 26               [12] 4812 	add	a,@r0
      001668 FC               [12] 4813 	mov	r4,a
      001669 ED               [12] 4814 	mov	a,r5
      00166A 08               [12] 4815 	inc	r0
      00166B 36               [12] 4816 	addc	a,@r0
      00166C FD               [12] 4817 	mov	r5,a
      00166D EE               [12] 4818 	mov	a,r6
      00166E 08               [12] 4819 	inc	r0
      00166F 36               [12] 4820 	addc	a,@r0
      001670 FE               [12] 4821 	mov	r6,a
      001671 EF               [12] 4822 	mov	a,r7
      001672 08               [12] 4823 	inc	r0
      001673 36               [12] 4824 	addc	a,@r0
      001674 FF               [12] 4825 	mov	r7,a
      001675 78r3D            [12] 4826 	mov	r0,#(___global_rootEntry + 0x0014)
      001677 A6 04            [24] 4827 	mov	@r0,ar4
      001679 08               [12] 4828 	inc	r0
      00167A A6 05            [24] 4829 	mov	@r0,ar5
      00167C 08               [12] 4830 	inc	r0
      00167D A6 06            [24] 4831 	mov	@r0,ar6
      00167F 08               [12] 4832 	inc	r0
      001680 A6 07            [24] 4833 	mov	@r0,ar7
                                   4834 ;	fat.h:822: SDread(current_sector,bytes_read_in_current_sector,nbytes,dst);
      001682 A8*00            [24] 4835 	mov	r0,_bp
      001684 08               [12] 4836 	inc	r0
      001685 86 06            [24] 4837 	mov	ar6,@r0
      001687 7F 00            [12] 4838 	mov	r7,#0x00
      001689 E5*00            [12] 4839 	mov	a,_bp
      00168B 24 FB            [12] 4840 	add	a,#0xfb
      00168D F8               [12] 4841 	mov	r0,a
      00168E E6               [12] 4842 	mov	a,@r0
      00168F C0 E0            [24] 4843 	push	acc
      001691 08               [12] 4844 	inc	r0
      001692 E6               [12] 4845 	mov	a,@r0
      001693 C0 E0            [24] 4846 	push	acc
      001695 08               [12] 4847 	inc	r0
      001696 E6               [12] 4848 	mov	a,@r0
      001697 C0 E0            [24] 4849 	push	acc
      001699 C0 06            [24] 4850 	push	ar6
      00169B C0 07            [24] 4851 	push	ar7
      00169D E5*00            [12] 4852 	mov	a,_bp
      00169F 24 0C            [12] 4853 	add	a,#0x0c
      0016A1 F8               [12] 4854 	mov	r0,a
      0016A2 E6               [12] 4855 	mov	a,@r0
      0016A3 C0 E0            [24] 4856 	push	acc
      0016A5 08               [12] 4857 	inc	r0
      0016A6 E6               [12] 4858 	mov	a,@r0
      0016A7 C0 E0            [24] 4859 	push	acc
      0016A9 E5*00            [12] 4860 	mov	a,_bp
      0016AB 24 0E            [12] 4861 	add	a,#0x0e
      0016AD F8               [12] 4862 	mov	r0,a
      0016AE 86 82            [24] 4863 	mov	dpl,@r0
      0016B0 08               [12] 4864 	inc	r0
      0016B1 86 83            [24] 4865 	mov	dph,@r0
      0016B3 08               [12] 4866 	inc	r0
      0016B4 86 F0            [24] 4867 	mov	b,@r0
      0016B6 08               [12] 4868 	inc	r0
      0016B7 E6               [12] 4869 	mov	a,@r0
      0016B8 12r07r11         [24] 4870 	lcall	_SDread
      0016BB E5 81            [12] 4871 	mov	a,sp
      0016BD 24 F9            [12] 4872 	add	a,#0xf9
      0016BF F5 81            [12] 4873 	mov	sp,a
                                   4874 ;	fat.h:827: return nbytes;
      0016C1 A8*00            [24] 4875 	mov	r0,_bp
      0016C3 08               [12] 4876 	inc	r0
      0016C4 86 82            [24] 4877 	mov	dpl,@r0
      0016C6                       4878 00113$:
                                   4879 ;	fat.h:829: }
      0016C6 85*00 81         [24] 4880 	mov	sp,_bp
      0016C9 D0*00            [24] 4881 	pop	_bp
      0016CB 22               [24] 4882 	ret
                                   4883 ;------------------------------------------------------------
                                   4884 ;Allocation info for local variables in function 'FAT16_FILE_CAT'
                                   4885 ;------------------------------------------------------------
                                   4886 ;filename                  Allocated to registers r5 r6 r7 
                                   4887 ;temp                      Allocated to stack - _bp +1
                                   4888 ;resp                      Allocated to registers r6 
                                   4889 ;i                         Allocated to registers r5 
                                   4890 ;------------------------------------------------------------
                                   4891 ;	fat.h:831: void FAT16_FILE_CAT(uint8_t *filename) __reentrant
                                   4892 ;	-----------------------------------------
                                   4893 ;	 function FAT16_FILE_CAT
                                   4894 ;	-----------------------------------------
      0016CC                       4895 _FAT16_FILE_CAT:
      0016CC C0*00            [24] 4896 	push	_bp
      0016CE E5 81            [12] 4897 	mov	a,sp
      0016D0 F5*00            [12] 4898 	mov	_bp,a
      0016D2 24 08            [12] 4899 	add	a,#0x08
      0016D4 F5 81            [12] 4900 	mov	sp,a
                                   4901 ;	fat.h:838: if(FAT16_FILE_OPEN(filename))
      0016D6 12r12rE6         [24] 4902 	lcall	_FAT16_FILE_OPEN
      0016D9 E5 82            [12] 4903 	mov	a,dpl
      0016DB 60 0B            [24] 4904 	jz	00115$
                                   4905 ;	fat.h:840: UartPrint("FILE NOT FOUND\n.");
      0016DD 90r00rA8         [24] 4906 	mov	dptr,#___str_8
      0016E0 75 F0 80         [24] 4907 	mov	b,#0x80
      0016E3 12r01r1B         [24] 4908 	lcall	_UartPrint
                                   4909 ;	fat.h:841: return;
                                   4910 ;	fat.h:844: do
      0016E6 80 42            [24] 4911 	sjmp	00110$
      0016E8                       4912 00115$:
      0016E8 AF*00            [24] 4913 	mov	r7,_bp
      0016EA 0F               [12] 4914 	inc	r7
      0016EB                       4915 00104$:
                                   4916 ;	fat.h:846: resp=FAT16_FILE_READ(FILE_CAT_BUFFER_SIZE,temp);
      0016EB 8F 04            [24] 4917 	mov	ar4,r7
      0016ED 7D 00            [12] 4918 	mov	r5,#0x00
      0016EF 7E 40            [12] 4919 	mov	r6,#0x40
      0016F1 C0 07            [24] 4920 	push	ar7
      0016F3 C0 04            [24] 4921 	push	ar4
      0016F5 C0 05            [24] 4922 	push	ar5
      0016F7 C0 06            [24] 4923 	push	ar6
      0016F9 75 82 08         [24] 4924 	mov	dpl,#0x08
      0016FC 12r14r63         [24] 4925 	lcall	_FAT16_FILE_READ
      0016FF AE 82            [24] 4926 	mov	r6,dpl
      001701 15 81            [12] 4927 	dec	sp
      001703 15 81            [12] 4928 	dec	sp
      001705 15 81            [12] 4929 	dec	sp
      001707 D0 07            [24] 4930 	pop	ar7
                                   4931 ;	fat.h:847: for(uint8_t i=0;i<resp;i++) UartWrite(temp[i]);
      001709 7D 00            [12] 4932 	mov	r5,#0x00
      00170B                       4933 00108$:
      00170B C3               [12] 4934 	clr	c
      00170C ED               [12] 4935 	mov	a,r5
      00170D 9E               [12] 4936 	subb	a,r6
      00170E 50 17            [24] 4937 	jnc	00105$
      001710 ED               [12] 4938 	mov	a,r5
      001711 2F               [12] 4939 	add	a,r7
      001712 F9               [12] 4940 	mov	r1,a
      001713 87 82            [24] 4941 	mov	dpl,@r1
      001715 C0 07            [24] 4942 	push	ar7
      001717 C0 06            [24] 4943 	push	ar6
      001719 C0 05            [24] 4944 	push	ar5
      00171B 12r00r95         [24] 4945 	lcall	_UartWrite
      00171E D0 05            [24] 4946 	pop	ar5
      001720 D0 06            [24] 4947 	pop	ar6
      001722 D0 07            [24] 4948 	pop	ar7
      001724 0D               [12] 4949 	inc	r5
      001725 80 E4            [24] 4950 	sjmp	00108$
      001727                       4951 00105$:
                                   4952 ;	fat.h:850: } while (resp!=0);
      001727 EE               [12] 4953 	mov	a,r6
      001728 70 C1            [24] 4954 	jnz	00104$
                                   4955 ;	fat.h:852: return;
      00172A                       4956 00110$:
                                   4957 ;	fat.h:854: }
      00172A 85*00 81         [24] 4958 	mov	sp,_bp
      00172D D0*00            [24] 4959 	pop	_bp
      00172F 22               [24] 4960 	ret
                                   4961 ;------------------------------------------------------------
                                   4962 ;Allocation info for local variables in function 'delay_ms'
                                   4963 ;------------------------------------------------------------
                                   4964 ;millisec                  Allocated to registers r6 r7 
                                   4965 ;i                         Allocated to registers r4 r5 
                                   4966 ;j                         Allocated to registers r3 
                                   4967 ;------------------------------------------------------------
                                   4968 ;	serialloader.h:16: void delay_ms(unsigned int millisec)
                                   4969 ;	-----------------------------------------
                                   4970 ;	 function delay_ms
                                   4971 ;	-----------------------------------------
      001730                       4972 _delay_ms:
      001730 AE 82            [24] 4973 	mov	r6,dpl
      001732 AF 83            [24] 4974 	mov	r7,dph
                                   4975 ;	serialloader.h:18: for(unsigned int i=0;i<millisec;i++)for(unsigned char j=0;j<255;j++); //wait millisec * 1ms
      001734 7C 00            [12] 4976 	mov	r4,#0x00
      001736 7D 00            [12] 4977 	mov	r5,#0x00
      001738                       4978 00107$:
      001738 C3               [12] 4979 	clr	c
      001739 EC               [12] 4980 	mov	a,r4
      00173A 9E               [12] 4981 	subb	a,r6
      00173B ED               [12] 4982 	mov	a,r5
      00173C 9F               [12] 4983 	subb	a,r7
      00173D 50 11            [24] 4984 	jnc	00109$
      00173F 7B 00            [12] 4985 	mov	r3,#0x00
      001741                       4986 00104$:
      001741 BB FF 00         [24] 4987 	cjne	r3,#0xff,00130$
      001744                       4988 00130$:
      001744 50 03            [24] 4989 	jnc	00108$
      001746 0B               [12] 4990 	inc	r3
      001747 80 F8            [24] 4991 	sjmp	00104$
      001749                       4992 00108$:
      001749 0C               [12] 4993 	inc	r4
      00174A BC 00 EB         [24] 4994 	cjne	r4,#0x00,00107$
      00174D 0D               [12] 4995 	inc	r5
      00174E 80 E8            [24] 4996 	sjmp	00107$
      001750                       4997 00109$:
                                   4998 ;	serialloader.h:19: }
      001750 22               [24] 4999 	ret
                                   5000 ;------------------------------------------------------------
                                   5001 ;Allocation info for local variables in function 'SL_disable_write_protection'
                                   5002 ;------------------------------------------------------------
                                   5003 ;xram_addr                 Allocated to registers 
                                   5004 ;------------------------------------------------------------
                                   5005 ;	serialloader.h:21: void SL_disable_write_protection()
                                   5006 ;	-----------------------------------------
                                   5007 ;	 function SL_disable_write_protection
                                   5008 ;	-----------------------------------------
      001751                       5009 _SL_disable_write_protection:
                                   5010 ;	serialloader.h:26: *(xram_addr) = 0xAA;
      001751 90 15 55         [24] 5011 	mov	dptr,#0x1555
      001754 74 AA            [12] 5012 	mov	a,#0xaa
      001756 F0               [24] 5013 	movx	@dptr,a
                                   5014 ;	serialloader.h:28: *(xram_addr) = 0x55;
      001757 90 0A AA         [24] 5015 	mov	dptr,#0x0aaa
      00175A F4               [12] 5016 	cpl	a
      00175B F0               [24] 5017 	movx	@dptr,a
                                   5018 ;	serialloader.h:30: *(xram_addr) = 0x80;
                                   5019 ;	serialloader.h:34: *(xram_addr) = 0xAA;
      00175C 90 15 55         [24] 5020 	mov	dptr,#0x1555
      00175F 74 80            [12] 5021 	mov	a,#0x80
      001761 F0               [24] 5022 	movx	@dptr,a
      001762 74 AA            [12] 5023 	mov	a,#0xaa
      001764 F0               [24] 5024 	movx	@dptr,a
                                   5025 ;	serialloader.h:36: *(xram_addr) = 0x55;
      001765 90 0A AA         [24] 5026 	mov	dptr,#0x0aaa
      001768 F4               [12] 5027 	cpl	a
      001769 F0               [24] 5028 	movx	@dptr,a
                                   5029 ;	serialloader.h:38: *(xram_addr) = 0x20;
      00176A 90 15 55         [24] 5030 	mov	dptr,#0x1555
      00176D 74 20            [12] 5031 	mov	a,#0x20
      00176F F0               [24] 5032 	movx	@dptr,a
                                   5033 ;	serialloader.h:40: UartWrite('D'); //ack
      001770 75 82 44         [24] 5034 	mov	dpl,#0x44
      001773 12r00r95         [24] 5035 	lcall	_UartWrite
                                   5036 ;	serialloader.h:42: EEPROM_WRITE_PROTECTION=0; //change flag
      001776 75*23 00         [24] 5037 	mov	_EEPROM_WRITE_PROTECTION,#0x00
                                   5038 ;	serialloader.h:43: }
      001779 22               [24] 5039 	ret
                                   5040 ;------------------------------------------------------------
                                   5041 ;Allocation info for local variables in function 'SL_enable_write_protection'
                                   5042 ;------------------------------------------------------------
                                   5043 ;	serialloader.h:45: void SL_enable_write_protection()
                                   5044 ;	-----------------------------------------
                                   5045 ;	 function SL_enable_write_protection
                                   5046 ;	-----------------------------------------
      00177A                       5047 _SL_enable_write_protection:
                                   5048 ;	serialloader.h:47: EEPROM_WRITE_PROTECTION=1; //change flag
      00177A 75*23 01         [24] 5049 	mov	_EEPROM_WRITE_PROTECTION,#0x01
                                   5050 ;	serialloader.h:48: UartWrite('E'); 
      00177D 75 82 45         [24] 5051 	mov	dpl,#0x45
                                   5052 ;	serialloader.h:49: }
      001780 02r00r95         [24] 5053 	ljmp	_UartWrite
                                   5054 ;------------------------------------------------------------
                                   5055 ;Allocation info for local variables in function 'SL_write'
                                   5056 ;------------------------------------------------------------
                                   5057 ;data                      Allocated to registers r5 
                                   5058 ;addr                      Allocated to registers r7 r6 
                                   5059 ;xram_addr                 Allocated to registers 
                                   5060 ;------------------------------------------------------------
                                   5061 ;	serialloader.h:51: void SL_write()
                                   5062 ;	-----------------------------------------
                                   5063 ;	 function SL_write
                                   5064 ;	-----------------------------------------
      001783                       5065 _SL_write:
                                   5066 ;	serialloader.h:57: while(UartReadReady()==0); //wait till we rcv data
      001783                       5067 00101$:
      001783 12r00r81         [24] 5068 	lcall	_UartReadReady
      001786 E5 82            [12] 5069 	mov	a,dpl
      001788 60 F9            [24] 5070 	jz	00101$
                                   5071 ;	serialloader.h:60: addr = UartRead(); //msb
      00178A 12r00r8C         [24] 5072 	lcall	_UartRead
                                   5073 ;	serialloader.h:61: addr = addr << 8;
      00178D AE 82            [24] 5074 	mov	r6,dpl
      00178F 7F 00            [12] 5075 	mov	r7,#0x00
                                   5076 ;	serialloader.h:62: addr |= UartRead(); //lsb
      001791 C0 07            [24] 5077 	push	ar7
      001793 C0 06            [24] 5078 	push	ar6
      001795 12r00r8C         [24] 5079 	lcall	_UartRead
      001798 AD 82            [24] 5080 	mov	r5,dpl
      00179A D0 06            [24] 5081 	pop	ar6
      00179C D0 07            [24] 5082 	pop	ar7
      00179E 7C 00            [12] 5083 	mov	r4,#0x00
      0017A0 ED               [12] 5084 	mov	a,r5
      0017A1 42 07            [12] 5085 	orl	ar7,a
      0017A3 EC               [12] 5086 	mov	a,r4
      0017A4 42 06            [12] 5087 	orl	ar6,a
                                   5088 ;	serialloader.h:64: data = UartRead(); //read data
      0017A6 C0 07            [24] 5089 	push	ar7
      0017A8 C0 06            [24] 5090 	push	ar6
      0017AA 12r00r8C         [24] 5091 	lcall	_UartRead
      0017AD AD 82            [24] 5092 	mov	r5,dpl
      0017AF D0 06            [24] 5093 	pop	ar6
      0017B1 D0 07            [24] 5094 	pop	ar7
                                   5095 ;	serialloader.h:66: if(EEPROM_WRITE_PROTECTION)
      0017B3 E5*23            [12] 5096 	mov	a,_EEPROM_WRITE_PROTECTION
      0017B5 60 11            [24] 5097 	jz	00105$
                                   5098 ;	serialloader.h:70: *(xram_addr) = 0xAA;
      0017B7 90 15 55         [24] 5099 	mov	dptr,#0x1555
      0017BA 74 AA            [12] 5100 	mov	a,#0xaa
      0017BC F0               [24] 5101 	movx	@dptr,a
                                   5102 ;	serialloader.h:72: *(xram_addr) = 0x55;
      0017BD 90 0A AA         [24] 5103 	mov	dptr,#0x0aaa
      0017C0 F4               [12] 5104 	cpl	a
      0017C1 F0               [24] 5105 	movx	@dptr,a
                                   5106 ;	serialloader.h:74: *(xram_addr) = 0xA0;
      0017C2 90 15 55         [24] 5107 	mov	dptr,#0x1555
      0017C5 74 A0            [12] 5108 	mov	a,#0xa0
      0017C7 F0               [24] 5109 	movx	@dptr,a
      0017C8                       5110 00105$:
                                   5111 ;	serialloader.h:77: xram_addr = (__xdata unsigned char*) addr;
      0017C8 8F 82            [24] 5112 	mov	dpl,r7
      0017CA 8E 83            [24] 5113 	mov	dph,r6
                                   5114 ;	serialloader.h:79: *(xram_addr) = data; //write to xram
      0017CC ED               [12] 5115 	mov	a,r5
      0017CD F0               [24] 5116 	movx	@dptr,a
                                   5117 ;	serialloader.h:81: UartWrite('W'); //ack
      0017CE 75 82 57         [24] 5118 	mov	dpl,#0x57
                                   5119 ;	serialloader.h:83: }
      0017D1 02r00r95         [24] 5120 	ljmp	_UartWrite
                                   5121 ;------------------------------------------------------------
                                   5122 ;Allocation info for local variables in function 'SL_read'
                                   5123 ;------------------------------------------------------------
                                   5124 ;data                      Allocated to registers r7 
                                   5125 ;addr                      Allocated to registers r7 r6 
                                   5126 ;xram_addr                 Allocated to registers 
                                   5127 ;------------------------------------------------------------
                                   5128 ;	serialloader.h:85: void SL_read()
                                   5129 ;	-----------------------------------------
                                   5130 ;	 function SL_read
                                   5131 ;	-----------------------------------------
      0017D4                       5132 _SL_read:
                                   5133 ;	serialloader.h:91: while(UartReadReady()==0); //wait till we rcv data
      0017D4                       5134 00101$:
      0017D4 12r00r81         [24] 5135 	lcall	_UartReadReady
      0017D7 E5 82            [12] 5136 	mov	a,dpl
      0017D9 60 F9            [24] 5137 	jz	00101$
                                   5138 ;	serialloader.h:95: addr = UartRead(); //msb
      0017DB 12r00r8C         [24] 5139 	lcall	_UartRead
                                   5140 ;	serialloader.h:96: addr = addr << 8;
      0017DE AE 82            [24] 5141 	mov	r6,dpl
      0017E0 7F 00            [12] 5142 	mov	r7,#0x00
                                   5143 ;	serialloader.h:97: addr |= UartRead(); //lsb
      0017E2 C0 07            [24] 5144 	push	ar7
      0017E4 C0 06            [24] 5145 	push	ar6
      0017E6 12r00r8C         [24] 5146 	lcall	_UartRead
      0017E9 AD 82            [24] 5147 	mov	r5,dpl
      0017EB D0 06            [24] 5148 	pop	ar6
      0017ED D0 07            [24] 5149 	pop	ar7
      0017EF 7C 00            [12] 5150 	mov	r4,#0x00
      0017F1 ED               [12] 5151 	mov	a,r5
      0017F2 42 07            [12] 5152 	orl	ar7,a
      0017F4 EC               [12] 5153 	mov	a,r4
      0017F5 42 06            [12] 5154 	orl	ar6,a
                                   5155 ;	serialloader.h:99: xram_addr = (__xdata unsigned char*) addr;
      0017F7 8F 82            [24] 5156 	mov	dpl,r7
      0017F9 8E 83            [24] 5157 	mov	dph,r6
                                   5158 ;	serialloader.h:101: data = *(xram_addr); //read from xram
      0017FB E0               [24] 5159 	movx	a,@dptr
                                   5160 ;	serialloader.h:103: UartWrite(data);
      0017FC F5 82            [12] 5161 	mov	dpl,a
                                   5162 ;	serialloader.h:105: }
      0017FE 02r00r95         [24] 5163 	ljmp	_UartWrite
                                   5164 ;------------------------------------------------------------
                                   5165 ;Allocation info for local variables in function 'SL_getcmd'
                                   5166 ;------------------------------------------------------------
                                   5167 ;cmd                       Allocated to registers r7 
                                   5168 ;------------------------------------------------------------
                                   5169 ;	serialloader.h:107: void SL_getcmd()
                                   5170 ;	-----------------------------------------
                                   5171 ;	 function SL_getcmd
                                   5172 ;	-----------------------------------------
      001801                       5173 _SL_getcmd:
                                   5174 ;	serialloader.h:110: while(UartReadReady()) UartRead(); //flush 
      001801                       5175 00101$:
      001801 12r00r81         [24] 5176 	lcall	_UartReadReady
      001804 E5 82            [12] 5177 	mov	a,dpl
      001806 60 05            [24] 5178 	jz	00104$
      001808 12r00r8C         [24] 5179 	lcall	_UartRead
                                   5180 ;	serialloader.h:112: while(UartReadReady()==0); //wait till we rcv data 
      00180B 80 F4            [24] 5181 	sjmp	00101$
      00180D                       5182 00104$:
      00180D 12r00r81         [24] 5183 	lcall	_UartReadReady
      001810 E5 82            [12] 5184 	mov	a,dpl
      001812 60 F9            [24] 5185 	jz	00104$
                                   5186 ;	serialloader.h:115: cmd = UartRead(); //read
      001814 12r00r8C         [24] 5187 	lcall	_UartRead
      001817 AF 82            [24] 5188 	mov	r7,dpl
                                   5189 ;	serialloader.h:117: switch(cmd)
      001819 BF 44 02         [24] 5190 	cjne	r7,#0x44,00154$
      00181C 80 23            [24] 5191 	sjmp	00110$
      00181E                       5192 00154$:
      00181E BF 45 02         [24] 5193 	cjne	r7,#0x45,00155$
      001821 80 21            [24] 5194 	sjmp	00111$
      001823                       5195 00155$:
      001823 BF 52 02         [24] 5196 	cjne	r7,#0x52,00156$
      001826 80 13            [24] 5197 	sjmp	00108$
      001828                       5198 00156$:
      001828 BF 56 02         [24] 5199 	cjne	r7,#0x56,00157$
      00182B 80 05            [24] 5200 	sjmp	00107$
      00182D                       5201 00157$:
                                   5202 ;	serialloader.h:119: case 'V':
      00182D BF 57 17         [24] 5203 	cjne	r7,#0x57,00114$
      001830 80 0C            [24] 5204 	sjmp	00109$
      001832                       5205 00107$:
                                   5206 ;	serialloader.h:120: UartPrint("ISA_SERIAL_LOADER_V0.1:8052\n");
      001832 90r00rB9         [24] 5207 	mov	dptr,#___str_9
      001835 75 F0 80         [24] 5208 	mov	b,#0x80
                                   5209 ;	serialloader.h:121: break;
                                   5210 ;	serialloader.h:122: case 'R':
      001838 02r01r1B         [24] 5211 	ljmp	_UartPrint
      00183B                       5212 00108$:
                                   5213 ;	serialloader.h:123: SL_read();
                                   5214 ;	serialloader.h:124: break;
                                   5215 ;	serialloader.h:125: case 'W':
      00183B 02r17rD4         [24] 5216 	ljmp	_SL_read
      00183E                       5217 00109$:
                                   5218 ;	serialloader.h:126: SL_write();
                                   5219 ;	serialloader.h:127: break;
                                   5220 ;	serialloader.h:128: case 'D':
      00183E 02r17r83         [24] 5221 	ljmp	_SL_write
      001841                       5222 00110$:
                                   5223 ;	serialloader.h:129: SL_disable_write_protection();
                                   5224 ;	serialloader.h:130: break;
                                   5225 ;	serialloader.h:131: case 'E':
      001841 02r17r51         [24] 5226 	ljmp	_SL_disable_write_protection
      001844                       5227 00111$:
                                   5228 ;	serialloader.h:132: SL_enable_write_protection();
                                   5229 ;	serialloader.h:136: }
                                   5230 ;	serialloader.h:137: }
      001844 02r17r7A         [24] 5231 	ljmp	_SL_enable_write_protection
      001847                       5232 00114$:
      001847 22               [24] 5233 	ret
                                   5234 ;------------------------------------------------------------
                                   5235 ;Allocation info for local variables in function 'delay'
                                   5236 ;------------------------------------------------------------
                                   5237 ;i                         Allocated to registers r7 
                                   5238 ;j                         Allocated to registers r6 
                                   5239 ;------------------------------------------------------------
                                   5240 ;	main.c:20: void delay(void) __reentrant
                                   5241 ;	-----------------------------------------
                                   5242 ;	 function delay
                                   5243 ;	-----------------------------------------
      001848                       5244 _delay:
                                   5245 ;	main.c:23: for(i=0;i<127;i++)
      001848 7F 00            [12] 5246 	mov	r7,#0x00
      00184A                       5247 00106$:
                                   5248 ;	main.c:24: for(j=0;j<127;j++);
      00184A 7E 7F            [12] 5249 	mov	r6,#0x7f
      00184C                       5250 00105$:
      00184C EE               [12] 5251 	mov	a,r6
      00184D 14               [12] 5252 	dec	a
      00184E FE               [12] 5253 	mov	r6,a
      00184F 70 FB            [24] 5254 	jnz	00105$
                                   5255 ;	main.c:23: for(i=0;i<127;i++)
      001851 0F               [12] 5256 	inc	r7
      001852 BF 7F 00         [24] 5257 	cjne	r7,#0x7f,00124$
      001855                       5258 00124$:
      001855 40 F3            [24] 5259 	jc	00106$
                                   5260 ;	main.c:25: }
      001857 22               [24] 5261 	ret
                                   5262 ;------------------------------------------------------------
                                   5263 ;Allocation info for local variables in function 'SelectFAT16PartitionPrompt'
                                   5264 ;------------------------------------------------------------
                                   5265 ;_resp                     Allocated to registers r6 
                                   5266 ;_temp                     Allocated to registers r5 
                                   5267 ;i                         Allocated to registers r5 
                                   5268 ;i                         Allocated to registers r5 
                                   5269 ;------------------------------------------------------------
                                   5270 ;	main.c:27: void SelectFAT16PartitionPrompt() __reentrant
                                   5271 ;	-----------------------------------------
                                   5272 ;	 function SelectFAT16PartitionPrompt
                                   5273 ;	-----------------------------------------
      001858                       5274 _SelectFAT16PartitionPrompt:
                                   5275 ;	main.c:32: if(MBR_CHECK__SIGNATURE())
      001858 12r0BrE1         [24] 5276 	lcall	_MBR_CHECK__SIGNATURE
      00185B E5 82            [12] 5277 	mov	a,dpl
      00185D 60 09            [24] 5278 	jz	00102$
                                   5279 ;	main.c:35: UartPrint("ERROR:NO MBR FOUND\n");
      00185F 90r00rD6         [24] 5280 	mov	dptr,#___str_11
      001862 75 F0 80         [24] 5281 	mov	b,#0x80
      001865 12r01r1B         [24] 5282 	lcall	_UartPrint
      001868                       5283 00102$:
                                   5284 ;	main.c:39: _resp=MBR_DETECT_FAT16();
      001868 12r0CrBF         [24] 5285 	lcall	_MBR_DETECT_FAT16
                                   5286 ;	main.c:40: if(_resp)
      00186B E5 82            [12] 5287 	mov	a,dpl
      00186D FF               [12] 5288 	mov	r7,a
      00186E FE               [12] 5289 	mov	r6,a
      00186F 70 03            [24] 5290 	jnz	00201$
      001871 02r19rDE         [24] 5291 	ljmp	00129$
      001874                       5292 00201$:
                                   5293 ;	main.c:44: if( (_resp & (_resp-1)) == 0)
      001874 7F 00            [12] 5294 	mov	r7,#0x00
      001876 EE               [12] 5295 	mov	a,r6
      001877 24 FF            [12] 5296 	add	a,#0xff
      001879 FC               [12] 5297 	mov	r4,a
      00187A EF               [12] 5298 	mov	a,r7
      00187B 34 FF            [12] 5299 	addc	a,#0xff
      00187D FD               [12] 5300 	mov	r5,a
      00187E EE               [12] 5301 	mov	a,r6
      00187F 52 04            [12] 5302 	anl	ar4,a
      001881 EF               [12] 5303 	mov	a,r7
      001882 52 05            [12] 5304 	anl	ar5,a
      001884 EC               [12] 5305 	mov	a,r4
      001885 4D               [12] 5306 	orl	a,r5
                                   5307 ;	main.c:46: for(uint8_t i=0;i<4;i++)
      001886 70 68            [24] 5308 	jnz	00149$
      001888 FD               [12] 5309 	mov	r5,a
      001889 FC               [12] 5310 	mov	r4,a
      00188A                       5311 00132$:
      00188A BC 04 00         [24] 5312 	cjne	r4,#0x04,00203$
      00188D                       5313 00203$:
      00188D 40 01            [24] 5314 	jc	00204$
      00188F 22               [24] 5315 	ret
      001890                       5316 00204$:
                                   5317 ;	main.c:48: if(_resp & 1<<i) 
      001890 8C F0            [24] 5318 	mov	b,r4
      001892 05 F0            [12] 5319 	inc	b
      001894 7A 01            [12] 5320 	mov	r2,#0x01
      001896 7B 00            [12] 5321 	mov	r3,#0x00
      001898 80 06            [24] 5322 	sjmp	00206$
      00189A                       5323 00205$:
      00189A EA               [12] 5324 	mov	a,r2
      00189B 2A               [12] 5325 	add	a,r2
      00189C FA               [12] 5326 	mov	r2,a
      00189D EB               [12] 5327 	mov	a,r3
      00189E 33               [12] 5328 	rlc	a
      00189F FB               [12] 5329 	mov	r3,a
      0018A0                       5330 00206$:
      0018A0 D5 F0 F7         [24] 5331 	djnz	b,00205$
      0018A3 EE               [12] 5332 	mov	a,r6
      0018A4 52 02            [12] 5333 	anl	ar2,a
      0018A6 EF               [12] 5334 	mov	a,r7
      0018A7 52 03            [12] 5335 	anl	ar3,a
      0018A9 EA               [12] 5336 	mov	a,r2
      0018AA 4B               [12] 5337 	orl	a,r3
      0018AB 60 3E            [24] 5338 	jz	00133$
                                   5339 ;	main.c:50: VBR_MOUNT_VBR(i);
      0018AD 8D 82            [24] 5340 	mov	dpl,r5
      0018AF C0 05            [24] 5341 	push	ar5
      0018B1 12r0Er1A         [24] 5342 	lcall	_VBR_MOUNT_VBR
                                   5343 ;	main.c:51: UartPrint("Partition Mounted:");UartWriteNumber(i,HEX);
      0018B4 90r00rEA         [24] 5344 	mov	dptr,#___str_12
      0018B7 75 F0 80         [24] 5345 	mov	b,#0x80
      0018BA 12r01r1B         [24] 5346 	lcall	_UartPrint
      0018BD D0 05            [24] 5347 	pop	ar5
      0018BF C0 05            [24] 5348 	push	ar5
      0018C1 E4               [12] 5349 	clr	a
      0018C2 C0 E0            [24] 5350 	push	acc
      0018C4 8D 82            [24] 5351 	mov	dpl,r5
      0018C6 12r01r4D         [24] 5352 	lcall	_UartWriteNumber
      0018C9 15 81            [12] 5353 	dec	sp
      0018CB D0 05            [24] 5354 	pop	ar5
                                   5355 ;	main.c:52: if(VBR_FAT16_CHECK_COMPATIBILITY(i))
      0018CD 8D 82            [24] 5356 	mov	dpl,r5
      0018CF 12r10r36         [24] 5357 	lcall	_VBR_FAT16_CHECK_COMPATIBILITY
      0018D2 E5 82            [12] 5358 	mov	a,dpl
      0018D4 70 01            [24] 5359 	jnz	00208$
      0018D6 22               [24] 5360 	ret
      0018D7                       5361 00208$:
                                   5362 ;	main.c:54: UartPrint("Incompatible FAT16\n");
      0018D7 90r00rFD         [24] 5363 	mov	dptr,#___str_13
      0018DA 75 F0 80         [24] 5364 	mov	b,#0x80
      0018DD 12r01r1B         [24] 5365 	lcall	_UartPrint
                                   5366 ;	main.c:55: UartPrint(HALTING_MSG); while(1);
      0018E0 90r1ArA8         [24] 5367 	mov	dptr,#_SelectFAT16PartitionPrompt_HALTING_MSG_65536_209
      0018E3 75 F0 80         [24] 5368 	mov	b,#0x80
      0018E6 12r01r1B         [24] 5369 	lcall	_UartPrint
      0018E9                       5370 00104$:
                                   5371 ;	main.c:57: break; //break from for loop
      0018E9 80 FE            [24] 5372 	sjmp	00104$
      0018EB                       5373 00133$:
                                   5374 ;	main.c:46: for(uint8_t i=0;i<4;i++)
      0018EB 0C               [12] 5375 	inc	r4
      0018EC 8C 05            [24] 5376 	mov	ar5,r4
                                   5377 ;	main.c:63: for(uint8_t i=0;i<4;i++)
      0018EE 80 9A            [24] 5378 	sjmp	00132$
      0018F0                       5379 00149$:
      0018F0 7D 00            [12] 5380 	mov	r5,#0x00
      0018F2                       5381 00135$:
      0018F2 BD 04 00         [24] 5382 	cjne	r5,#0x04,00209$
      0018F5                       5383 00209$:
      0018F5 50 75            [24] 5384 	jnc	00114$
                                   5385 ;	main.c:65: UartPrint("Partition-");UartWriteNumber(i,HEX);UartWrite('> ');
      0018F7 90r01r11         [24] 5386 	mov	dptr,#___str_14
      0018FA 75 F0 80         [24] 5387 	mov	b,#0x80
      0018FD C0 07            [24] 5388 	push	ar7
      0018FF C0 06            [24] 5389 	push	ar6
      001901 C0 05            [24] 5390 	push	ar5
      001903 12r01r1B         [24] 5391 	lcall	_UartPrint
      001906 D0 05            [24] 5392 	pop	ar5
      001908 C0 05            [24] 5393 	push	ar5
      00190A E4               [12] 5394 	clr	a
      00190B C0 E0            [24] 5395 	push	acc
      00190D 8D 82            [24] 5396 	mov	dpl,r5
      00190F 12r01r4D         [24] 5397 	lcall	_UartWriteNumber
      001912 15 81            [12] 5398 	dec	sp
      001914 75 82 3E         [24] 5399 	mov	dpl,#0x3e
      001917 12r00r95         [24] 5400 	lcall	_UartWrite
      00191A D0 05            [24] 5401 	pop	ar5
      00191C D0 06            [24] 5402 	pop	ar6
      00191E D0 07            [24] 5403 	pop	ar7
                                   5404 ;	main.c:66: if(_resp & 1<<i) UartPrint("FAT16\n");
      001920 8D F0            [24] 5405 	mov	b,r5
      001922 05 F0            [12] 5406 	inc	b
      001924 7B 01            [12] 5407 	mov	r3,#0x01
      001926 7C 00            [12] 5408 	mov	r4,#0x00
      001928 80 06            [24] 5409 	sjmp	00212$
      00192A                       5410 00211$:
      00192A EB               [12] 5411 	mov	a,r3
      00192B 2B               [12] 5412 	add	a,r3
      00192C FB               [12] 5413 	mov	r3,a
      00192D EC               [12] 5414 	mov	a,r4
      00192E 33               [12] 5415 	rlc	a
      00192F FC               [12] 5416 	mov	r4,a
      001930                       5417 00212$:
      001930 D5 F0 F7         [24] 5418 	djnz	b,00211$
      001933 EE               [12] 5419 	mov	a,r6
      001934 52 03            [12] 5420 	anl	ar3,a
      001936 EF               [12] 5421 	mov	a,r7
      001937 52 04            [12] 5422 	anl	ar4,a
      001939 EB               [12] 5423 	mov	a,r3
      00193A 4C               [12] 5424 	orl	a,r4
      00193B 60 17            [24] 5425 	jz	00112$
      00193D 90r01r1C         [24] 5426 	mov	dptr,#___str_15
      001940 75 F0 80         [24] 5427 	mov	b,#0x80
      001943 C0 07            [24] 5428 	push	ar7
      001945 C0 06            [24] 5429 	push	ar6
      001947 C0 05            [24] 5430 	push	ar5
      001949 12r01r1B         [24] 5431 	lcall	_UartPrint
      00194C D0 05            [24] 5432 	pop	ar5
      00194E D0 06            [24] 5433 	pop	ar6
      001950 D0 07            [24] 5434 	pop	ar7
      001952 80 15            [24] 5435 	sjmp	00136$
      001954                       5436 00112$:
                                   5437 ;	main.c:67: else UartPrint("Unknown\n");
      001954 90r01r23         [24] 5438 	mov	dptr,#___str_16
      001957 75 F0 80         [24] 5439 	mov	b,#0x80
      00195A C0 07            [24] 5440 	push	ar7
      00195C C0 06            [24] 5441 	push	ar6
      00195E C0 05            [24] 5442 	push	ar5
      001960 12r01r1B         [24] 5443 	lcall	_UartPrint
      001963 D0 05            [24] 5444 	pop	ar5
      001965 D0 06            [24] 5445 	pop	ar6
      001967 D0 07            [24] 5446 	pop	ar7
      001969                       5447 00136$:
                                   5448 ;	main.c:63: for(uint8_t i=0;i<4;i++)
      001969 0D               [12] 5449 	inc	r5
      00196A 80 86            [24] 5450 	sjmp	00135$
      00196C                       5451 00114$:
                                   5452 ;	main.c:70: UartPrint("\nSelect FAT16 Partition->\n");
      00196C 90r01r2C         [24] 5453 	mov	dptr,#___str_17
      00196F 75 F0 80         [24] 5454 	mov	b,#0x80
      001972 C0 07            [24] 5455 	push	ar7
      001974 C0 06            [24] 5456 	push	ar6
      001976 12r01r1B         [24] 5457 	lcall	_UartPrint
                                   5458 ;	main.c:71: _temp=UartScanByte();
      001979 12r03r5B         [24] 5459 	lcall	_UartScanByte
      00197C AD 82            [24] 5460 	mov	r5,dpl
      00197E D0 06            [24] 5461 	pop	ar6
      001980 D0 07            [24] 5462 	pop	ar7
                                   5463 ;	main.c:72: if( _temp<4 && (_resp & (1<<_temp)) )
      001982 BD 04 00         [24] 5464 	cjne	r5,#0x04,00214$
      001985                       5465 00214$:
      001985 50 43            [24] 5466 	jnc	00119$
      001987 8D F0            [24] 5467 	mov	b,r5
      001989 05 F0            [12] 5468 	inc	b
      00198B 7B 01            [12] 5469 	mov	r3,#0x01
      00198D 7C 00            [12] 5470 	mov	r4,#0x00
      00198F 80 06            [24] 5471 	sjmp	00217$
      001991                       5472 00216$:
      001991 EB               [12] 5473 	mov	a,r3
      001992 2B               [12] 5474 	add	a,r3
      001993 FB               [12] 5475 	mov	r3,a
      001994 EC               [12] 5476 	mov	a,r4
      001995 33               [12] 5477 	rlc	a
      001996 FC               [12] 5478 	mov	r4,a
      001997                       5479 00217$:
      001997 D5 F0 F7         [24] 5480 	djnz	b,00216$
      00199A EB               [12] 5481 	mov	a,r3
      00199B 52 06            [12] 5482 	anl	ar6,a
      00199D EC               [12] 5483 	mov	a,r4
      00199E 52 07            [12] 5484 	anl	ar7,a
      0019A0 EE               [12] 5485 	mov	a,r6
      0019A1 4F               [12] 5486 	orl	a,r7
      0019A2 60 26            [24] 5487 	jz	00119$
                                   5488 ;	main.c:74: UartPrint("Partition Mounted:");UartWriteNumber(_temp,HEX);
      0019A4 90r00rEA         [24] 5489 	mov	dptr,#___str_12
      0019A7 75 F0 80         [24] 5490 	mov	b,#0x80
      0019AA C0 05            [24] 5491 	push	ar5
      0019AC 12r01r1B         [24] 5492 	lcall	_UartPrint
      0019AF D0 05            [24] 5493 	pop	ar5
      0019B1 C0 05            [24] 5494 	push	ar5
      0019B3 E4               [12] 5495 	clr	a
      0019B4 C0 E0            [24] 5496 	push	acc
      0019B6 8D 82            [24] 5497 	mov	dpl,r5
      0019B8 12r01r4D         [24] 5498 	lcall	_UartWriteNumber
      0019BB 15 81            [12] 5499 	dec	sp
                                   5500 ;	main.c:75: UartWrite('\n');
      0019BD 75 82 0A         [24] 5501 	mov	dpl,#0x0a
      0019C0 12r00r95         [24] 5502 	lcall	_UartWrite
      0019C3 D0 05            [24] 5503 	pop	ar5
                                   5504 ;	main.c:76: VBR_MOUNT_VBR(_temp);
      0019C5 8D 82            [24] 5505 	mov	dpl,r5
      0019C7 02r0Er1A         [24] 5506 	ljmp	_VBR_MOUNT_VBR
      0019CA                       5507 00119$:
                                   5508 ;	main.c:80: UartPrint("Invalid selection.\n");
      0019CA 90r01r47         [24] 5509 	mov	dptr,#___str_18
      0019CD 75 F0 80         [24] 5510 	mov	b,#0x80
      0019D0 12r01r1B         [24] 5511 	lcall	_UartPrint
                                   5512 ;	main.c:81: UartPrint(HALTING_MSG); while(1);
      0019D3 90r1ArA8         [24] 5513 	mov	dptr,#_SelectFAT16PartitionPrompt_HALTING_MSG_65536_209
      0019D6 75 F0 80         [24] 5514 	mov	b,#0x80
      0019D9 12r01r1B         [24] 5515 	lcall	_UartPrint
      0019DC                       5516 00116$:
      0019DC 80 FE            [24] 5517 	sjmp	00116$
      0019DE                       5518 00129$:
                                   5519 ;	main.c:89: UartPrint("No FAT16 Partition.\n");
      0019DE 90r01r5B         [24] 5520 	mov	dptr,#___str_19
      0019E1 75 F0 80         [24] 5521 	mov	b,#0x80
      0019E4 12r01r1B         [24] 5522 	lcall	_UartPrint
                                   5523 ;	main.c:90: UartPrint(HALTING_MSG); while(1);
      0019E7 90r1ArA8         [24] 5524 	mov	dptr,#_SelectFAT16PartitionPrompt_HALTING_MSG_65536_209
      0019EA 75 F0 80         [24] 5525 	mov	b,#0x80
      0019ED 12r01r1B         [24] 5526 	lcall	_UartPrint
      0019F0                       5527 00126$:
                                   5528 ;	main.c:93: }
      0019F0 80 FE            [24] 5529 	sjmp	00126$
                                   5530 ;------------------------------------------------------------
                                   5531 ;Allocation info for local variables in function 'SelectFileAndFileOpen'
                                   5532 ;------------------------------------------------------------
                                   5533 ;_result                   Allocated to registers r7 
                                   5534 ;i                         Allocated to registers r7 
                                   5535 ;j                         Allocated to registers r6 
                                   5536 ;------------------------------------------------------------
                                   5537 ;	main.c:95: void SelectFileAndFileOpen() __reentrant
                                   5538 ;	-----------------------------------------
                                   5539 ;	 function SelectFileAndFileOpen
                                   5540 ;	-----------------------------------------
      0019F2                       5541 _SelectFileAndFileOpen:
                                   5542 ;	main.c:98: FAT16_ROOTENTRY_SCAN_RESET();
      0019F2 12r12rB1         [24] 5543 	lcall	_FAT16_ROOTENTRY_SCAN_RESET
                                   5544 ;	main.c:99: UartPrint("ROOTE_INDEX\tFILE\n\n");
      0019F5 90r01r70         [24] 5545 	mov	dptr,#___str_20
      0019F8 75 F0 80         [24] 5546 	mov	b,#0x80
      0019FB 12r01r1B         [24] 5547 	lcall	_UartPrint
                                   5548 ;	main.c:102: for(uint8_t i=0;i<255;i++) 
      0019FE 7F 00            [12] 5549 	mov	r7,#0x00
      001A00                       5550 00112$:
      001A00 BF FF 00         [24] 5551 	cjne	r7,#0xff,00148$
      001A03                       5552 00148$:
      001A03 50 58            [24] 5553 	jnc	00107$
                                   5554 ;	main.c:104: _result = FAT16_ROOTENTRY_SCAN();
      001A05 C0 07            [24] 5555 	push	ar7
      001A07 12r12rC3         [24] 5556 	lcall	_FAT16_ROOTENTRY_SCAN
      001A0A AE 82            [24] 5557 	mov	r6,dpl
      001A0C D0 07            [24] 5558 	pop	ar7
                                   5559 ;	main.c:105: if(_result==0xff) break; //end of scan
      001A0E BE FF 02         [24] 5560 	cjne	r6,#0xff,00150$
      001A11 80 4A            [24] 5561 	sjmp	00107$
      001A13                       5562 00150$:
                                   5563 ;	main.c:106: else if (_result==0) //valid file
      001A13 EE               [12] 5564 	mov	a,r6
      001A14 70 44            [24] 5565 	jnz	00113$
                                   5566 ;	main.c:108: UartWriteNumber(__global_rootEntry.entry_index,DEC); //print root entry index
      001A16 78r3B            [12] 5567 	mov	r0,#(___global_rootEntry + 0x0012)
      001A18 86 06            [24] 5568 	mov	ar6,@r0
      001A1A C0 07            [24] 5569 	push	ar7
      001A1C 74 01            [12] 5570 	mov	a,#0x01
      001A1E C0 E0            [24] 5571 	push	acc
      001A20 8E 82            [24] 5572 	mov	dpl,r6
      001A22 12r01r4D         [24] 5573 	lcall	_UartWriteNumber
      001A25 15 81            [12] 5574 	dec	sp
                                   5575 ;	main.c:109: UartWrite('\t');
      001A27 75 82 09         [24] 5576 	mov	dpl,#0x09
      001A2A 12r00r95         [24] 5577 	lcall	_UartWrite
                                   5578 ;	main.c:110: UartWrite('\t');
      001A2D 75 82 09         [24] 5579 	mov	dpl,#0x09
      001A30 12r00r95         [24] 5580 	lcall	_UartWrite
      001A33 D0 07            [24] 5581 	pop	ar7
                                   5582 ;	main.c:111: for(uint8_t j=0;j<11;j++)UartWrite(__global_rootEntry.name[j]); //print name
      001A35 7E 00            [12] 5583 	mov	r6,#0x00
      001A37                       5584 00109$:
      001A37 BE 0B 00         [24] 5585 	cjne	r6,#0x0b,00152$
      001A3A                       5586 00152$:
      001A3A 50 14            [24] 5587 	jnc	00101$
      001A3C EE               [12] 5588 	mov	a,r6
      001A3D 24r29            [12] 5589 	add	a,#___global_rootEntry
      001A3F F9               [12] 5590 	mov	r1,a
      001A40 87 82            [24] 5591 	mov	dpl,@r1
      001A42 C0 07            [24] 5592 	push	ar7
      001A44 C0 06            [24] 5593 	push	ar6
      001A46 12r00r95         [24] 5594 	lcall	_UartWrite
      001A49 D0 06            [24] 5595 	pop	ar6
      001A4B D0 07            [24] 5596 	pop	ar7
      001A4D 0E               [12] 5597 	inc	r6
      001A4E 80 E7            [24] 5598 	sjmp	00109$
      001A50                       5599 00101$:
                                   5600 ;	main.c:112: UartWrite('\n');
      001A50 75 82 0A         [24] 5601 	mov	dpl,#0x0a
      001A53 C0 07            [24] 5602 	push	ar7
      001A55 12r00r95         [24] 5603 	lcall	_UartWrite
      001A58 D0 07            [24] 5604 	pop	ar7
      001A5A                       5605 00113$:
                                   5606 ;	main.c:102: for(uint8_t i=0;i<255;i++) 
      001A5A 0F               [12] 5607 	inc	r7
      001A5B 80 A3            [24] 5608 	sjmp	00112$
      001A5D                       5609 00107$:
                                   5610 ;	main.c:116: UartPrint("Select ROOTE Index >\n");
      001A5D 90r01r83         [24] 5611 	mov	dptr,#___str_21
      001A60 75 F0 80         [24] 5612 	mov	b,#0x80
      001A63 12r01r1B         [24] 5613 	lcall	_UartPrint
                                   5614 ;	main.c:117: _result=UartScanByte();
      001A66 12r03r5B         [24] 5615 	lcall	_UartScanByte
                                   5616 ;	main.c:118: FAT16_ROOTENTRY_READ(_result); //load the selected
      001A69 7E 00            [12] 5617 	mov	r6,#0x00
      001A6B 8E 83            [24] 5618 	mov	dph,r6
                                   5619 ;	main.c:119: }
      001A6D 02r12r90         [24] 5620 	ljmp	_FAT16_ROOTENTRY_READ
                                   5621 ;------------------------------------------------------------
                                   5622 ;Allocation info for local variables in function 'setup'
                                   5623 ;------------------------------------------------------------
                                   5624 ;	main.c:126: void setup()
                                   5625 ;	-----------------------------------------
                                   5626 ;	 function setup
                                   5627 ;	-----------------------------------------
      001A70                       5628 _setup:
                                   5629 ;	main.c:128: UartBegin();
      001A70 12r00r72         [24] 5630 	lcall	_UartBegin
                                   5631 ;	main.c:129: spi_init(); 
      001A73 12r04r54         [24] 5632 	lcall	_spi_init
                                   5633 ;	main.c:130: SDinit();
                                   5634 ;	main.c:131: }
      001A76 02r06r8D         [24] 5635 	ljmp	_SDinit
                                   5636 ;------------------------------------------------------------
                                   5637 ;Allocation info for local variables in function 'main'
                                   5638 ;------------------------------------------------------------
                                   5639 ;buff                      Allocated with name '_main_buff_65536_230'
                                   5640 ;_resp                     Allocated to registers 
                                   5641 ;_cmd                      Allocated to registers 
                                   5642 ;xram_addr                 Allocated to registers 
                                   5643 ;i                         Allocated to registers 
                                   5644 ;------------------------------------------------------------
                                   5645 ;	main.c:137: void main(void)
                                   5646 ;	-----------------------------------------
                                   5647 ;	 function main
                                   5648 ;	-----------------------------------------
      001A79                       5649 _main:
                                   5650 ;	main.c:148: setup(); //setup peripherals
      001A79 12r1Ar70         [24] 5651 	lcall	_setup
                                   5652 ;	main.c:149: while(UartReadReady())UartRead(); //flush
      001A7C                       5653 00101$:
      001A7C 12r00r81         [24] 5654 	lcall	_UartReadReady
      001A7F E5 82            [12] 5655 	mov	a,dpl
      001A81 60 05            [24] 5656 	jz	00113$
      001A83 12r00r8C         [24] 5657 	lcall	_UartRead
                                   5658 ;	main.c:151: while(1)
      001A86 80 F4            [24] 5659 	sjmp	00101$
      001A88                       5660 00113$:
                                   5661 ;	main.c:153: _cmd=UartRead();
      001A88 12r00r8C         [24] 5662 	lcall	_UartRead
                                   5663 ;	main.c:154: switch (_resp)
                                   5664 ;	main.c:209: while(1);        
                                   5665 ;	main.c:212: }
      001A8B 80 FB            [24] 5666 	sjmp	00113$
                                   5667 	.area CSEG    (CODE)
                                   5668 	.area CONST   (CODE)
                                   5669 	.area CONST   (CODE)
      000000                       5670 ___str_0:
      000000 4E 75 6D 62 65 72 28  5671 	.ascii "Number(HEX, eg FE for 254): "
             48 45 58 2C 20 65 67
             20 46 45 20 66 6F 72
             20 32 35 34 29 3A 20
      00001C 00                    5672 	.db 0x00
                                   5673 	.area CSEG    (CODE)
                                   5674 	.area CONST   (CODE)
      00001D                       5675 ___str_1:
      00001D 56 42 52 3A 20 73 74  5676 	.ascii "VBR: start,bps,spc,reservedSectors,nfat,nroote,spf,fat_start"
             61 72 74 2C 62 70 73
             2C 73 70 63 2C 72 65
             73 65 72 76 65 64 53
             65 63 74 6F 72 73 2C
             6E 66 61 74 2C 6E 72
             6F 6F 74 65 2C 73 70
             66 2C 66 61 74 5F 73
             74 61 72 74
      000059 2C 72 6F 6F 74 65 5F  5677 	.ascii ",roote_start,data_start"
             73 74 61 72 74 2C 64
             61 74 61 5F 73 74 61
             72 74
      000070 0A                    5678 	.db 0x0a
      000071 00                    5679 	.db 0x00
                                   5680 	.area CSEG    (CODE)
                                   5681 	.area CONST   (CODE)
      000072                       5682 ___str_2:
      000072 0A                    5683 	.db 0x0a
      000073 52 4F 4F 54 5F 45 4E  5684 	.ascii "ROOT_ENTRY_INDEX:"
             54 52 59 5F 49 4E 44
             45 58 3A
      000084 00                    5685 	.db 0x00
                                   5686 	.area CSEG    (CODE)
                                   5687 	.area CONST   (CODE)
      000085                       5688 ___str_3:
      000085 0A                    5689 	.db 0x0a
      000086 46 49 4C 45 3A 20     5690 	.ascii "FILE: "
      00008C 00                    5691 	.db 0x00
                                   5692 	.area CSEG    (CODE)
                                   5693 	.area CONST   (CODE)
      00008D                       5694 ___str_4:
      00008D 0A                    5695 	.db 0x0a
      00008E 53 54 41 52 54 3A 20  5696 	.ascii "START: "
      000095 00                    5697 	.db 0x00
                                   5698 	.area CSEG    (CODE)
                                   5699 	.area CONST   (CODE)
      000096                       5700 ___str_5:
      000096 0A                    5701 	.db 0x0a
      000097 53 49 5A 45 3A 20     5702 	.ascii "SIZE: "
      00009D 00                    5703 	.db 0x00
                                   5704 	.area CSEG    (CODE)
                                   5705 	.area CONST   (CODE)
      00009E                       5706 ___str_6:
      00009E 0A                    5707 	.db 0x0a
      00009F 41 54 54 52 3A 20 30  5708 	.ascii "ATTR: 0x"
             78
      0000A7 00                    5709 	.db 0x00
                                   5710 	.area CSEG    (CODE)
      001A8D                       5711 _FAT16_FILE_READ_power2error_65536_182:
      001A8D 6E 62 79 74 65 73 20  5712 	.ascii "nbytes must be power of 2"
             6D 75 73 74 20 62 65
             20 70 6F 77 65 72 20
             6F 66 20 32
      001AA6 0A                    5713 	.db 0x0a
      001AA7 00                    5714 	.db 0x00
                                   5715 	.area CONST   (CODE)
      0000A8                       5716 ___str_8:
      0000A8 46 49 4C 45 20 4E 4F  5717 	.ascii "FILE NOT FOUND"
             54 20 46 4F 55 4E 44
      0000B6 0A                    5718 	.db 0x0a
      0000B7 2E                    5719 	.ascii "."
      0000B8 00                    5720 	.db 0x00
                                   5721 	.area CSEG    (CODE)
                                   5722 	.area CONST   (CODE)
      0000B9                       5723 ___str_9:
      0000B9 49 53 41 5F 53 45 52  5724 	.ascii "ISA_SERIAL_LOADER_V0.1:8052"
             49 41 4C 5F 4C 4F 41
             44 45 52 5F 56 30 2E
             31 3A 38 30 35 32
      0000D4 0A                    5725 	.db 0x0a
      0000D5 00                    5726 	.db 0x00
                                   5727 	.area CSEG    (CODE)
      001AA8                       5728 _SelectFAT16PartitionPrompt_HALTING_MSG_65536_209:
      001AA8 48 41 4C 54 49 4E 47  5729 	.ascii "HALTING..."
             2E 2E 2E
      001AB2 00                    5730 	.db 0x00
                                   5731 	.area CONST   (CODE)
      0000D6                       5732 ___str_11:
      0000D6 45 52 52 4F 52 3A 4E  5733 	.ascii "ERROR:NO MBR FOUND"
             4F 20 4D 42 52 20 46
             4F 55 4E 44
      0000E8 0A                    5734 	.db 0x0a
      0000E9 00                    5735 	.db 0x00
                                   5736 	.area CSEG    (CODE)
                                   5737 	.area CONST   (CODE)
      0000EA                       5738 ___str_12:
      0000EA 50 61 72 74 69 74 69  5739 	.ascii "Partition Mounted:"
             6F 6E 20 4D 6F 75 6E
             74 65 64 3A
      0000FC 00                    5740 	.db 0x00
                                   5741 	.area CSEG    (CODE)
                                   5742 	.area CONST   (CODE)
      0000FD                       5743 ___str_13:
      0000FD 49 6E 63 6F 6D 70 61  5744 	.ascii "Incompatible FAT16"
             74 69 62 6C 65 20 46
             41 54 31 36
      00010F 0A                    5745 	.db 0x0a
      000110 00                    5746 	.db 0x00
                                   5747 	.area CSEG    (CODE)
                                   5748 	.area CONST   (CODE)
      000111                       5749 ___str_14:
      000111 50 61 72 74 69 74 69  5750 	.ascii "Partition-"
             6F 6E 2D
      00011B 00                    5751 	.db 0x00
                                   5752 	.area CSEG    (CODE)
                                   5753 	.area CONST   (CODE)
      00011C                       5754 ___str_15:
      00011C 46 41 54 31 36        5755 	.ascii "FAT16"
      000121 0A                    5756 	.db 0x0a
      000122 00                    5757 	.db 0x00
                                   5758 	.area CSEG    (CODE)
                                   5759 	.area CONST   (CODE)
      000123                       5760 ___str_16:
      000123 55 6E 6B 6E 6F 77 6E  5761 	.ascii "Unknown"
      00012A 0A                    5762 	.db 0x0a
      00012B 00                    5763 	.db 0x00
                                   5764 	.area CSEG    (CODE)
                                   5765 	.area CONST   (CODE)
      00012C                       5766 ___str_17:
      00012C 0A                    5767 	.db 0x0a
      00012D 53 65 6C 65 63 74 20  5768 	.ascii "Select FAT16 Partition->"
             46 41 54 31 36 20 50
             61 72 74 69 74 69 6F
             6E 2D 3E
      000145 0A                    5769 	.db 0x0a
      000146 00                    5770 	.db 0x00
                                   5771 	.area CSEG    (CODE)
                                   5772 	.area CONST   (CODE)
      000147                       5773 ___str_18:
      000147 49 6E 76 61 6C 69 64  5774 	.ascii "Invalid selection."
             20 73 65 6C 65 63 74
             69 6F 6E 2E
      000159 0A                    5775 	.db 0x0a
      00015A 00                    5776 	.db 0x00
                                   5777 	.area CSEG    (CODE)
                                   5778 	.area CONST   (CODE)
      00015B                       5779 ___str_19:
      00015B 4E 6F 20 46 41 54 31  5780 	.ascii "No FAT16 Partition."
             36 20 50 61 72 74 69
             74 69 6F 6E 2E
      00016E 0A                    5781 	.db 0x0a
      00016F 00                    5782 	.db 0x00
                                   5783 	.area CSEG    (CODE)
                                   5784 	.area CONST   (CODE)
      000170                       5785 ___str_20:
      000170 52 4F 4F 54 45 5F 49  5786 	.ascii "ROOTE_INDEX"
             4E 44 45 58
      00017B 09                    5787 	.db 0x09
      00017C 46 49 4C 45           5788 	.ascii "FILE"
      000180 0A                    5789 	.db 0x0a
      000181 0A                    5790 	.db 0x0a
      000182 00                    5791 	.db 0x00
                                   5792 	.area CSEG    (CODE)
                                   5793 	.area CONST   (CODE)
      000183                       5794 ___str_21:
      000183 53 65 6C 65 63 74 20  5795 	.ascii "Select ROOTE Index >"
             52 4F 4F 54 45 20 49
             6E 64 65 78 20 3E
      000197 0A                    5796 	.db 0x0a
      000198 00                    5797 	.db 0x00
                                   5798 	.area CSEG    (CODE)
                                   5799 	.area CONST   (CODE)
      000199                       5800 ___str_22:
      000199 49 53 41 2D 46 41 54  5801 	.ascii "ISA-FAT16+SERIAL-LOADER: V1.0"
             31 36 2B 53 45 52 49
             41 4C 2D 4C 4F 41 44
             45 52 3A 20 56 31 2E
             30
      0001B6 0A                    5802 	.db 0x0a
      0001B7 00                    5803 	.db 0x00
                                   5804 	.area CSEG    (CODE)
                                   5805 	.area CONST   (CODE)
      0001B8                       5806 ___str_23:
      0001B8 0D                    5807 	.db 0x0d
      0001B9 00                    5808 	.db 0x00
                                   5809 	.area CSEG    (CODE)
                                   5810 	.area XINIT   (CODE)
                                   5811 	.area CABS    (ABS,CODE)
